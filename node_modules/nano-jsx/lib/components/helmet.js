"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Helmet = void 0;
const component_js_1 = require("../component.js");
const core_js_1 = require("../core.js");
class Attributes extends Map {
    toString() {
        let string = '';
        for (const [key, value] of this)
            string += ` ${key}="${value}"`;
        return string.trim();
    }
}
class Helmet extends component_js_1.Component {
    static SSR(body) {
        var _a, _b;
        const reg = /(<helmet\b[^>]*>)((.|\r|\n)*?)(<\/helmet>)/gm;
        // collect all elements
        const head = [];
        const footer = [];
        const attributes = {
            html: new Attributes(),
            body: new Attributes()
        };
        // get what's in the head
        if (typeof document !== 'undefined' && document.head) {
            let children = [];
            children = [].slice.call(document.head.children);
            for (let i = 0; i < children.length; i++) {
                // check if the same element already exists
                if (head.indexOf(children[i]) === -1) {
                    head.push(children[i]);
                }
            }
        }
        let result;
        while ((result = reg.exec(body)) !== null) {
            const first = result[1];
            let second = result[2];
            const regHTML = /<html\s([^>]+)><\/html>/gm;
            const regBody = /<body\s([^>]+)><\/body>/gm;
            const regAttr = /(\w+)="([^"]+)"/gm;
            let res = null;
            // extract html attributes
            (_a = body.match(regHTML)) === null || _a === void 0 ? void 0 : _a.forEach(h => {
                second = second.replace(h, '');
                while ((res = regAttr.exec(h)) !== null) {
                    attributes.html.set(res[1], res[2]);
                }
            });
            // extract body attributes
            (_b = body.match(regBody)) === null || _b === void 0 ? void 0 : _b.forEach(b => {
                second = second.replace(b, '');
                while ((res = regAttr.exec(b)) !== null) {
                    attributes.body.set(res[1], res[2]);
                }
            });
            const toHead = first.includes('data-placement="head"');
            // do not add an element if it already exists
            if (toHead && !head.includes(second))
                head.push(second);
            else if (!toHead && !footer.includes(second))
                footer.push(second);
        }
        // clean the body from all matches
        const cleanBody = body.replace(reg, '');
        return {
            body: cleanBody,
            head: head,
            footer: footer,
            attributes
        };
    }
    didMount() {
        this.props.children.forEach((element) => {
            var _a, _b, _c, _d;
            // return if it is not an html element
            if (!(element instanceof HTMLElement))
                return;
            const parent = this.props.footer ? document.body : document.head;
            const tag = element.tagName;
            let attrs = [];
            // get the inner text
            attrs.push(element.innerText);
            // get all attributes
            for (let attr = 0; attr < element.attributes.length; attr++) {
                attrs.push((_a = element.attributes.item(attr)) === null || _a === void 0 ? void 0 : _a.name.toLowerCase());
                attrs.push((_b = element.attributes.item(attr)) === null || _b === void 0 ? void 0 : _b.value.toLowerCase());
            }
            // handle special tags
            if (tag === 'HTML' || tag === 'BODY') {
                const htmlTag = document.getElementsByTagName(tag)[0];
                for (let attr = 1; attr < attrs.length; attr += 2) {
                    htmlTag.setAttribute(attrs[attr], attrs[attr + 1]);
                }
                return;
            }
            else if (tag === 'TITLE') {
                const titleTags = document.getElementsByTagName('TITLE');
                if (titleTags.length > 0) {
                    const e = element;
                    titleTags[0].text = e.text;
                }
                else {
                    const titleTag = (0, core_js_1.h)('title', null, element.innerHTML);
                    (0, core_js_1.appendChildren)(parent, [titleTag], false);
                }
                return;
            }
            // check if the element already exists
            let exists = false;
            attrs = attrs.sort();
            const el = document.getElementsByTagName(tag);
            for (let i = 0; i < el.length; i++) {
                let attrs2 = [];
                // get the inner text
                attrs2.push(el[i].innerText);
                for (let attr = 0; attr < el[i].attributes.length; attr++) {
                    attrs2.push((_c = el[i].attributes.item(attr)) === null || _c === void 0 ? void 0 : _c.name.toLowerCase());
                    attrs2.push((_d = el[i].attributes.item(attr)) === null || _d === void 0 ? void 0 : _d.value.toLowerCase());
                }
                attrs2 = attrs2.sort();
                if (attrs.length > 0 && attrs2.length > 0 && JSON.stringify(attrs) === JSON.stringify(attrs2))
                    exists = true;
            }
            // add to dom
            if (!exists)
                (0, core_js_1.appendChildren)(parent, [element], false);
        });
    }
    render() {
        const placement = this.props.footer ? 'footer' : 'head';
        if ((0, core_js_1.isSSR)())
            return (0, core_js_1.h)('helmet', { 'data-ssr': true, 'data-placement': placement }, this.props.children);
        else
            return [];
    }
}
exports.Helmet = Helmet;
//# sourceMappingURL=helmet.js.map