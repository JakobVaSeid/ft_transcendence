"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.h = exports._render = exports.hydrate = exports.render = exports.appendChildren = exports.strToHash = exports.removeAllChildNodes = exports.tick = exports.isSSR = void 0;
require("./types.js");
const isSSR = () => typeof _nano !== 'undefined' && _nano.isSSR === true;
exports.isSSR = isSSR;
/** Creates a new Microtask using Promise() */
exports.tick = Promise.prototype.then.bind(Promise.resolve());
const removeAllChildNodes = (parent) => {
    while (parent.firstChild) {
        parent.removeChild(parent.firstChild);
    }
};
exports.removeAllChildNodes = removeAllChildNodes;
// https://stackoverflow.com/a/7616484/12656855
const strToHash = (s) => {
    let hash = 0;
    for (let i = 0; i < s.length; i++) {
        const chr = s.charCodeAt(i);
        hash = (hash << 5) - hash + chr;
        hash |= 0; // Convert to 32bit integer
    }
    return Math.abs(hash).toString(32);
};
exports.strToHash = strToHash;
const appendChildren = (element, children, escape = true) => {
    // if the child is an html element
    if (!Array.isArray(children)) {
        (0, exports.appendChildren)(element, [children], escape);
        return;
    }
    // htmlCollection to array
    if (typeof children === 'object')
        children = Array.prototype.slice.call(children);
    children.forEach(child => {
        // if child is an array of children, append them instead
        if (Array.isArray(child))
            (0, exports.appendChildren)(element, child, escape);
        else {
            // render the component
            const c = (0, exports._render)(child);
            if (typeof c !== 'undefined') {
                // if c is an array of children, append them instead
                if (Array.isArray(c))
                    (0, exports.appendChildren)(element, c, escape);
                // apply the component to parent element
                else {
                    if ((0, exports.isSSR)() && !escape)
                        element.appendChild(c.nodeType == null ? c.toString() : c);
                    else
                        element.appendChild(c.nodeType == null ? document.createTextNode(c.toString()) : c);
                }
            }
        }
    });
};
exports.appendChildren = appendChildren;
/**
 * A simple component for rendering SVGs
 */
const SVG = (props) => {
    const child = props.children[0];
    const attrs = child.attributes;
    if ((0, exports.isSSR)())
        return child;
    const svg = hNS('svg');
    for (let i = attrs.length - 1; i >= 0; i--) {
        svg.setAttribute(attrs[i].name, attrs[i].value);
    }
    svg.innerHTML = child.innerHTML;
    return svg;
};
/** Returns the populated parent if available else  one child or an array of children */
const render = (component, parent = null, removeChildNodes = true) => {
    let el = (0, exports._render)(component);
    if (Array.isArray(el)) {
        el = el.map(e => (0, exports._render)(e));
        if (el.length === 1)
            el = el[0];
    }
    if (parent) {
        if (removeChildNodes)
            (0, exports.removeAllChildNodes)(parent);
        // if parent and child are the same, we replace the parent instead of appending to it
        if (el && parent.id && parent.id === el.id && parent.parentElement) {
            parent.parentElement.replaceChild(el, parent);
        }
        else {
            // append element(s) to the parent
            if (Array.isArray(el))
                el.forEach((e) => {
                    (0, exports.appendChildren)(parent, (0, exports._render)(e));
                    //parent.appendChild(_render(e))
                });
            else
                (0, exports.appendChildren)(parent, (0, exports._render)(el));
        }
        return parent;
    }
    // returning one child or an array of children
    else {
        if ((0, exports.isSSR)() && !Array.isArray(el))
            return [el];
        return el;
    }
};
exports.render = render;
exports.hydrate = exports.render;
const _render = (comp) => {
    // null, false, undefined
    if (comp === null || comp === false || typeof comp === 'undefined')
        return [];
    // string, number
    if (typeof comp === 'string' || typeof comp === 'number')
        return comp.toString();
    // SVGElement
    if (comp.tagName && comp.tagName.toLowerCase() === 'svg')
        return SVG({ children: [comp] });
    // HTMLElement
    if (comp.tagName)
        return comp;
    // TEXTNode (Node.TEXT_NODE === 3)
    if (comp && comp.nodeType === 3)
        return comp;
    // Class Component
    if (comp && comp.component && comp.component.isClass)
        return renderClassComponent(comp);
    // Class Component (Uninitialized)
    if (comp.isClass)
        return renderClassComponent({ component: comp, props: {} });
    // Functional Component
    if (comp.component && typeof comp.component === 'function')
        return renderFunctionalComponent(comp);
    // Array (render each child and return the array) (is probably a fragment)
    if (Array.isArray(comp))
        return comp.map(c => (0, exports._render)(c)).flat();
    // function
    if (typeof comp === 'function' && !comp.isClass)
        return (0, exports._render)(comp());
    // if component is a HTMLElement (rare case)
    if (comp.component && comp.component.tagName && typeof comp.component.tagName === 'string')
        return (0, exports._render)(comp.component);
    // (rare case)
    if (Array.isArray(comp.component))
        return (0, exports._render)(comp.component);
    // (rare case)
    if (comp.component)
        return (0, exports._render)(comp.component);
    // object
    if (typeof comp === 'object')
        return [];
    console.warn('Something unexpected happened with:', comp);
};
exports._render = _render;
const renderFunctionalComponent = (fncComp) => {
    const { component, props } = fncComp;
    return (0, exports._render)(component(props));
};
const renderClassComponent = (classComp) => {
    const { component, props } = classComp;
    // calc hash
    const hash = (0, exports.strToHash)(component.toString());
    // make hash accessible in constructor, without passing it to it
    component.prototype._getHash = () => hash;
    const Component = new component(props);
    if (!(0, exports.isSSR)())
        Component.willMount();
    let el = Component.render();
    el = (0, exports._render)(el);
    Component.elements = el;
    // pass the component instance as ref
    if (props && props.ref)
        props.ref(Component);
    if (!(0, exports.isSSR)())
        (0, exports.tick)(() => {
            Component._didMount();
        });
    return el;
};
const hNS = (tag) => document.createElementNS('http://www.w3.org/2000/svg', tag);
// https://stackoverflow.com/a/42405694/12656855
const h = (tagNameOrComponent, props = {}, ...children) => {
    // if children is passed as props, merge with ...children
    if (props && props.children) {
        if (Array.isArray(children)) {
            if (Array.isArray(props.children))
                children = [...props.children, ...children];
            else
                children.push(props.children);
        }
        else {
            if (Array.isArray(props.children))
                children = props.children;
            else
                children = [props.children];
        }
    }
    // render WebComponent in SSR
    if ((0, exports.isSSR)() && _nano.ssrTricks.isWebComponent(tagNameOrComponent)) {
        const element = _nano.ssrTricks.renderWebComponent(tagNameOrComponent, props, children, exports._render);
        if (element === null)
            return `ERROR: "<${tagNameOrComponent} />"`;
        else
            return element;
    }
    // if tagNameOrComponent is a component
    if (typeof tagNameOrComponent !== 'string')
        return { component: tagNameOrComponent, props: Object.assign(Object.assign({}, props), { children: children }) };
    // custom message if document is not defined in SSR
    try {
        if ((0, exports.isSSR)() && typeof tagNameOrComponent === 'string' && !document)
            throw new Error('document is not defined');
    }
    catch (err) {
        console.log('ERROR:', err.message, '\n > Please read: https://github.com/nanojsx/nano/issues/106');
    }
    let ref;
    const element = tagNameOrComponent === 'svg'
        ? hNS('svg')
        : document.createElement(tagNameOrComponent);
    // check if the element includes the event (for example 'oninput')
    const isEvent = (el, p) => {
        // check if the event begins with 'on'
        if (0 !== p.indexOf('on'))
            return false;
        // we return true if SSR, since otherwise it will get rendered
        if (el._ssr)
            return true;
        // check if the event is present in the element as object (null) or as function
        return typeof el[p] === 'object' || typeof el[p] === 'function';
    };
    for (const p in props) {
        // https://stackoverflow.com/a/45205645/12656855
        // style object to style string
        if (p === 'style' && typeof props[p] === 'object') {
            const styles = Object.keys(props[p])
                .map(k => `${k}:${props[p][k]}`)
                .join(';')
                .replace(/[A-Z]/g, match => `-${match.toLowerCase()}`);
            props[p] = `${styles};`;
        }
        // handel ref
        if (p === 'ref')
            ref = props[p];
        // handle events
        else if (isEvent(element, p.toLowerCase()))
            element.addEventListener(p.toLowerCase().substring(2), (e) => props[p](e));
        // dangerouslySetInnerHTML
        else if (p === 'dangerouslySetInnerHTML' && props[p].__html) {
            if (!(0, exports.isSSR)()) {
                const fragment = document.createElement('fragment');
                fragment.innerHTML = props[p].__html;
                element.appendChild(fragment);
            }
            else {
                element.innerHTML = props[p].__html;
            }
        }
        // modern dangerouslySetInnerHTML
        else if (p === 'innerHTML' && props[p].__dangerousHtml) {
            if (!(0, exports.isSSR)()) {
                const fragment = document.createElement('fragment');
                fragment.innerHTML = props[p].__dangerousHtml;
                element.appendChild(fragment);
            }
            else {
                element.innerHTML = props[p].__dangerousHtml;
            }
        }
        // className
        else if (/^className$/i.test(p))
            element.setAttribute('class', props[p]);
        // setAttribute
        else if (typeof props[p] !== 'undefined')
            element.setAttribute(p, props[p]);
    }
    // these tags should not be escaped by default (in ssr)
    const escape = !['noscript', 'script', 'style'].includes(tagNameOrComponent);
    (0, exports.appendChildren)(element, children, escape);
    if (ref)
        ref(element);
    return element;
};
exports.h = h;
//# sourceMappingURL=core.js.map