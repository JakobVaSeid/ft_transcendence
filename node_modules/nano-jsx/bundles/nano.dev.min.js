var nanoJSX;
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./lib/bundles/bundle.full.js":
/*!************************************!*\
  !*** ./lib/bundles/bundle.full.js ***!
  \************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.VERSION = exports.printVersion = void 0;
// core
const core_js_1 = __webpack_require__(/*! ../core.js */ "./lib/core.js");
const lazy_js_1 = __webpack_require__(/*! ../lazy.js */ "./lib/lazy.js");
const helpers_js_1 = __webpack_require__(/*! ../helpers.js */ "./lib/helpers.js");
// useful tools
const component_js_1 = __webpack_require__(/*! ../component.js */ "./lib/component.js");
const fragment_js_1 = __webpack_require__(/*! ../fragment.js */ "./lib/fragment.js");
const store_js_1 = __webpack_require__(/*! ../store.js */ "./lib/store.js");
const context_js_1 = __webpack_require__(/*! ../context.js */ "./lib/context.js");
const withStyles_js_1 = __webpack_require__(/*! ../withStyles.js */ "./lib/withStyles.js");
// built-in components
const helmet_js_1 = __webpack_require__(/*! ../components/helmet.js */ "./lib/components/helmet.js");
const link_js_1 = __webpack_require__(/*! ../components/link.js */ "./lib/components/link.js");
const img_js_1 = __webpack_require__(/*! ../components/img.js */ "./lib/components/img.js");
const visible_js_1 = __webpack_require__(/*! ../components/visible.js */ "./lib/components/visible.js");
const Router = __importStar(__webpack_require__(/*! ../components/router.js */ "./lib/components/router.js"));
// customElement
const customElementsMode_js_1 = __webpack_require__(/*! ../customElementsMode.js */ "./lib/customElementsMode.js");
// tagged templates
const jsx_js_1 = __webpack_require__(/*! ../jsx.js */ "./lib/jsx.js");
// ui
const UI = __importStar(__webpack_require__(/*! ../ui/index.js */ "./lib/ui/index.js"));
exports["default"] = {
    Component: component_js_1.Component,
    Fragment: fragment_js_1.Fragment,
    Helmet: helmet_js_1.Helmet,
    Img: img_js_1.Img,
    Link: link_js_1.Link,
    Router,
    Store: store_js_1.Store,
    UI,
    Visible: visible_js_1.Visible,
    createContext: context_js_1.createContext,
    h: core_js_1.h,
    hydrate: core_js_1.hydrate,
    hydrateLazy: lazy_js_1.hydrateLazy,
    jsx: jsx_js_1.jsx,
    nodeToString: helpers_js_1.nodeToString,
    removeAllChildNodes: core_js_1.removeAllChildNodes,
    render: core_js_1.render,
    task: helpers_js_1.task,
    tick: core_js_1.tick,
    withStyles: withStyles_js_1.withStyles,
    defineAsCustomElements: customElementsMode_js_1.defineAsCustomElements
};
// version
var helpers_js_2 = __webpack_require__(/*! ../helpers.js */ "./lib/helpers.js");
Object.defineProperty(exports, "printVersion", ({ enumerable: true, get: function () { return helpers_js_2.printVersion; } }));
var version_js_1 = __webpack_require__(/*! ../version.js */ "./lib/version.js");
Object.defineProperty(exports, "VERSION", ({ enumerable: true, get: function () { return version_js_1.VERSION; } }));
//# sourceMappingURL=bundle.full.js.map

/***/ }),

/***/ "./lib/component.js":
/*!**************************!*\
  !*** ./lib/component.js ***!
  \**************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Component = void 0;
const helpers_js_1 = __webpack_require__(/*! ./helpers.js */ "./lib/helpers.js");
const core_js_1 = __webpack_require__(/*! ./core.js */ "./lib/core.js");
const state_js_1 = __webpack_require__(/*! ./state.js */ "./lib/state.js");
class Component {
    constructor(props) {
        this._elements = [];
        this._skipUnmount = false;
        this._hasUnmounted = false;
        this.props = props || {};
        this.id = this._getHash();
    }
    static get isClass() {
        return true;
    }
    get isClass() {
        return true;
    }
    setState(state, shouldUpdate = false) {
        const isObject = typeof state === 'object' && state !== null;
        // if state is an object, we merge the objects
        if (isObject && this.state !== undefined)
            this.state = Object.assign(Object.assign({}, this.state), state);
        // else, we just overwrite it
        else
            this.state = state;
        if (shouldUpdate)
            this.update();
    }
    set state(state) {
        state_js_1._state.set(this.id, state);
    }
    get state() {
        return state_js_1._state.get(this.id);
    }
    set initState(state) {
        if (this.state === undefined)
            this.state = state;
    }
    /** Returns all currently rendered node elements */
    get elements() {
        return this._elements || [];
    }
    set elements(elements) {
        if (!Array.isArray(elements))
            elements = [elements];
        elements.forEach(element => {
            this._elements.push(element);
        });
    }
    _addNodeRemoveListener() {
        // check if didUnmount is unused
        if (/^[^{]+{\s+}$/gm.test(this.didUnmount.toString()))
            return;
        // listen if the root elements gets removed
        (0, helpers_js_1.onNodeRemove)(this.elements[0], () => {
            if (!this._skipUnmount)
                this._didUnmount();
        });
    }
    // @ts-ignore
    _didMount() {
        this._addNodeRemoveListener();
        this.didMount();
    }
    _willUpdate() {
        this.willUpdate();
    }
    _didUpdate() {
        this.didUpdate();
    }
    _didUnmount() {
        if (this._hasUnmounted)
            return;
        this.didUnmount();
        this._hasUnmounted = true;
    }
    willMount() { }
    didMount() { }
    willUpdate() { }
    didUpdate() { }
    didUnmount() { }
    render(_update) { }
    /** Will forceRender the component */
    update(update) {
        this._skipUnmount = true;
        this._willUpdate();
        // get all current rendered node elements
        const oldElements = [...this.elements];
        // clear
        this._elements = [];
        let el = this.render(update);
        el = (0, core_js_1._render)(el);
        this.elements = el;
        // console.log('old: ', oldElements)
        // console.log('new: ', this.elements)
        // get valid parent node
        const parent = oldElements[0].parentElement;
        // make sure we have a parent
        if (!parent)
            console.warn('Component needs a parent element to get updated!');
        // add all new node elements
        this.elements.forEach((child) => {
            if (parent)
                parent.insertBefore(child, oldElements[0]);
        });
        // remove all elements
        oldElements.forEach((child) => {
            // wee keep the element if it is the same, for example if passed as a child
            if (!this.elements.includes(child)) {
                child.remove();
                // @ts-ignore
                child = null;
            }
        });
        // listen for node removal
        this._addNodeRemoveListener();
        // @ts-ignore
        (0, core_js_1.tick)(() => {
            this._skipUnmount = false;
            if (!this.elements[0].isConnected)
                this._didUnmount();
            else
                this._didUpdate();
        });
    }
    _getHash() { }
}
exports.Component = Component;
//# sourceMappingURL=component.js.map

/***/ }),

/***/ "./lib/components/helmet.js":
/*!**********************************!*\
  !*** ./lib/components/helmet.js ***!
  \**********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Helmet = void 0;
const component_js_1 = __webpack_require__(/*! ../component.js */ "./lib/component.js");
const core_js_1 = __webpack_require__(/*! ../core.js */ "./lib/core.js");
class Attributes extends Map {
    toString() {
        let string = '';
        for (const [key, value] of this)
            string += ` ${key}="${value}"`;
        return string.trim();
    }
}
class Helmet extends component_js_1.Component {
    static SSR(body) {
        var _a, _b;
        const reg = /(<helmet\b[^>]*>)((.|\r|\n)*?)(<\/helmet>)/gm;
        // collect all elements
        const head = [];
        const footer = [];
        const attributes = {
            html: new Attributes(),
            body: new Attributes()
        };
        // get what's in the head
        if (typeof document !== 'undefined' && document.head) {
            let children = [];
            children = [].slice.call(document.head.children);
            for (let i = 0; i < children.length; i++) {
                // check if the same element already exists
                if (head.indexOf(children[i]) === -1) {
                    head.push(children[i]);
                }
            }
        }
        let result;
        while ((result = reg.exec(body)) !== null) {
            const first = result[1];
            let second = result[2];
            const regHTML = /<html\s([^>]+)><\/html>/gm;
            const regBody = /<body\s([^>]+)><\/body>/gm;
            const regAttr = /(\w+)="([^"]+)"/gm;
            let res = null;
            // extract html attributes
            (_a = body.match(regHTML)) === null || _a === void 0 ? void 0 : _a.forEach(h => {
                second = second.replace(h, '');
                while ((res = regAttr.exec(h)) !== null) {
                    attributes.html.set(res[1], res[2]);
                }
            });
            // extract body attributes
            (_b = body.match(regBody)) === null || _b === void 0 ? void 0 : _b.forEach(b => {
                second = second.replace(b, '');
                while ((res = regAttr.exec(b)) !== null) {
                    attributes.body.set(res[1], res[2]);
                }
            });
            const toHead = first.includes('data-placement="head"');
            // do not add an element if it already exists
            if (toHead && !head.includes(second))
                head.push(second);
            else if (!toHead && !footer.includes(second))
                footer.push(second);
        }
        // clean the body from all matches
        const cleanBody = body.replace(reg, '');
        return {
            body: cleanBody,
            head: head,
            footer: footer,
            attributes
        };
    }
    didMount() {
        this.props.children.forEach((element) => {
            var _a, _b, _c, _d;
            // return if it is not an html element
            if (!(element instanceof HTMLElement))
                return;
            const parent = this.props.footer ? document.body : document.head;
            const tag = element.tagName;
            let attrs = [];
            // get the inner text
            attrs.push(element.innerText);
            // get all attributes
            for (let attr = 0; attr < element.attributes.length; attr++) {
                attrs.push((_a = element.attributes.item(attr)) === null || _a === void 0 ? void 0 : _a.name.toLowerCase());
                attrs.push((_b = element.attributes.item(attr)) === null || _b === void 0 ? void 0 : _b.value.toLowerCase());
            }
            // handle special tags
            if (tag === 'HTML' || tag === 'BODY') {
                const htmlTag = document.getElementsByTagName(tag)[0];
                for (let attr = 1; attr < attrs.length; attr += 2) {
                    htmlTag.setAttribute(attrs[attr], attrs[attr + 1]);
                }
                return;
            }
            else if (tag === 'TITLE') {
                const titleTags = document.getElementsByTagName('TITLE');
                if (titleTags.length > 0) {
                    const e = element;
                    titleTags[0].text = e.text;
                }
                else {
                    const titleTag = (0, core_js_1.h)('title', null, element.innerHTML);
                    (0, core_js_1.appendChildren)(parent, [titleTag], false);
                }
                return;
            }
            // check if the element already exists
            let exists = false;
            attrs = attrs.sort();
            const el = document.getElementsByTagName(tag);
            for (let i = 0; i < el.length; i++) {
                let attrs2 = [];
                // get the inner text
                attrs2.push(el[i].innerText);
                for (let attr = 0; attr < el[i].attributes.length; attr++) {
                    attrs2.push((_c = el[i].attributes.item(attr)) === null || _c === void 0 ? void 0 : _c.name.toLowerCase());
                    attrs2.push((_d = el[i].attributes.item(attr)) === null || _d === void 0 ? void 0 : _d.value.toLowerCase());
                }
                attrs2 = attrs2.sort();
                if (attrs.length > 0 && attrs2.length > 0 && JSON.stringify(attrs) === JSON.stringify(attrs2))
                    exists = true;
            }
            // add to dom
            if (!exists)
                (0, core_js_1.appendChildren)(parent, [element], false);
        });
    }
    render() {
        const placement = this.props.footer ? 'footer' : 'head';
        if ((0, core_js_1.isSSR)())
            return (0, core_js_1.h)('helmet', { 'data-ssr': true, 'data-placement': placement }, this.props.children);
        else
            return [];
    }
}
exports.Helmet = Helmet;
//# sourceMappingURL=helmet.js.map

/***/ }),

/***/ "./lib/components/img.js":
/*!*******************************!*\
  !*** ./lib/components/img.js ***!
  \*******************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Img = void 0;
const component_js_1 = __webpack_require__(/*! ../component.js */ "./lib/component.js");
const core_js_1 = __webpack_require__(/*! ../core.js */ "./lib/core.js");
/**
 * A useful Image component
 * Add <Img lazy ..., to lazy load the img source
 * Add <Img width="100" height="100" ..., to specify img element's size.
 * Add <Img placeholder="src or element" ...., to prepare placeholder for img.
 */
class Img extends component_js_1.Component {
    constructor(props) {
        super(props);
        const { src, key } = props;
        // id has to be unique
        this.id = `${(0, core_js_1.strToHash)(src)}-${(0, core_js_1.strToHash)(JSON.stringify(props))}`;
        if (key)
            this.id += `key-${key}`;
        // this could also be done in willMount()
        if (!this.state)
            this.setState({ isLoaded: false, image: undefined });
    }
    didMount() {
        const _a = this.props, { lazy = true, placeholder, children, key, ref } = _a, rest = __rest(_a, ["lazy", "placeholder", "children", "key", "ref"]);
        if (typeof lazy === 'boolean' && lazy === false)
            return;
        const observer = new IntersectionObserver((entries, observer) => {
            entries.forEach(entry => {
                if (entry.isIntersecting) {
                    observer.disconnect();
                    this.state.image = (0, core_js_1.h)('img', Object.assign({}, rest));
                    if (this.state.image.complete) {
                        this.state.isLoaded = true;
                        this.update();
                    }
                    else {
                        this.state.image.onload = () => {
                            this.state.isLoaded = true;
                            this.update();
                        };
                    }
                }
            });
        }, { threshold: [0, 1] });
        observer.observe(this.elements[0]);
    }
    render() {
        const _a = this.props, { src, placeholder, children, lazy = true, key, ref } = _a, rest = __rest(_a, ["src", "placeholder", "children", "lazy", "key", "ref"]);
        // return the img tag if not lazy loaded
        if (typeof lazy === 'boolean' && lazy === false) {
            this.state.image = (0, core_js_1.h)('img', Object.assign({ src }, rest));
            return this.state.image;
        }
        // if it is visible and loaded, show the image
        if (this.state.isLoaded) {
            return this.state.image;
            // if the placeholder is an image src
        }
        else if (placeholder && typeof placeholder === 'string') {
            return (0, core_js_1.h)('img', Object.assign({ src: placeholder }, rest));
            // if the placeholder is an JSX element
        }
        else if (placeholder && typeof placeholder === 'function') {
            return placeholder();
        }
        else {
            // render a simple box
            const style = {};
            if (rest.width)
                style.width = `${rest.width}px`;
            if (rest.height)
                style.height = `${rest.height}px`;
            const { width, height } = rest, others = __rest(rest, ["width", "height"]);
            return (0, core_js_1.h)('div', Object.assign({ style }, others));
        }
    }
}
exports.Img = Img;
//# sourceMappingURL=img.js.map

/***/ }),

/***/ "./lib/components/link.js":
/*!********************************!*\
  !*** ./lib/components/link.js ***!
  \********************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Link = void 0;
const component_js_1 = __webpack_require__(/*! ../component.js */ "./lib/component.js");
const helmet_js_1 = __webpack_require__(/*! ./helmet.js */ "./lib/components/helmet.js");
const core_js_1 = __webpack_require__(/*! ../core.js */ "./lib/core.js");
const fragment_js_1 = __webpack_require__(/*! ../fragment.js */ "./lib/fragment.js");
/**
 * A simple Link component
 * Add <Link prefetch ..., to prefetch the html document
 * Add <Link prefetch="hover" ..., to prefetch the html document on hovering over the link element.
 */
class Link extends component_js_1.Component {
    prefetchOnHover() {
        this.elements[0].addEventListener('mouseover', () => this.addPrefetch(), { once: true });
    }
    prefetchOnVisible() {
        const observer = new IntersectionObserver((entries, observer) => {
            entries.forEach(entry => {
                if (entry.isIntersecting) {
                    observer.disconnect();
                    this.addPrefetch();
                }
            });
        }, { threshold: [0, 1] });
        observer.observe(this.elements[0]);
    }
    addPrefetch() {
        let doesAlreadyExist = false;
        // check if it is already on the dom
        const links = document.getElementsByTagName('link');
        for (let i = 0; i < links.length; i++) {
            // if it is not already on the dom, add it
            if (links[i].getAttribute('rel') === 'prefetch' && links[i].getAttribute('href') === this.props.href) {
                doesAlreadyExist = true;
            }
        }
        if (!doesAlreadyExist) {
            const prefetch = (0, core_js_1.h)('link', { rel: 'prefetch', href: this.props.href, as: 'document' });
            document.head.appendChild(prefetch);
        }
    }
    didMount() {
        const { href, prefetch, delay = 0, back = false } = this.props;
        if (back)
            this.elements[0].addEventListener('click', (e) => {
                e.preventDefault();
                const target = e.target;
                if (target.href === document.referrer)
                    window.history.back();
                else
                    window.location.href = target.href;
            });
        if (delay > 0)
            this.elements[0].addEventListener('click', (e) => {
                e.preventDefault();
                setTimeout(() => (window.location.href = href), delay);
            });
        if (prefetch) {
            if (prefetch === 'hover')
                this.prefetchOnHover();
            else if (prefetch === 'visible')
                this.prefetchOnVisible();
            else
                this.addPrefetch();
        }
    }
    render() {
        // separate children and prefetch from props
        const _a = this.props, { children, prefetch, back, ref } = _a, rest = __rest(_a, ["children", "prefetch", "back", "ref"]);
        // some warning messages
        if (!this.props.href)
            console.warn('Please add "href" to <Link>');
        if (children.length !== 1)
            console.warn('Please add ONE child to <Link> (<Link>child</Link>)');
        const a = (0, core_js_1.h)('a', Object.assign({}, rest), ...children);
        // if ssr
        if (prefetch === true && !(typeof window !== 'undefined' && window.document)) {
            // <link rel="prefetch" href="/index.html" as="document"></link>
            const link = (0, core_js_1.h)('link', { rel: 'prefetch', href: this.props.href, as: 'document' });
            const helmet = (0, core_js_1.h)(helmet_js_1.Helmet, null, link);
            return (0, core_js_1.h)(fragment_js_1.Fragment, null, [helmet, a]);
        }
        // if not ssr
        else {
            return a;
        }
    }
}
exports.Link = Link;
//# sourceMappingURL=link.js.map

/***/ }),

/***/ "./lib/components/router.js":
/*!**********************************!*\
  !*** ./lib/components/router.js ***!
  \**********************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


// inspired by https://codesandbox.io/s/build-own-react-router-v4-mpslz
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.parseParamsFromPath = exports.Listener = exports.Link = exports.to = exports.Route = exports.Routes = exports.Switch = exports.matchPath = void 0;
const component_js_1 = __webpack_require__(/*! ../component.js */ "./lib/component.js");
const core_js_1 = __webpack_require__(/*! ../core.js */ "./lib/core.js");
const instances = [];
const register = (comp) => instances.push(comp);
const unregister = (comp) => instances.splice(instances.indexOf(comp), 1);
const historyPush = (path) => {
    window.history.pushState({}, '', path);
    instances.forEach(instance => instance.handleChanges());
    window.dispatchEvent(new Event('pushstate'));
};
const historyReplace = (path) => {
    window.history.replaceState({}, '', path);
    instances.forEach(instance => instance.handleChanges());
    window.dispatchEvent(new Event('replacestate'));
};
const matchPath = (pathname, options) => {
    const { exact = false, regex } = options;
    let { path } = options;
    if (!path) {
        return {
            path: null,
            url: pathname,
            isExact: true,
            params: {}
        };
    }
    let match;
    let params = {};
    // path with params
    if (path.includes('/:')) {
        const pathArr = path.split('/');
        const pathnameArr = pathname.split('/');
        pathArr.forEach((p, i) => {
            if (/^:/.test(p)) {
                const key = p.slice(1);
                const value = pathnameArr[i];
                // if a regex is provided, check it it matches
                if (regex && regex[key]) {
                    const regexMatch = regex[key].test(value);
                    if (!regexMatch)
                        return null;
                }
                params = Object.assign(Object.assign({}, params), { [key]: value });
                pathArr[i] = pathnameArr[i];
            }
        });
        path = pathArr.join('/');
    }
    // catch all
    if (path === '*')
        match = [pathname];
    // regular path
    if (!match)
        match = new RegExp(`^${path}`).exec(pathname);
    if (!match)
        return null;
    const url = match[0];
    const isExact = pathname === url;
    if (exact && !isExact)
        return null;
    return {
        path,
        url,
        isExact,
        params
    };
};
exports.matchPath = matchPath;
class Switch extends component_js_1.Component {
    constructor() {
        super(...arguments);
        this.index = 0;
        this.path = '';
        this.match = { index: -1, path: '' };
    }
    didMount() {
        window.addEventListener('popstate', this.handleChanges.bind(this));
        register(this);
    }
    didUnmount() {
        window.removeEventListener('popstate', this.handleChanges.bind(this));
        unregister(this);
    }
    handleChanges() {
        this.findChild();
        if (this.shouldUpdate())
            this.update();
    }
    findChild() {
        this.match = { index: -1, path: '' };
        // flatten children
        this.props.children = this.props.children.flat();
        for (let i = 0; i < this.props.children.length; i++) {
            const child = this.props.children[i];
            const { path, exact, regex } = child.props;
            const match = (0, exports.matchPath)((0, core_js_1.isSSR)() ? _nano.location.pathname : window.location.pathname, {
                path,
                exact,
                regex
            });
            if (match) {
                this.match.index = i;
                this.match.path = path;
                return;
            }
        }
    }
    shouldUpdate() {
        return this.path !== this.match.path || this.index !== this.match.index;
    }
    render() {
        this.findChild();
        const child = this.props.children[this.match.index];
        if (this.match.index === -1) {
            this.path = '';
            this.index = 0;
        }
        if (child) {
            const { path } = child.props;
            this.path = path;
            this.index = this.match.index;
            const el = (0, core_js_1._render)(child);
            return (0, core_js_1.h)('div', {}, (0, core_js_1._render)(el));
        }
        else if (this.props.fallback) {
            return (0, core_js_1.h)('div', {}, (0, core_js_1._render)(this.props.fallback));
        }
        else {
            return (0, core_js_1.h)('div', {}, 'not found');
        }
    }
}
exports.Switch = Switch;
// alias for <Switch />
class Routes extends Switch {
}
exports.Routes = Routes;
const Route = ({ path, regex, children }) => {
    // lookup pathname and parameters
    const pathname = (0, core_js_1.isSSR)() ? _nano.location.pathname : window.location.pathname;
    const params = (0, exports.parseParamsFromPath)(path);
    // pass the route as props to the children
    children.forEach((child) => {
        if (child.props)
            child.props = Object.assign(Object.assign({}, child.props), { route: { path, regex, pathname, params } });
    });
    return children;
};
exports.Route = Route;
const to = (to, replace = false) => {
    replace ? historyReplace(to) : historyPush(to);
};
exports.to = to;
const Link = (_a) => {
    var { to, replace, children } = _a, rest = __rest(_a, ["to", "replace", "children"]);
    const handleClick = (event) => {
        event.preventDefault();
        replace ? historyReplace(to) : historyPush(to);
    };
    return (0, core_js_1.h)('a', Object.assign({ href: to, onClick: (e) => handleClick(e) }, rest), children);
};
exports.Link = Link;
class CListener {
    constructor() {
        this._listeners = new Map();
        if ((0, core_js_1.isSSR)())
            return;
        this._route = window.location.pathname;
        const event = () => {
            const newRoute = window.location.pathname;
            this._listeners.forEach(fnc => {
                fnc(newRoute, this._route);
            });
            this._route = newRoute;
        };
        window.addEventListener('pushstate', event);
        window.addEventListener('replacestate', event);
    }
    use() {
        const id = Math.random().toString(36).substring(2);
        return {
            subscribe: (fnc) => {
                this._listeners.set(id, fnc);
            },
            cancel: () => {
                if (this._listeners.has(id))
                    this._listeners.delete(id);
            }
        };
    }
}
let listener;
const Listener = () => {
    if (!listener)
        listener = new CListener();
    return listener;
};
exports.Listener = Listener;
/** Pass "this.props.route.path" to it. */
const parseParamsFromPath = (path) => {
    let params = {};
    const _pathname = (0, core_js_1.isSSR)() ? _nano.location.pathname.split('/') : window.location.pathname.split('/');
    path.split('/').forEach((p, i) => {
        if (p.startsWith(':'))
            params = Object.assign(Object.assign({}, params), { [p.slice(1)]: _pathname[i] });
    });
    return params;
};
exports.parseParamsFromPath = parseParamsFromPath;
//# sourceMappingURL=router.js.map

/***/ }),

/***/ "./lib/components/visible.js":
/*!***********************************!*\
  !*** ./lib/components/visible.js ***!
  \***********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Visible = void 0;
const core_js_1 = __webpack_require__(/*! ../core.js */ "./lib/core.js");
const component_js_1 = __webpack_require__(/*! ../component.js */ "./lib/component.js");
class Visible extends component_js_1.Component {
    constructor() {
        super(...arguments);
        this.isVisible = false;
    }
    didMount() {
        const observer = new IntersectionObserver((entries, observer) => {
            entries.forEach(entry => {
                if (entry.isIntersecting) {
                    observer.disconnect();
                    this.isVisible = true;
                    this.update();
                }
            });
        }, { threshold: [0, 1] });
        observer.observe(this.elements[0]);
    }
    render() {
        if (!this.isVisible) {
            return (0, core_js_1.h)('div', { 'data-visible': false, visibility: 'hidden' });
        }
        else {
            if (this.props.onVisible)
                this.props.onVisible();
            return (0, core_js_1.render)(this.props.component || this.props.children[0]);
        }
    }
}
exports.Visible = Visible;
//# sourceMappingURL=visible.js.map

/***/ }),

/***/ "./lib/context.js":
/*!************************!*\
  !*** ./lib/context.js ***!
  \************************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.useContext = exports.createContext = void 0;
const createContext = (ctx) => {
    let _ctx = ctx;
    return {
        Provider: (props) => {
            if (props.value)
                _ctx = props.value;
            return props.children;
        },
        Consumer: (props) => {
            return { component: props.children[0](_ctx), props: Object.assign(Object.assign({}, props), { context: _ctx }) };
        },
        get: () => _ctx,
        set: (ctx) => (_ctx = ctx)
    };
};
exports.createContext = createContext;
const useContext = (ctx) => {
    const _ctx = ctx;
    if (_ctx && typeof _ctx.get === 'function') {
        return _ctx.get();
    }
};
exports.useContext = useContext;
//# sourceMappingURL=context.js.map

/***/ }),

/***/ "./lib/core.js":
/*!*********************!*\
  !*** ./lib/core.js ***!
  \*********************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.h = exports._render = exports.hydrate = exports.render = exports.appendChildren = exports.strToHash = exports.removeAllChildNodes = exports.tick = exports.isSSR = void 0;
__webpack_require__(/*! ./types.js */ "./lib/types.js");
const isSSR = () => typeof _nano !== 'undefined' && _nano.isSSR === true;
exports.isSSR = isSSR;
/** Creates a new Microtask using Promise() */
exports.tick = Promise.prototype.then.bind(Promise.resolve());
const removeAllChildNodes = (parent) => {
    while (parent.firstChild) {
        parent.removeChild(parent.firstChild);
    }
};
exports.removeAllChildNodes = removeAllChildNodes;
// https://stackoverflow.com/a/7616484/12656855
const strToHash = (s) => {
    let hash = 0;
    for (let i = 0; i < s.length; i++) {
        const chr = s.charCodeAt(i);
        hash = (hash << 5) - hash + chr;
        hash |= 0; // Convert to 32bit integer
    }
    return Math.abs(hash).toString(32);
};
exports.strToHash = strToHash;
const appendChildren = (element, children, escape = true) => {
    // if the child is an html element
    if (!Array.isArray(children)) {
        (0, exports.appendChildren)(element, [children], escape);
        return;
    }
    // htmlCollection to array
    if (typeof children === 'object')
        children = Array.prototype.slice.call(children);
    children.forEach(child => {
        // if child is an array of children, append them instead
        if (Array.isArray(child))
            (0, exports.appendChildren)(element, child, escape);
        else {
            // render the component
            const c = (0, exports._render)(child);
            if (typeof c !== 'undefined') {
                // if c is an array of children, append them instead
                if (Array.isArray(c))
                    (0, exports.appendChildren)(element, c, escape);
                // apply the component to parent element
                else {
                    if ((0, exports.isSSR)() && !escape)
                        element.appendChild(c.nodeType == null ? c.toString() : c);
                    else
                        element.appendChild(c.nodeType == null ? document.createTextNode(c.toString()) : c);
                }
            }
        }
    });
};
exports.appendChildren = appendChildren;
/**
 * A simple component for rendering SVGs
 */
const SVG = (props) => {
    const child = props.children[0];
    const attrs = child.attributes;
    if ((0, exports.isSSR)())
        return child;
    const svg = hNS('svg');
    for (let i = attrs.length - 1; i >= 0; i--) {
        svg.setAttribute(attrs[i].name, attrs[i].value);
    }
    svg.innerHTML = child.innerHTML;
    return svg;
};
/** Returns the populated parent if available else  one child or an array of children */
const render = (component, parent = null, removeChildNodes = true) => {
    let el = (0, exports._render)(component);
    if (Array.isArray(el)) {
        el = el.map(e => (0, exports._render)(e));
        if (el.length === 1)
            el = el[0];
    }
    if (parent) {
        if (removeChildNodes)
            (0, exports.removeAllChildNodes)(parent);
        // if parent and child are the same, we replace the parent instead of appending to it
        if (el && parent.id && parent.id === el.id && parent.parentElement) {
            parent.parentElement.replaceChild(el, parent);
        }
        else {
            // append element(s) to the parent
            if (Array.isArray(el))
                el.forEach((e) => {
                    (0, exports.appendChildren)(parent, (0, exports._render)(e));
                    //parent.appendChild(_render(e))
                });
            else
                (0, exports.appendChildren)(parent, (0, exports._render)(el));
        }
        return parent;
    }
    // returning one child or an array of children
    else {
        if ((0, exports.isSSR)() && !Array.isArray(el))
            return [el];
        return el;
    }
};
exports.render = render;
exports.hydrate = exports.render;
const _render = (comp) => {
    // null, false, undefined
    if (comp === null || comp === false || typeof comp === 'undefined')
        return [];
    // string, number
    if (typeof comp === 'string' || typeof comp === 'number')
        return comp.toString();
    // SVGElement
    if (comp.tagName && comp.tagName.toLowerCase() === 'svg')
        return SVG({ children: [comp] });
    // HTMLElement
    if (comp.tagName)
        return comp;
    // TEXTNode (Node.TEXT_NODE === 3)
    if (comp && comp.nodeType === 3)
        return comp;
    // Class Component
    if (comp && comp.component && comp.component.isClass)
        return renderClassComponent(comp);
    // Class Component (Uninitialized)
    if (comp.isClass)
        return renderClassComponent({ component: comp, props: {} });
    // Functional Component
    if (comp.component && typeof comp.component === 'function')
        return renderFunctionalComponent(comp);
    // Array (render each child and return the array) (is probably a fragment)
    if (Array.isArray(comp))
        return comp.map(c => (0, exports._render)(c)).flat();
    // function
    if (typeof comp === 'function' && !comp.isClass)
        return (0, exports._render)(comp());
    // if component is a HTMLElement (rare case)
    if (comp.component && comp.component.tagName && typeof comp.component.tagName === 'string')
        return (0, exports._render)(comp.component);
    // (rare case)
    if (Array.isArray(comp.component))
        return (0, exports._render)(comp.component);
    // (rare case)
    if (comp.component)
        return (0, exports._render)(comp.component);
    // object
    if (typeof comp === 'object')
        return [];
    console.warn('Something unexpected happened with:', comp);
};
exports._render = _render;
const renderFunctionalComponent = (fncComp) => {
    const { component, props } = fncComp;
    return (0, exports._render)(component(props));
};
const renderClassComponent = (classComp) => {
    const { component, props } = classComp;
    // calc hash
    const hash = (0, exports.strToHash)(component.toString());
    // make hash accessible in constructor, without passing it to it
    component.prototype._getHash = () => hash;
    const Component = new component(props);
    if (!(0, exports.isSSR)())
        Component.willMount();
    let el = Component.render();
    el = (0, exports._render)(el);
    Component.elements = el;
    // pass the component instance as ref
    if (props && props.ref)
        props.ref(Component);
    if (!(0, exports.isSSR)())
        (0, exports.tick)(() => {
            Component._didMount();
        });
    return el;
};
const hNS = (tag) => document.createElementNS('http://www.w3.org/2000/svg', tag);
// https://stackoverflow.com/a/42405694/12656855
const h = (tagNameOrComponent, props = {}, ...children) => {
    // if children is passed as props, merge with ...children
    if (props && props.children) {
        if (Array.isArray(children)) {
            if (Array.isArray(props.children))
                children = [...props.children, ...children];
            else
                children.push(props.children);
        }
        else {
            if (Array.isArray(props.children))
                children = props.children;
            else
                children = [props.children];
        }
    }
    // render WebComponent in SSR
    if ((0, exports.isSSR)() && _nano.ssrTricks.isWebComponent(tagNameOrComponent)) {
        const element = _nano.ssrTricks.renderWebComponent(tagNameOrComponent, props, children, exports._render);
        if (element === null)
            return `ERROR: "<${tagNameOrComponent} />"`;
        else
            return element;
    }
    // if tagNameOrComponent is a component
    if (typeof tagNameOrComponent !== 'string')
        return { component: tagNameOrComponent, props: Object.assign(Object.assign({}, props), { children: children }) };
    // custom message if document is not defined in SSR
    try {
        if ((0, exports.isSSR)() && typeof tagNameOrComponent === 'string' && !document)
            throw new Error('document is not defined');
    }
    catch (err) {
        console.log('ERROR:', err.message, '\n > Please read: https://github.com/nanojsx/nano/issues/106');
    }
    let ref;
    const element = tagNameOrComponent === 'svg'
        ? hNS('svg')
        : document.createElement(tagNameOrComponent);
    // check if the element includes the event (for example 'oninput')
    const isEvent = (el, p) => {
        // check if the event begins with 'on'
        if (0 !== p.indexOf('on'))
            return false;
        // we return true if SSR, since otherwise it will get rendered
        if (el._ssr)
            return true;
        // check if the event is present in the element as object (null) or as function
        return typeof el[p] === 'object' || typeof el[p] === 'function';
    };
    for (const p in props) {
        // https://stackoverflow.com/a/45205645/12656855
        // style object to style string
        if (p === 'style' && typeof props[p] === 'object') {
            const styles = Object.keys(props[p])
                .map(k => `${k}:${props[p][k]}`)
                .join(';')
                .replace(/[A-Z]/g, match => `-${match.toLowerCase()}`);
            props[p] = `${styles};`;
        }
        // handel ref
        if (p === 'ref')
            ref = props[p];
        // handle events
        else if (isEvent(element, p.toLowerCase()))
            element.addEventListener(p.toLowerCase().substring(2), (e) => props[p](e));
        // dangerouslySetInnerHTML
        else if (p === 'dangerouslySetInnerHTML' && props[p].__html) {
            if (!(0, exports.isSSR)()) {
                const fragment = document.createElement('fragment');
                fragment.innerHTML = props[p].__html;
                element.appendChild(fragment);
            }
            else {
                element.innerHTML = props[p].__html;
            }
        }
        // modern dangerouslySetInnerHTML
        else if (p === 'innerHTML' && props[p].__dangerousHtml) {
            if (!(0, exports.isSSR)()) {
                const fragment = document.createElement('fragment');
                fragment.innerHTML = props[p].__dangerousHtml;
                element.appendChild(fragment);
            }
            else {
                element.innerHTML = props[p].__dangerousHtml;
            }
        }
        // className
        else if (/^className$/i.test(p))
            element.setAttribute('class', props[p]);
        // setAttribute
        else if (typeof props[p] !== 'undefined')
            element.setAttribute(p, props[p]);
    }
    // these tags should not be escaped by default (in ssr)
    const escape = !['noscript', 'script', 'style'].includes(tagNameOrComponent);
    (0, exports.appendChildren)(element, children, escape);
    if (ref)
        ref(element);
    return element;
};
exports.h = h;
//# sourceMappingURL=core.js.map

/***/ }),

/***/ "./lib/customElementsMode.js":
/*!***********************************!*\
  !*** ./lib/customElementsMode.js ***!
  \***********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.defineAsCustomElements = void 0;
const core_js_1 = __webpack_require__(/*! ./core.js */ "./lib/core.js");
const defineAsCustomElementsSSR = (component, componentName, _publicProps = [], _options = {}) => {
    if (!/^[a-zA-Z0-9]+-[a-zA-Z0-9]+$/.test(componentName))
        console.log(`Error: WebComponent name "${componentName}" is invalid.`);
    else
        _nano.customElements.set(componentName, component);
};
const defineAsCustomElements = function (component, componentName, publicProps, shadow) {
    if ((0, core_js_1.isSSR)()) {
        defineAsCustomElementsSSR(component, componentName, publicProps);
        return;
    }
    customElements.define(componentName, class extends HTMLElement {
        constructor() {
            super();
            if (shadow) {
                this.attachShadow(shadow);
                this.$root = this.shadowRoot;
            }
            else {
                this.$root = this;
            }
            let ref;
            const el = this.buildEl((0, core_js_1._render)({
                component,
                props: {
                    ref: (r) => (ref = r),
                    children: Array.from(this.children).map(c => (0, core_js_1.render)(c))
                }
            }));
            // ------------------------------ first render
            this.component = ref;
            this.isFunctionalComponent = !component.isClass;
            this.functionalComponentsProps = {};
            this.appendEl(el);
            // ------------------------------------------
            if (!this.isFunctionalComponent) {
                this.component.updatePropsValue = (name, value) => {
                    // @ts-ignore
                    if (!this.component.props)
                        this.component.props = {};
                    this.component.props[name] = value;
                    this.component[name] = value;
                };
            }
        }
        static get observedAttributes() {
            return publicProps;
        }
        buildEl(contents) {
            // because nano-jsx update needs parentElement, we need
            // to wrap the element in a div when using shadow mode
            return (0, core_js_1.h)(this.shadowRoot ? 'div' : 'template', null, contents);
        }
        appendEl(el) {
            if (this.shadowRoot) {
                // el.dataset.wcRoot = true
                this.$root.append(el);
            }
            else {
                this.$root.append(...el.childNodes);
            }
        }
        removeChildren() {
            var _a;
            if (this.$root) {
                const children = Array.from((_a = this.$root) === null || _a === void 0 ? void 0 : _a.children) || [];
                for (const el of children) {
                    el.remove();
                }
            }
        }
        attributeChangedCallback(name, _, newValue) {
            if (!this.isFunctionalComponent) {
                this.component.updatePropsValue(name, newValue);
                this.component.update();
            }
            else {
                this.removeChildren();
                this.functionalComponentsProps[name] = newValue;
                const el = this.buildEl((0, core_js_1._render)({
                    component,
                    props: Object.assign({ children: [], ref: (r) => (this.component = r) }, this.functionalComponentsProps)
                }));
                this.appendEl(el);
            }
        }
    });
};
exports.defineAsCustomElements = defineAsCustomElements;
//# sourceMappingURL=customElementsMode.js.map

/***/ }),

/***/ "./lib/fragment.js":
/*!*************************!*\
  !*** ./lib/fragment.js ***!
  \*************************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Fragment = void 0;
const Fragment = (props) => {
    return props.children;
};
exports.Fragment = Fragment;
//# sourceMappingURL=fragment.js.map

/***/ }),

/***/ "./lib/helpers.js":
/*!************************!*\
  !*** ./lib/helpers.js ***!
  \************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.printVersion = exports.escapeHtml = exports.onNodeRemove = exports.detectSSR = exports.nodeToString = exports.task = void 0;
const version_js_1 = __webpack_require__(/*! ./version.js */ "./lib/version.js");
/** Creates a new Task using setTimeout() */
const task = (task) => setTimeout(task, 0);
exports.task = task;
const nodeToString = (node) => {
    const tmpNode = document.createElement('div');
    tmpNode.appendChild(node.cloneNode(true));
    return tmpNode.innerHTML;
};
exports.nodeToString = nodeToString;
const detectSSR = () => {
    // @ts-ignore
    const isDeno = typeof Deno !== 'undefined';
    const hasWindow = typeof window !== 'undefined' ? true : false;
    return (typeof _nano !== 'undefined' && _nano.isSSR) || isDeno || !hasWindow;
};
exports.detectSSR = detectSSR;
function isDescendant(desc, root) {
    // @ts-ignore
    return !!desc && (desc === root || isDescendant(desc.parentNode, root));
}
// https://developer.mozilla.org/en-US/docs/Web/API/MutationObserver
const onNodeRemove = (element, callback) => {
    let observer = new MutationObserver(mutationsList => {
        mutationsList.forEach(mutation => {
            mutation.removedNodes.forEach(removed => {
                if (isDescendant(element, removed)) {
                    callback();
                    if (observer) {
                        // allow garbage collection
                        observer.disconnect();
                        // @ts-ignore
                        observer = undefined;
                    }
                }
            });
        });
    });
    observer.observe(document, {
        childList: true,
        subtree: true
    });
    return observer;
};
exports.onNodeRemove = onNodeRemove;
// https://stackoverflow.com/a/6234804
const escapeHtml = (unsafe) => {
    if (unsafe && typeof unsafe === 'string')
        return unsafe
            .replace(/&/g, '&amp;')
            .replace(/</g, '&lt;')
            .replace(/>/g, '&gt;')
            .replace(/"/g, '&quot;')
            .replace(/'/g, '&apos;');
    return unsafe;
};
exports.escapeHtml = escapeHtml;
const printVersion = () => {
    const info = `Powered by nano JSX v${version_js_1.VERSION}`;
    console.log(`%c %c %c %c %c ${info} %c http://nanojsx.io`, 'background: #ff0000', 'background: #ffff00', 'background: #00ff00', 'background: #00ffff', 'color: #fff; background: #000000;', 'background: none');
};
exports.printVersion = printVersion;
//# sourceMappingURL=helpers.js.map

/***/ }),

/***/ "./lib/htm.js":
/*!********************!*\
  !*** ./lib/htm.js ***!
  \********************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const index_js_1 = __importDefault(__webpack_require__(/*! ./htm/index.js */ "./lib/htm/index.js"));
exports["default"] = index_js_1.default;
//# sourceMappingURL=htm.js.map

/***/ }),

/***/ "./lib/htm/build.js":
/*!**************************!*\
  !*** ./lib/htm/build.js ***!
  \**************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.build = exports.evaluate = exports.treeify = void 0;
const constants_js_1 = __webpack_require__(/*! ./constants.js */ "./lib/htm/constants.js");
const MODE_SLASH = 0;
const MODE_TEXT = 1;
const MODE_WHITESPACE = 2;
const MODE_TAGNAME = 3;
const MODE_COMMENT = 4;
const MODE_PROP_SET = 5;
const MODE_PROP_APPEND = 6;
const CHILD_APPEND = 0;
const CHILD_RECURSE = 2;
const TAG_SET = 3;
const PROPS_ASSIGN = 4;
const PROP_SET = MODE_PROP_SET;
const PROP_APPEND = MODE_PROP_APPEND;
// Turn a result of a build(...) call into a tree that is more
// convenient to analyze and transform (e.g. Babel plugins).
// For example:
// 	treeify(
//		build'<div href="1${a}" ...${b}><${x} /></div>`,
//		[X, Y, Z]
//	)
// returns:
// 	{
// 		tag: 'div',
//		props: [ { href: ["1", X] },	Y ],
// 		children: [ { tag: Z, props: [], children: [] } ]
// 	}
const treeify = (built, fields) => {
    const _treeify = (built) => {
        let tag = '';
        let currentProps = null;
        const props = [];
        const children = [];
        for (let i = 1; i < built.length; i++) {
            const type = built[i++];
            const value = built[i] ? fields[built[i++] - 1] : built[++i];
            if (type === TAG_SET) {
                tag = value;
            }
            else if (type === PROPS_ASSIGN) {
                props.push(value);
                currentProps = null;
            }
            else if (type === PROP_SET) {
                if (!currentProps) {
                    currentProps = Object.create(null);
                    props.push(currentProps);
                }
                currentProps[built[++i]] = [value];
            }
            else if (type === PROP_APPEND) {
                currentProps[built[++i]].push(value);
            }
            else if (type === CHILD_RECURSE) {
                children.push(_treeify(value));
            }
            else if (type === CHILD_APPEND) {
                children.push(value);
            }
        }
        return { tag, props, children };
    };
    const { children } = _treeify(built);
    return children.length > 1 ? children : children[0];
};
exports.treeify = treeify;
const evaluate = (h, built, fields, args) => {
    let tmp;
    // `build()` used the first element of the operation list as
    // temporary workspace. Now that `build()` is done we can use
    // that space to track whether the current element is "dynamic"
    // (i.e. it or any of its descendants depend on dynamic values).
    built[0] = 0;
    for (let i = 1; i < built.length; i++) {
        const type = built[i++];
        // Set `built[0]`'s appropriate bits if this element depends on a dynamic value.
        const value = built[i] ? ((built[0] |= type ? 1 : 2), fields[built[i++]]) : built[++i];
        if (type === TAG_SET) {
            args[0] = value;
        }
        else if (type === PROPS_ASSIGN) {
            args[1] = Object.assign(args[1] || {}, value);
        }
        else if (type === PROP_SET) {
            ;
            (args[1] = args[1] || {})[built[++i]] = value;
        }
        else if (type === PROP_APPEND) {
            args[1][built[++i]] += `${value}`;
        }
        else if (type) {
            // type === CHILD_RECURSE
            // Set the operation list (including the staticness bits) as
            // `this` for the `h` call.
            tmp = h.apply(value, (0, exports.evaluate)(h, value, fields, ['', null]));
            args.push(tmp);
            if (value[0]) {
                // Set the 2nd lowest bit it the child element is dynamic.
                built[0] |= 2;
            }
            else {
                // Rewrite the operation list in-place if the child element is static.
                // The currently evaluated piece `CHILD_RECURSE, 0, [...]` becomes
                // `CHILD_APPEND, 0, tmp`.
                // Essentially the operation list gets optimized for potential future
                // re-evaluations.
                built[i - 2] = CHILD_APPEND;
                built[i] = tmp;
            }
        }
        else {
            // type === CHILD_APPEND
            args.push(value);
        }
    }
    return args;
};
exports.evaluate = evaluate;
const build = function (statics, ...rest) {
    const fields = [statics, ...rest];
    // @ts-ignore
    const h = this;
    let mode = MODE_TEXT;
    let buffer = '';
    let quote = '';
    let current = [0];
    let char;
    let propName;
    const commit = (field) => {
        if (mode === MODE_TEXT && (field || (buffer = buffer.replace(/^\s*\n\s*|\s*\n\s*$/g, '')))) {
            if (constants_js_1.MINI) {
                current.push(field ? fields[field] : buffer);
            }
            else {
                current.push(CHILD_APPEND, field, buffer);
            }
        }
        else if (mode === MODE_TAGNAME && (field || buffer)) {
            if (constants_js_1.MINI) {
                current[1] = field ? fields[field] : buffer;
            }
            else {
                current.push(TAG_SET, field, buffer);
            }
            mode = MODE_WHITESPACE;
        }
        else if (mode === MODE_WHITESPACE && buffer === '...' && field) {
            if (constants_js_1.MINI) {
                current[2] = Object.assign(current[2] || {}, fields[field]);
            }
            else {
                current.push(PROPS_ASSIGN, field, 0);
            }
        }
        else if (mode === MODE_WHITESPACE && buffer && !field) {
            if (constants_js_1.MINI) {
                ;
                (current[2] = current[2] || {})[buffer] = true;
            }
            else {
                current.push(PROP_SET, 0, true, buffer);
            }
        }
        else if (mode >= MODE_PROP_SET) {
            if (constants_js_1.MINI) {
                if (mode === MODE_PROP_SET) {
                    ;
                    (current[2] = current[2] || {})[propName] = field
                        ? buffer
                            ? buffer + fields[field]
                            : fields[field]
                        : buffer;
                    mode = MODE_PROP_APPEND;
                }
                else if (field || buffer) {
                    current[2][propName] += field ? buffer + fields[field] : buffer;
                }
            }
            else {
                if (buffer || (!field && mode === MODE_PROP_SET)) {
                    current.push(mode, 0, buffer, propName);
                    mode = MODE_PROP_APPEND;
                }
                if (field) {
                    current.push(mode, field, 0, propName);
                    mode = MODE_PROP_APPEND;
                }
            }
        }
        buffer = '';
    };
    for (let i = 0; i < statics.length; i++) {
        if (i) {
            if (mode === MODE_TEXT) {
                commit();
            }
            commit(i);
        }
        for (let j = 0; j < statics[i].length; j++) {
            char = statics[i][j];
            if (mode === MODE_TEXT) {
                if (char === '<') {
                    // commit buffer
                    commit();
                    if (constants_js_1.MINI) {
                        current = [current, '', null];
                    }
                    else {
                        current = [current];
                    }
                    mode = MODE_TAGNAME;
                }
                else {
                    buffer += char;
                }
            }
            else if (mode === MODE_COMMENT) {
                // Ignore everything until the last three characters are '-', '-' and '>'
                if (buffer === '--' && char === '>') {
                    mode = MODE_TEXT;
                    buffer = '';
                }
                else {
                    buffer = char + buffer[0];
                }
            }
            else if (quote) {
                if (char === quote) {
                    quote = '';
                }
                else {
                    buffer += char;
                }
            }
            else if (char === '"' || char === "'") {
                quote = char;
            }
            else if (char === '>') {
                commit();
                mode = MODE_TEXT;
            }
            else if (!mode) {
                // Ignore everything until the tag ends
            }
            else if (char === '=') {
                mode = MODE_PROP_SET;
                propName = buffer;
                buffer = '';
            }
            else if (char === '/' && (mode < MODE_PROP_SET || statics[i][j + 1] === '>')) {
                commit();
                if (mode === MODE_TAGNAME) {
                    current = current[0];
                }
                mode = current;
                if (constants_js_1.MINI) {
                    ;
                    (current = current[0]).push(h(...mode.slice(1)));
                }
                else {
                    ;
                    (current = current[0]).push(CHILD_RECURSE, 0, mode);
                }
                mode = MODE_SLASH;
            }
            else if (char === ' ' || char === '\t' || char === '\n' || char === '\r') {
                // <a disabled>
                commit();
                mode = MODE_WHITESPACE;
            }
            else {
                buffer += char;
            }
            if (mode === MODE_TAGNAME && buffer === '!--') {
                mode = MODE_COMMENT;
                current = current[0];
            }
        }
    }
    commit();
    if (constants_js_1.MINI) {
        return current.length > 2 ? current.slice(1) : current[1];
    }
    return current;
};
exports.build = build;
//# sourceMappingURL=build.js.map

/***/ }),

/***/ "./lib/htm/constants.js":
/*!******************************!*\
  !*** ./lib/htm/constants.js ***!
  \******************************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MINI = void 0;
exports.MINI = false;
//# sourceMappingURL=constants.js.map

/***/ }),

/***/ "./lib/htm/index.js":
/*!**************************!*\
  !*** ./lib/htm/index.js ***!
  \**************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/**
 * Copyright 2018 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *     http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
const constants_js_1 = __webpack_require__(/*! ./constants.js */ "./lib/htm/constants.js");
const build_js_1 = __webpack_require__(/*! ./build.js */ "./lib/htm/build.js");
const CACHES = new Map();
const regular = function (statics) {
    let tmp = CACHES.get(this);
    if (!tmp) {
        tmp = new Map();
        CACHES.set(this, tmp);
    }
    tmp = (0, build_js_1.evaluate)(this, tmp.get(statics) || (tmp.set(statics, (tmp = (0, build_js_1.build)(statics))), tmp), arguments, []);
    return tmp.length > 1 ? tmp : tmp[0];
};
// export as htm
exports["default"] = constants_js_1.MINI ? build_js_1.build : regular;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./lib/jsx.js":
/*!********************!*\
  !*** ./lib/jsx.js ***!
  \********************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.jsx = void 0;
const core_js_1 = __webpack_require__(/*! ./core.js */ "./lib/core.js");
const htm_js_1 = __importDefault(__webpack_require__(/*! ./htm.js */ "./lib/htm.js"));
const jsx = htm_js_1.default.bind(core_js_1.h);
exports.jsx = jsx;
//# sourceMappingURL=jsx.js.map

/***/ }),

/***/ "./lib/lazy.js":
/*!*********************!*\
  !*** ./lib/lazy.js ***!
  \*********************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.hydrateLazy = void 0;
const core_js_1 = __webpack_require__(/*! ./core.js */ "./lib/core.js");
const visible_js_1 = __webpack_require__(/*! ./components/visible.js */ "./lib/components/visible.js");
const hydrateLazy = (component, parent = null, removeChildNodes = true) => {
    const c = (0, core_js_1.h)(visible_js_1.Visible, null, component);
    return (0, core_js_1.hydrate)(c, parent, removeChildNodes);
};
exports.hydrateLazy = hydrateLazy;
//# sourceMappingURL=lazy.js.map

/***/ }),

/***/ "./lib/state.js":
/*!**********************!*\
  !*** ./lib/state.js ***!
  \**********************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports._clearState = exports._state = void 0;
/** Holds the state of the whole application. */
exports._state = new Map();
/** Clears the state of the whole application. */
const _clearState = () => {
    exports._state.clear();
};
exports._clearState = _clearState;
//# sourceMappingURL=state.js.map

/***/ }),

/***/ "./lib/store.js":
/*!**********************!*\
  !*** ./lib/store.js ***!
  \**********************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Store = void 0;
const core_js_1 = __webpack_require__(/*! ./core.js */ "./lib/core.js");
class Store {
    /**
     * Create your own Store.
     * @param defaultState Pass the initial State.
     * @param name The name of the Store (only required if you persist the state in localStorage or sessionStorage).
     * @param storage Pass 'memory', 'local' or 'session'.
     */
    constructor(defaultState, name = '', storage = 'memory') {
        this._listeners = new Map();
        if ((0, core_js_1.isSSR)())
            storage = 'memory';
        this._id = name;
        this._storage = storage;
        this._state = this._prevState = defaultState;
        if (storage === 'memory' || !storage)
            return;
        const Storage = storage === 'local' ? localStorage : sessionStorage;
        // get/set initial state of Storage
        const item = Storage.getItem(this._id);
        if (item) {
            this._state = this._prevState = JSON.parse(item);
        }
        else
            Storage.setItem(this._id, JSON.stringify(defaultState));
    }
    persist(newState) {
        if (this._storage === 'memory')
            return;
        const Storage = this._storage === 'local' ? localStorage : sessionStorage;
        Storage.setItem(this._id, JSON.stringify(newState));
    }
    /** Clears the state of the whole store. */
    clear() {
        // @ts-ignore
        this._state = this._prevState = undefined;
        if (this._storage === 'local')
            localStorage.removeItem(this._id);
        else if (this._storage === 'session')
            sessionStorage.removeItem(this._id);
    }
    setState(newState) {
        this.state = newState;
    }
    set state(newState) {
        this._prevState = this._state;
        this._state = newState;
        this.persist(newState);
        this._listeners.forEach(fnc => {
            fnc(this._state, this._prevState);
        });
    }
    get state() {
        return this._state;
    }
    use() {
        const id = Math.random().toString(36).substring(2, 9);
        const _this = this;
        return {
            get state() {
                return _this.state;
            },
            setState: (newState) => {
                this.state = newState;
            },
            subscribe: (fnc) => {
                this._listeners.set(id, fnc);
            },
            cancel: () => {
                if (this._listeners.has(id))
                    this._listeners.delete(id);
            }
        };
    }
}
exports.Store = Store;
//# sourceMappingURL=store.js.map

/***/ }),

/***/ "./lib/types.js":
/*!**********************!*\
  !*** ./lib/types.js ***!
  \**********************/
/***/ ((__unused_webpack_module, exports) => {


// fixes an issue in std@0.80.0 (deno)
// interface ReadableStream<R> {
//   getIterator(): any
// }
Object.defineProperty(exports, "__esModule", ({ value: true }));
//# sourceMappingURL=types.js.map

/***/ }),

/***/ "./lib/ui/_config.js":
/*!***************************!*\
  !*** ./lib/ui/_config.js ***!
  \***************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.zIndex = exports.rippleEffect = exports.userSelect = exports.boxShadow = void 0;
const core_js_1 = __webpack_require__(/*! ../core.js */ "./lib/core.js");
exports.boxShadow = `
  -webkit-box-shadow: 0px 3px 5px -1px rgba(0,0,0,0.2), 0px 6px 10px 0px rgba(0,0,0,0.14), 0px 1px 18px 0px rgba(0,0,0,0.12);
  -moz-box-shadow: 0px 3px 5px -1px rgba(0,0,0,0.2), 0px 6px 10px 0px rgba(0,0,0,0.14), 0px 1px 18px 0px rgba(0,0,0,0.12);
  box-shadow: 0px 3px 5px -1px rgba(0,0,0,0.2), 0px 6px 10px 0px rgba(0,0,0,0.14), 0px 1px 18px 0px rgba(0,0,0,0.12);
`;
exports.userSelect = `
  -webkit-touch-callout:none;
  -webkit-user-select:none;
  -khtml-user-select:none;
  -moz-user-select:none;
  -ms-user-select:none;
  user-select:none;
  -webkit-tap-highlight-color:rgba(0,0,0,0);
`;
const rippleEffect = (rippleClr, hoverClr) => {
    const rippleClass = `ripple-${(0, core_js_1.strToHash)(rippleClr + hoverClr)}`;
    const styles = `  
  .${rippleClass} {
    background-position: center;
    transition: background 0.8s;
  }
  
  .${rippleClass}:hover {
    background: ${hoverClr} radial-gradient(circle, transparent 1%, ${hoverClr} 1%) center/15000%;
  }

  .${rippleClass}:focus {
    background: ${hoverClr} radial-gradient(circle, transparent 1%, ${hoverClr} 1%) center/15000%;
  }
  
  .${rippleClass}:active {
    background-color: ${rippleClr};
    background-size: 100%;
    transition: background 0s;
  }`;
    return {
        styles,
        class: rippleClass
    };
};
exports.rippleEffect = rippleEffect;
exports.zIndex = {
    button: 'unset;',
    banner: '50;',
    bar: '100;',
    navigation: '100;',
    fab: '200;',
    sheet: '300;',
    menu: '400;',
    snackbar: '500;',
    dialog: '600;'
};
//# sourceMappingURL=_config.js.map

/***/ }),

/***/ "./lib/ui/_helpers.js":
/*!****************************!*\
  !*** ./lib/ui/_helpers.js ***!
  \****************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.addStylesToHead = exports.lightenColor = void 0;
const core_js_1 = __webpack_require__(/*! ../core.js */ "./lib/core.js");
// https://gist.github.com/renancouto/4675192
const lightenColor = (color, percent) => {
    const num = parseInt(color.replace('#', ''), 16), amt = Math.round(2.55 * percent), R = (num >> 16) + amt, B = ((num >> 8) & 0x00ff) + amt, G = (num & 0x0000ff) + amt;
    return `#${(0x1000000 +
        (R < 255 ? (R < 1 ? 0 : R) : 255) * 0x10000 +
        (B < 255 ? (B < 1 ? 0 : B) : 255) * 0x100 +
        (G < 255 ? (G < 1 ? 0 : G) : 255))
        .toString(16)
        .slice(1)}`;
};
exports.lightenColor = lightenColor;
const addStylesToHead = (styles, hash) => {
    const el = document.querySelector(`[data-css-hash*="${hash}"]`);
    if (!el) {
        const styleElement = (0, core_js_1.h)('style', { 'data-css-hash': hash }, styles);
        document.head.appendChild(styleElement);
    }
};
exports.addStylesToHead = addStylesToHead;
//# sourceMappingURL=_helpers.js.map

/***/ }),

/***/ "./lib/ui/appBar.js":
/*!**************************!*\
  !*** ./lib/ui/appBar.js ***!
  \**************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AppBar = void 0;
const component_js_1 = __webpack_require__(/*! ../component.js */ "./lib/component.js");
const core_js_1 = __webpack_require__(/*! ../core.js */ "./lib/core.js");
const _config_js_1 = __webpack_require__(/*! ./_config.js */ "./lib/ui/_config.js");
const classes = {
    container: 'appBar_container',
    scrollingDown: 'appBar_scrolling_down'
};
class AppBar extends component_js_1.Component {
    constructor() {
        super(...arguments);
        this.curr_scrollY = 0;
        this.last_scrollY = 0;
        this.curr_scrollingState = 'none';
        this.last_scrollingState = 'none';
    }
    calcScrollPosition() {
        this.curr_scrollY = window.scrollY;
        if (this.curr_scrollY > this.last_scrollY) {
            this.curr_scrollingState = 'down';
        }
        else if (this.curr_scrollY < this.last_scrollY) {
            this.curr_scrollingState = 'up';
        }
        this.last_scrollY = this.curr_scrollY;
    }
    scroll() {
        this.calcScrollPosition();
        if (this.curr_scrollY < 1) {
            this.container.classList.remove('appBar_scrolling_down');
        }
        else if (this.last_scrollingState !== this.curr_scrollingState) {
            this.last_scrollingState = this.curr_scrollingState;
            if (this.curr_scrollingState === 'down')
                this.container.classList.add('appBar_scrolling_down');
            else
                this.container.classList.remove('appBar_scrolling_down');
        }
    }
    merge() {
        this.calcScrollPosition();
        if (this.curr_scrollY <= 1) {
            this.container.classList.add('appBar_merged');
        }
        else {
            this.container.classList.remove('appBar_merged');
        }
    }
    didMount() {
        this.curr_scrollY = this.last_scrollY = window.scrollY;
        if (this.props.autoHide)
            window.addEventListener('scroll', () => this.scroll());
        if (this.props.autoMerge)
            window.addEventListener('scroll', () => this.merge());
    }
    didUnmount() {
        if (this.props.autoHide)
            window.removeEventListener('scroll', this.scroll);
        if (this.props.autoMerge)
            window.removeEventListener('scroll', () => this.merge());
    }
    render() {
        const { background = '#6200EE', color = 'white' } = this.props;
        const styles = `
    .appBar_container {
      background: ${background};
      color: ${color};
      font-weight: 500;

      z-index: ${_config_js_1.zIndex.bar}

      position: fixed;
      top: 0;
      left: 0;
      min-height: 24px;
      width: 100vw;


      ${_config_js_1.boxShadow}

      transition: top 0.2s, -webkit-box-shadow 0.5s, -moz-box-shadow 0.5s, box-shadow 0.5s;
    }

    .appBar_container.appBar_scrolling_down {
      top: -56px;
    }

    .appBar_container.appBar_merged {
      -webkit-box-shadow: none;
      -moz-box-shadow: none;
      box-shadow: none;
    }

    .appBar_container .toolbar_container {
      display: flex;
      justify-content: space-between;
    }

    .appBar_container .toolbar_container,
    .appBar_container .tabs_container {
      margin: 0 auto;
      ${this.props.maxWidth ? `max-width: ${this.props.maxWidth}px;` : ''}
    }

    .appBar_container .toolbar_container .toolbar_left,
    .appBar_container .toolbar_container .toolbar_right {
      display: flex;
      align-items: center;      
    }

    .appBar_container .toolbar_container .toolbar_left {
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .appBar_container .toolbar_title {
      font-size: 20px;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    `;
        document.head.appendChild((0, core_js_1.h)('style', {}, styles));
        const mergedClass = this.props.autoMerge ? 'appBar_merged' : '';
        // @ts-ignore
        this.container = (0, core_js_1.h)('div', { class: `${classes.container} ${mergedClass}` }, this.props.children);
        return this.container;
    }
}
exports.AppBar = AppBar;
//# sourceMappingURL=appBar.js.map

/***/ }),

/***/ "./lib/ui/button.js":
/*!**************************!*\
  !*** ./lib/ui/button.js ***!
  \**************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Button = void 0;
const core_js_1 = __webpack_require__(/*! ../core.js */ "./lib/core.js");
const _config_js_1 = __webpack_require__(/*! ./_config.js */ "./lib/ui/_config.js");
const _helpers_js_1 = __webpack_require__(/*! ./_helpers.js */ "./lib/ui/_helpers.js");
const icon_js_1 = __webpack_require__(/*! ./icon.js */ "./lib/ui/icon.js");
const Button = (props) => {
    const { children, outlined = false, text = false, background = '#6200ee', color = '#ffffff', style = '', class: className = '', icon } = props, rest = __rest(props, ["children", "outlined", "text", "background", "color", "style", "class", "icon"]);
    const normal = !(outlined || text);
    const bg = normal ? background : '#ffffff';
    const clr = normal ? color : background;
    const hoverClr = normal ? (0, _helpers_js_1.lightenColor)(bg, 10) : (0, _helpers_js_1.lightenColor)(bg, -10);
    const rippleClr = normal ? (0, _helpers_js_1.lightenColor)(bg, 50) : (0, _helpers_js_1.lightenColor)(background, 50);
    const cssHash = (0, core_js_1.strToHash)(outlined.toString() + text.toString() + bg + clr + style);
    const ripple = (0, _config_js_1.rippleEffect)(rippleClr, hoverClr);
    const styles = `
    .nano_jsx_button-${cssHash} {
      color: ${clr};
      background: ${bg};
      border-radius: 4px;
      display: inline-flex;
      font-size: 14px;
      padding: 10px 16px;
      margin: 0px 0px 1em 0px;
      text-align: center;
      cursor: pointer;

      ${_config_js_1.userSelect}
      

      z-index: ${_config_js_1.zIndex.button}

      ${_config_js_1.boxShadow}

      border: none;
      text-transform: uppercase;
      box-shadow: 0 0 4px #999;
      outline: none;
    }

    ${ripple.styles}
  `;
    (0, _helpers_js_1.addStylesToHead)(styles, cssHash);
    let customStyles = '';
    if (outlined || text) {
        customStyles += 'padding-top: 9px; padding-bottom: 9px; ';
        customStyles += '-webkit-box-shadow: none; -moz-box-shadow: none; box-shadow none; ';
        if (outlined)
            customStyles += `border: 1px ${clr} solid; `;
    }
    customStyles += style;
    return (0, core_js_1.h)('button', Object.assign({ class: `nano_jsx_button-${cssHash} ${ripple.class} ${className}`, style: customStyles }, rest), icon ? (0, core_js_1.h)(icon_js_1.Icon, { style: 'margin-left: -4px; margin-right: 8px; width: 14px; height: 14px;' }, icon) : null, children);
};
exports.Button = Button;
//# sourceMappingURL=button.js.map

/***/ }),

/***/ "./lib/ui/dialog.js":
/*!**************************!*\
  !*** ./lib/ui/dialog.js ***!
  \**************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Dialog = void 0;
const core_js_1 = __webpack_require__(/*! ../core.js */ "./lib/core.js");
const _config_js_1 = __webpack_require__(/*! ./_config.js */ "./lib/ui/_config.js");
const button_js_1 = __webpack_require__(/*! ./button.js */ "./lib/ui/button.js");
class Dialog {
    constructor(options = {}) {
        this.options = options;
        this.defaultParentId = 'dialog_container';
        this.defaultActionColor = '#6200EE';
        const defaultOptions = {
            title: 'Dialog Title',
            body: 'Dialog body text.',
            actions: [
                { name: 'Action 1', color: this.defaultActionColor },
                { name: 'Action 2', color: this.defaultActionColor }
            ],
            firstFocusAction: false
        };
        this.options = Object.assign(Object.assign({}, defaultOptions), options);
        // styles
        const styles = `
    #dialog_container {  
      background: #00000070;
      position: fixed;
      bottom: 0px;
      left: 0px;
      display: flex;
      align-items: center;
      justify-content: center;
      flex-direction: column;
      width: 100vw;
      height: 100vh;
      overflow: hidden;
      
      z-index: ${_config_js_1.zIndex.dialog}

      animation-name: dialog-fadein;
      animation-duration: 0.2s;

      transition: opacity 0.2s;
      opacity: 1;
    }

    #dialog_container.dialog_fadeout {
      opacity: 0;
    } 

    #dialog_container .dialog {
      background-color: white;
      border-radius: 4px;
      min-width: 240px;
      max-width: min(500px, 80%);

      margin: 8px;

      ${_config_js_1.boxShadow}
    }

    #dialog_container .dialog .dialog_header {
      color: #000000DE;
      font-size: 20px;
      padding: 0px 24px 9px;
      margin: 24px 0px 6px 0px;
      line-height: 1;
    }

    #dialog_container .dialog .dialog_body {
      color: #00000099;
      font-size: 16px;  
      padding: 0px 24px 20px;
      line-height: 1.5em;
    }

    #dialog_container .dialog .dialog_actions {
      
      margin: 0;
      padding: 8px;
      
      display: flex;
      flex-direction: row;
      align-items: flex-end;
      float: right;

      flex-wrap: wrap;
      justify-content: flex-end;
    }

    #dialog_container .dialog .dialog_action {
      margin-bottom: 0px;
      margin-left: 10px;
    }

    /*#dialog_container .dialog .dialog_action:hover {
      border-radius: 4px;      
      background: #0000000a;
    }*/

    @keyframes dialog-fadein {
      from {opacity: 0;}
      to {opacity: 1;}
    }
    `;
        document.head.appendChild((0, core_js_1.h)('style', {}, styles));
        this.handleKeydown = this.handleKeydown.bind(this);
    }
    getParentElement(parentId) {
        let el = document.getElementById(parentId || this.defaultParentId);
        if (!el) {
            el = document.createElement('div');
            el.id = this.defaultParentId;
            el.ariaHidden = 'true';
            document.body.appendChild(el);
        }
        return el;
    }
    handleKeydown(event) {
        if (event.key === 'Escape' || event.key === 'Esc') {
            this.remove();
        }
        if (event.key === 'Tab') {
            event.preventDefault();
            const actions = Array.from(document.querySelectorAll('.dialog_action'));
            if (actions.length < 1) {
                return;
            }
            const currentFocus = actions.findIndex(el => document.activeElement === el);
            if (currentFocus === -1) {
                actions[0].focus();
            }
            const nextFocus = currentFocus + (event.shiftKey ? -1 : 1);
            if (nextFocus === -1) {
                actions[actions.length - 1].focus();
                return;
            }
            if (nextFocus === actions.length) {
                actions[0].focus();
                return;
            }
            actions[nextFocus].focus();
        }
    }
    remove() {
        const el = document.getElementById('dialog_container');
        if (!el)
            return;
        el.classList.add('dialog_fadeout');
        setTimeout(() => {
            el.remove();
            window.removeEventListener('keydown', this.handleKeydown);
            this.enableScroll();
        }, 200);
    }
    disableScroll() {
        document.body.style.overflow = 'hidden';
    }
    enableScroll() {
        // default
        document.body.style.overflow = '';
    }
    focusAction(focusActionId, actions) {
        const actionElements = Array.from(document.querySelectorAll('.dialog_action'));
        const focusTargetIndex = actions.findIndex(action => action.id === focusActionId);
        const focusTarget = actionElements[focusTargetIndex];
        if (focusTarget) {
            focusTarget.focus();
        }
    }
    focusFirstAction() {
        const actionElements = Array.from(document.querySelectorAll('.dialog_action'));
        const focusTarget = actionElements[0];
        if (focusTarget) {
            focusTarget.focus();
        }
    }
    show(options, callback) {
        options = Object.assign(Object.assign({}, this.options), options);
        const container = this.getParentElement(options.parentId || this.defaultParentId);
        if (container.hasChildNodes())
            return;
        // remove dialog when container (background) gets clicked
        container.addEventListener('click', e => {
            if (e.target === container)
                this.remove();
        });
        const Dialog = (_header, _body, _actions) => {
            const actionsArray = _actions.map((action) => {
                return (0, core_js_1.h)(button_js_1.Button, {
                    text: true,
                    color: action.color || this.defaultActionColor,
                    class: 'dialog_action',
                    // style: `color: ${action.color || this.defaultActionColor}`,
                    onClick: () => {
                        callback({ name: action.name, id: action.id });
                        this.remove();
                    }
                }, action.name.toUpperCase());
            });
            const title = (0, core_js_1.h)('h2', { class: 'dialog_header', id: 'dialog-title' }, _header);
            const body = (0, core_js_1.h)('div', { class: 'dialog_body' }, _body);
            const actions = (0, core_js_1.h)('div', { class: 'dialog_actions' }, actionsArray);
            const dialog = (0, core_js_1.h)('div', { class: 'dialog', role: 'dialog', 'aria-modal': 'true', 'aria-labelledby': 'dialog-title' }, title, body, actions);
            return dialog;
        };
        const el = Dialog(options.title, options.body, options.actions || []);
        container.appendChild(el);
        const { firstFocusAction } = options;
        if (options.actions && firstFocusAction) {
            if (typeof firstFocusAction === 'string') {
                this.focusAction(firstFocusAction, options.actions);
            }
            else {
                this.focusFirstAction();
            }
        }
        this.disableScroll();
        window.addEventListener('keydown', this.handleKeydown);
        const dialog = document.getElementsByClassName('dialog')[0];
        const actions = document.getElementsByClassName('dialog_actions')[0];
        // if the actions are too long, we prefer to set flex-direction to column than to wrap the single actions
        const useColumn = dialog.clientWidth <= actions.clientWidth;
        if (useColumn)
            actions.setAttribute('style', 'flex-direction: column;');
    }
}
exports.Dialog = Dialog;
//# sourceMappingURL=dialog.js.map

/***/ }),

/***/ "./lib/ui/fab.js":
/*!***********************!*\
  !*** ./lib/ui/fab.js ***!
  \***********************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Fab = void 0;
const component_js_1 = __webpack_require__(/*! ../component.js */ "./lib/component.js");
const core_js_1 = __webpack_require__(/*! ../core.js */ "./lib/core.js");
const _config_js_1 = __webpack_require__(/*! ./_config.js */ "./lib/ui/_config.js");
const _helpers_js_1 = __webpack_require__(/*! ./_helpers.js */ "./lib/ui/_helpers.js");
class Fab extends component_js_1.Component {
    render() {
        const { background = '#6200EE', color = 'white', extended = false, mini = false, center = false, left = false, onClick = () => { } } = this.props;
        const height = mini ? 40 : extended ? 48 : 56;
        const cssHash = (0, core_js_1.strToHash)(extended.toString() + mini.toString() + center.toString() + left.toString());
        const className = `fab-container-${cssHash}`;
        const styles = `
      .${className} {
        ${mini ? 'width: 40px;' : extended ? 'padding: 0px 12px;' : 'width: 56px;'}
        height: ${height}px;
        position: fixed;
        background: ${background};
        border-radius: 36px;
        display: flex;
        align-items: center;
        justify-content: center;
        color: ${color};
        cursor: pointer;

        z-index: ${_config_js_1.zIndex.fab}
        bottom: ${this.props.offsetY ? 16 + this.props.offsetY : 16}px;        
        ${left ? 'left: 16px;' : 'right: 16px;'}
        ${center ? 'transform: translateX(50%); right: 50%;' : ''}
        ${_config_js_1.boxShadow}
        ${_config_js_1.userSelect}
      }
    `;
        (0, _helpers_js_1.addStylesToHead)(styles, cssHash);
        const { children } = this.props;
        return (0, core_js_1.h)('div', { class: className, onClick: (e) => onClick(e) }, children);
    }
}
exports.Fab = Fab;
//# sourceMappingURL=fab.js.map

/***/ }),

/***/ "./lib/ui/icon.js":
/*!************************!*\
  !*** ./lib/ui/icon.js ***!
  \************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Icon = void 0;
const component_js_1 = __webpack_require__(/*! ../component.js */ "./lib/component.js");
const core_js_1 = __webpack_require__(/*! ../core.js */ "./lib/core.js");
const _helpers_js_1 = __webpack_require__(/*! ./_helpers.js */ "./lib/ui/_helpers.js");
class Icon extends component_js_1.Component {
    didUnmount() {
        // not sure if I want to remove the css, since there might be another Icon with the same styles.
        // const el = document.querySelector(`[data-css-hash*="${this.cssHash}"]`)
        // if (el) el.remove()
    }
    render() {
        const _a = this.props, { src, size = 16, active = true, color = '#6204EE', style = '' } = _a, rest = __rest(_a, ["src", "size", "active", "color", "style"]);
        // @ts-ignore
        const children = this.props.children;
        this.cssHash = (0, core_js_1.strToHash)(active + color + size.toString());
        const colors = {
            active: color,
            inactive: '#00000070'
        };
        const styles = `
    i.icon-${this.cssHash} {
      width: ${size}px;
      height: ${size}px;
      display: inline-block;
      content: '';

      /*-webkit-mask: url(YOUR_SVG_URL) no-repeat 50% 50%;
      mask: url(YOUR_SVG_URL) no-repeat 50% 50%;*/

      -webkit-mask-size: cover;
      mask-size: cover; 

      background-color: ${colors.active};
    }

    i.icon-${this.cssHash}.icon_inactive-${this.cssHash} {
      background-color: ${colors.inactive};
    }
    `;
        (0, _helpers_js_1.addStylesToHead)(styles, this.cssHash);
        // const iconStyle = `-webkit-mask: url(/dev/font-awesome/ellipsis-v-solid.svg) no-repeat 50% 50%;mask: url(/dev/font-awesome/ellipsis-v-solid.svg) no-repeat 50% 50%;`
        const iconStyle = `-webkit-mask: url(${src || children}) no-repeat 50% 50%; mask: url(${src || children}) no-repeat 50% 50%;`;
        const classes = [`icon-${this.cssHash}`];
        if (!active)
            classes.push(`icon_inactive-${this.cssHash}`);
        const icon = (0, core_js_1.h)('i', Object.assign(Object.assign({ class: classes.join(' ') }, rest), { style: iconStyle + style }));
        return icon;
    }
}
exports.Icon = Icon;
//# sourceMappingURL=icon.js.map

/***/ }),

/***/ "./lib/ui/index.js":
/*!*************************!*\
  !*** ./lib/ui/index.js ***!
  \*************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Sheet = exports.Tab = exports.Tabs = exports.Snackbar = exports.Menu = exports.ListItem = exports.List = exports.Icon = exports.Fab = exports.Dialog = exports.Button = exports.NavigationAction = exports.Navigation = exports.Toolbar = exports.AppBar = void 0;
var appBar_js_1 = __webpack_require__(/*! ../ui/appBar.js */ "./lib/ui/appBar.js");
Object.defineProperty(exports, "AppBar", ({ enumerable: true, get: function () { return appBar_js_1.AppBar; } }));
var toolbar_js_1 = __webpack_require__(/*! ../ui/toolbar.js */ "./lib/ui/toolbar.js");
Object.defineProperty(exports, "Toolbar", ({ enumerable: true, get: function () { return toolbar_js_1.Toolbar; } }));
var navigation_js_1 = __webpack_require__(/*! ../ui/navigation.js */ "./lib/ui/navigation.js");
Object.defineProperty(exports, "Navigation", ({ enumerable: true, get: function () { return navigation_js_1.Navigation; } }));
Object.defineProperty(exports, "NavigationAction", ({ enumerable: true, get: function () { return navigation_js_1.NavigationAction; } }));
var button_js_1 = __webpack_require__(/*! ../ui/button.js */ "./lib/ui/button.js");
Object.defineProperty(exports, "Button", ({ enumerable: true, get: function () { return button_js_1.Button; } }));
var dialog_js_1 = __webpack_require__(/*! ../ui/dialog.js */ "./lib/ui/dialog.js");
Object.defineProperty(exports, "Dialog", ({ enumerable: true, get: function () { return dialog_js_1.Dialog; } }));
var fab_js_1 = __webpack_require__(/*! ../ui/fab.js */ "./lib/ui/fab.js");
Object.defineProperty(exports, "Fab", ({ enumerable: true, get: function () { return fab_js_1.Fab; } }));
var icon_js_1 = __webpack_require__(/*! ../ui/icon.js */ "./lib/ui/icon.js");
Object.defineProperty(exports, "Icon", ({ enumerable: true, get: function () { return icon_js_1.Icon; } }));
var list_js_1 = __webpack_require__(/*! ../ui/list.js */ "./lib/ui/list.js");
Object.defineProperty(exports, "List", ({ enumerable: true, get: function () { return list_js_1.List; } }));
Object.defineProperty(exports, "ListItem", ({ enumerable: true, get: function () { return list_js_1.ListItem; } }));
var menu_js_1 = __webpack_require__(/*! ../ui/menu.js */ "./lib/ui/menu.js");
Object.defineProperty(exports, "Menu", ({ enumerable: true, get: function () { return menu_js_1.Menu; } }));
var snackbar_js_1 = __webpack_require__(/*! ../ui/snackbar.js */ "./lib/ui/snackbar.js");
Object.defineProperty(exports, "Snackbar", ({ enumerable: true, get: function () { return snackbar_js_1.Snackbar; } }));
var tabs_js_1 = __webpack_require__(/*! ../ui/tabs.js */ "./lib/ui/tabs.js");
Object.defineProperty(exports, "Tabs", ({ enumerable: true, get: function () { return tabs_js_1.Tabs; } }));
Object.defineProperty(exports, "Tab", ({ enumerable: true, get: function () { return tabs_js_1.Tab; } }));
var sheet_js_1 = __webpack_require__(/*! ../ui/sheet.js */ "./lib/ui/sheet.js");
Object.defineProperty(exports, "Sheet", ({ enumerable: true, get: function () { return sheet_js_1.Sheet; } }));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./lib/ui/list.js":
/*!************************!*\
  !*** ./lib/ui/list.js ***!
  \************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.List = exports.ListItem = void 0;
const component_js_1 = __webpack_require__(/*! ../component.js */ "./lib/component.js");
const core_js_1 = __webpack_require__(/*! ../core.js */ "./lib/core.js");
const icon_js_1 = __webpack_require__(/*! ./icon.js */ "./lib/ui/icon.js");
const _helpers_js_1 = __webpack_require__(/*! ./_helpers.js */ "./lib/ui/_helpers.js");
class ListItem extends component_js_1.Component {
    render() {
        const { props: p } = this;
        const { onClick = () => { } } = p;
        const adjustedMargin = 'margin-right: 16px;';
        const icon = p.icon ? (0, core_js_1.h)(icon_js_1.Icon, { size: 20, style: 'margin-right: 32px;', src: p.icon }) : null;
        const avatar = p.avatar
            ? (0, core_js_1.h)('img', { src: p.avatar, width: 40, height: 40, style: `border-radius: 20px; ${adjustedMargin}` })
            : null;
        const square = p.square ? (0, core_js_1.h)('img', { src: p.square, width: 56, height: 56, style: adjustedMargin }) : null;
        const image = p.image
            ? (0, core_js_1.h)('img', { src: p.image, width: 100, height: 56, style: 'margin-left: -16px; margin-right: 16px;' })
            : null;
        const text = (0, core_js_1.h)('span', null, p.children);
        // additional style for the list item
        let style = '';
        if (p.icon || p.avatar)
            style += 'min-height: 56px; ';
        if (p.square || p.image)
            style += 'min-height: 72px; ';
        return (0, core_js_1.h)('li', { style, onClick }, icon, avatar, square, image, text);
    }
}
exports.ListItem = ListItem;
class List extends component_js_1.Component {
    render() {
        const { small = false } = this.props;
        this.cssHash = (0, core_js_1.strToHash)(`List${small.toString()}`);
        const styles = `
      .list-${this.cssHash} ul {
        margin: 0px;
        padding: 8px 16px;
      }

      .list-${this.cssHash} ul li {
        list-style: none;
        min-height: ${small ? 32 : 46}px;
        display: flex;
        align-items: center;
        margin: 0px -16px;
        padding: 0px 16px;
        cursor: pointer;
      }

      .list-${this.cssHash} ul li span {
        font-size: 16px;
      }

      .list-${this.cssHash} ul li:hover  {
        background:#00000010
      }    
    `;
        (0, _helpers_js_1.addStylesToHead)(styles, this.cssHash);
        const ul = (0, core_js_1.h)('ul', null, this.props.children);
        return (0, core_js_1.h)('div', { class: `list-${this.cssHash}` }, ul);
    }
}
exports.List = List;
//# sourceMappingURL=list.js.map

/***/ }),

/***/ "./lib/ui/menu.js":
/*!************************!*\
  !*** ./lib/ui/menu.js ***!
  \************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Menu = void 0;
const core_js_1 = __webpack_require__(/*! ../core.js */ "./lib/core.js");
const _config_js_1 = __webpack_require__(/*! ./_config.js */ "./lib/ui/_config.js");
const _helpers_js_1 = __webpack_require__(/*! ./_helpers.js */ "./lib/ui/_helpers.js");
class Menu {
    constructor() {
        this.defaultParentId = 'menu_items_container';
        this.cssHash = Math.random().toString(36).substring(2);
    }
    // didUnmount() {
    //   const el = document.querySelector(`[data-css-hash*="${this.cssHash}"]`)
    //   if (el) el.remove()
    // }
    getParentElement(id) {
        // delete all other
        const others = document.querySelectorAll(`[id^="${this.defaultParentId}"]`);
        others.forEach(e => {
            e.remove();
        });
        let el = document.getElementById(`${this.defaultParentId}-${id}`);
        if (!el) {
            el = document.createElement('div');
            el.id = `${this.defaultParentId}-${id}`;
        }
        (0, core_js_1.removeAllChildNodes)(el);
        document.body.appendChild(el);
        return el;
    }
    close() {
        (0, core_js_1.removeAllChildNodes)(this.getParentElement(this.cssHash));
    }
    open(menuOptions) {
        const { position, list } = menuOptions;
        // check in which corner the menu appears and adjust fixed position.
        const left = position.x < window.innerWidth / 2 ? 'left' : 'right';
        const top = position.y < window.innerHeight / 2 ? 'top' : 'bottom';
        const styles = `
   
    #menu_items_background-${this.cssHash} {
      width: 100vw;
      height: 100vh;
      background: transparent;
      position: fixed;
      top: 0;
      left: 0;
      z-index: ${_config_js_1.zIndex.menu}      
    }
   
    #menu_items_list-${this.cssHash} {
      position: fixed;
      background: white;
      
      border-radius: 4px;
      min-width: 112px;

      ${top}: ${position.y > window.innerHeight / 2 ? window.innerHeight - position.y : position.y}px;
      ${left}: ${position.x > window.innerWidth / 2 ? window.innerWidth - position.x : position.x}px;

      z-index: ${_config_js_1.zIndex.menu}

      ${_config_js_1.boxShadow}
    }

    `;
        // remove old styles
        const el = document.querySelector(`[data-css-hash*="${this.cssHash}"]`);
        if (el)
            el.remove();
        // add new styles
        (0, _helpers_js_1.addStylesToHead)(styles, this.cssHash);
        const itemsList = (0, core_js_1.h)('div', { id: `menu_items_list-${this.cssHash}` }, list);
        const itemsBg = (0, core_js_1.h)('div', { onClick: () => this.close(), id: `menu_items_background-${this.cssHash}` }, itemsList);
        itemsList.addEventListener('click', (e) => e.stopPropagation());
        this.getParentElement(this.cssHash).appendChild((0, core_js_1.render)(itemsBg));
    }
}
exports.Menu = Menu;
//# sourceMappingURL=menu.js.map

/***/ }),

/***/ "./lib/ui/navigation.js":
/*!******************************!*\
  !*** ./lib/ui/navigation.js ***!
  \******************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Navigation = exports.NavigationAction = void 0;
const core_js_1 = __webpack_require__(/*! ../core.js */ "./lib/core.js");
const component_js_1 = __webpack_require__(/*! ../component.js */ "./lib/component.js");
const _config_js_1 = __webpack_require__(/*! ./_config.js */ "./lib/ui/_config.js");
const icon_js_1 = __webpack_require__(/*! ./icon.js */ "./lib/ui/icon.js");
const classes = {
    label: 'bottom_navigation_label',
    action: 'bottom_navigation_action',
    idPrefix: 'bottom_navigation_action_id-',
    inactive: 'bottom_navigation_action_inactive',
    initialActive: 'bottom_navigation_label_initial_active'
};
class NavigationAction extends component_js_1.Component {
    willMount() {
        var _a;
        this.id = (_a = this.props.id) !== null && _a !== void 0 ? _a : this.props.label.toLowerCase().replace(/\s/gm, '-').replace(/[-]+/gm, '-');
    }
    render() {
        const label = (0, core_js_1.h)('span', { class: classes.label }, this.props.label);
        const actionClasses = [classes.action];
        if (this.props.active)
            actionClasses.push(classes.initialActive);
        else
            actionClasses.push(classes.inactive);
        return (0, core_js_1.h)('div', {
            id: `${classes.idPrefix}${this.id}`,
            class: actionClasses.join(' '),
            onClick: () => {
                var _a, _b;
                if (this.props.link)
                    window.location.href = this.props.link;
                (_b = (_a = this.props).onClick) === null || _b === void 0 ? void 0 : _b.call(_a, { navigate: !!this.props.link, id: this.id, label: this.props.label, component: this });
            }
        }, this.props.icon ? (0, core_js_1.h)(icon_js_1.Icon, { size: 22, style: 'margin-bottom: 2px;', src: this.props.icon }) : null, label);
    }
}
exports.NavigationAction = NavigationAction;
class Navigation extends component_js_1.Component {
    didMount() {
        const children = this.props.children;
        children.forEach(c => {
            c.props.onClick = e => {
                var _a, _b;
                if (e.navigate)
                    return;
                const elements = document.querySelectorAll(`[id^="${classes.idPrefix}"]`);
                elements.forEach(el => {
                    if (el.id === `${classes.idPrefix}${e.id}`)
                        el.classList.remove(classes.inactive);
                    else
                        el.classList.add(classes.inactive);
                });
                (_b = (_a = this.props).onClick) === null || _b === void 0 ? void 0 : _b.call(_a, e);
            };
        });
    }
    render() {
        const colors = {
            active: '#6204EE',
            inactive: '#00000070'
        };
        const styles = `
      #bottom_navigation_container {

        background-color: white;
        position: fixed;
        bottom: 0;
        left: 0;
        width: 100vw;
        min-height: 56px;

        z-index: ${_config_js_1.zIndex.navigation}

        display: flex;
        justify-content: center;
        
        ${_config_js_1.boxShadow}
      } 

      #bottom_navigation_container .bottom_navigation_label {
        transition: font-size 0.2s;
      }

      #bottom_navigation_container .bottom_navigation_label_initial_active .bottom_navigation_label{
        animation-name: bottom_navigation_label_fontsize;
        animation-duration: 0.2s;
      }

      @keyframes bottom_navigation_label_fontsize {
        from {font-size: 12px;}
        to {font-size: 14px;}
      }

      #bottom_navigation_container .bottom_navigation_action {
        color: ${colors.active};
        font-size: 14px;

        min-width: 80px;
        max-width: 168px;
        flex-grow: 1;

        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;

        cursor: pointer;
      }

      #bottom_navigation_container .bottom_navigation_action_inactive{
        color: ${colors.inactive};
        font-size: 12px;
      }

      #bottom_navigation_container .bottom_navigation_action_inactive i {
        background-color: ${colors.inactive}
      }
    `;
        document.head.appendChild((0, core_js_1.h)('style', {}, styles));
        const { parentId, children } = this.props;
        const navigation = (0, core_js_1.h)('div', { id: 'bottom_navigation_container' }, children);
        if (parentId) {
            const parent = document.getElementById(parentId);
            if (parent) {
                parent.appendChild(navigation);
                return;
            }
        }
        return navigation;
    }
}
exports.Navigation = Navigation;
//# sourceMappingURL=navigation.js.map

/***/ }),

/***/ "./lib/ui/sheet.js":
/*!*************************!*\
  !*** ./lib/ui/sheet.js ***!
  \*************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Sheet = void 0;
const component_js_1 = __webpack_require__(/*! ../component.js */ "./lib/component.js");
const core_js_1 = __webpack_require__(/*! ../core.js */ "./lib/core.js");
const _config_js_1 = __webpack_require__(/*! ./_config.js */ "./lib/ui/_config.js");
const _helpers_js_1 = __webpack_require__(/*! ./_helpers.js */ "./lib/ui/_helpers.js");
class Sheet extends component_js_1.Component {
    static show(sheet) {
        document.body.appendChild((0, core_js_1.render)(sheet));
    }
    static close() {
        const el = document.querySelector('[class^=sheet_container]');
        if (el)
            el.remove();
    }
    render() {
        const { mode = 'custom', title, subtitle } = this.props;
        const cssHash = (0, core_js_1.strToHash)(`sheet${mode}`);
        const isSide = mode === 'side' || mode === 'right' || mode === 'left';
        const isBottom = mode === 'bottom';
        const fadeIn = mode === 'side' ? 'left' : mode;
        const borderRadius = mode === 'bottom' ? 'border-radius: 4px;' : '';
        let sheetStyles = '';
        if (isSide) {
            sheetStyles += `
        min-width: 256px;
        max-width: calc(100vw - 56px);
        height: 100vh;

        top: 0;
        ${mode === 'right' ? 'right' : 'left'}: 0;`;
        }
        if (isBottom) {
            sheetStyles += `
        width: 100vw;
        bottom: 0px;      
        left: 0;`;
        }
        const styles = `
      @keyframes sheet_fadein_${fadeIn}-${cssHash} {
        from {${fadeIn}: -100%;}
        to {${fadeIn}: 0;}
      }

      .sheet_container-${cssHash} {
      }

      .sheet_sheet-${cssHash} {
        overflow: scroll;
        max-height: 100vh;

        ${sheetStyles}
        background: white;
        position: fixed;

        ${borderRadius}

        box-sizing: border-box;
        ${_config_js_1.boxShadow}

        z-index: ${_config_js_1.zIndex.sheet}

        animation-name: sheet_fadein_${fadeIn}-${cssHash};
        animation-duration: 0.2s;

        transition: top 2s, right 2s, bottom 2s, left 2s;
      }

      .sheet_background-${cssHash} {
        background: #00000070;
        position: fixed;
        top: 0px;
        left: 0px;
        width: 100vw;
        height: 100vh;
        z-index: ${_config_js_1.zIndex.sheet}

        animation-name: sheet-background-fadein;
        animation-duration: 0.2s;
      }

      @keyframes sheet-background-fadein {
        from {opacity: 0;}
        to {opacity: 1;}
      }
      
      .sheet_title-${cssHash} {
        padding: 20px 16px 0px;
        font-size: 24px;
      }
      
      .sheet_subtitle-${cssHash} {
        padding: 8px 16px;
        font-size: 14px;
        color: #000000b0;
      }`;
        (0, _helpers_js_1.addStylesToHead)(styles, cssHash);
        const background = (0, core_js_1.h)('div', {
            class: `sheet_background-${cssHash}`,
            onClick: () => {
                element.remove();
            }
        });
        const t = title ? (0, core_js_1.h)('div', { class: `sheet_title-${cssHash}` }, title) : null;
        const s = subtitle ? (0, core_js_1.h)('div', { class: `sheet_subtitle-${cssHash}` }, subtitle) : null;
        // @ts-ignore
        const sh = (0, core_js_1.h)('div', { class: `sheet_sheet-${cssHash}` }, t, s, this.props.children);
        const element = (0, core_js_1.h)('div', { class: `sheet_container-${cssHash}` }, background, sh);
        return element;
    }
}
exports.Sheet = Sheet;
//# sourceMappingURL=sheet.js.map

/***/ }),

/***/ "./lib/ui/snackbar.js":
/*!****************************!*\
  !*** ./lib/ui/snackbar.js ***!
  \****************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Snackbar = void 0;
const core_js_1 = __webpack_require__(/*! ../core.js */ "./lib/core.js");
const _config_js_1 = __webpack_require__(/*! ./_config.js */ "./lib/ui/_config.js");
class Snackbar {
    constructor(options = {}) {
        this.options = options;
        this.defaultParentId = 'snackbar_container';
        this.defaultActionColor = '#BC86FC';
        const defaultOptions = {
            message: 'Hello Snack!',
            actions: [{ name: 'Dismiss', color: this.defaultActionColor }],
            autoHide: true,
            consecutive: true,
            offsetY: 0
        };
        this.options = Object.assign(Object.assign({}, defaultOptions), options);
        // styles
        const styles = `
      #snackbar_container {    
        position: fixed;
        bottom: ${this.options.offsetY}px;
        left: 0px;
        overflow: hidden;
        z-index: ${_config_js_1.zIndex.snackbar}
      }

      #snackbar_container .snackbar_snack {
        background-color: #323232;

        padding: 16px 16px 16px 16px;
        margin: 0px 8px 8px 8px;

        border-radius: 4px;
        width: 344px;
        max-width: calc(100vw - 16px);
        box-sizing: border-box;
        display: flex;
        justify-content: space-between;
        height: fit-content;
        overflow: hidden;

        ${_config_js_1.boxShadow}

        animation-name: snackbar-fadein;
        animation-duration: 0.2s;

        transition: opacity 0.2s;
        opacity: 1;
      }

      #snackbar_container .snackbar_snack_fadeout {
        opacity: 0;
      } 

      #snackbar_container .snackbar_snack .snackbar_message {
        color: #DFDFDF;
        font-size: 16px;
        align-self: center;
      }

      #snackbar_container .snackbar_snack .snackbar_actions {
        align-self: center;
      }

      #snackbar_container .snackbar_snack .snackbar_action {
        font-size: 16px;
        cursor: pointer;
        padding: 8px;
        margin-right: -8px;
      }

      @keyframes snackbar-fadein {
        from {opacity: 0;}
        to {opacity: 1;}
      }
    `;
        document.head.appendChild((0, core_js_1.h)('style', {}, styles));
    }
    getParentElement(parentId) {
        let el = document.getElementById(parentId || this.defaultParentId);
        if (!el) {
            el = document.createElement('div');
            el.id = this.defaultParentId;
            document.body.appendChild(el);
        }
        return el;
    }
    remove(el) {
        el.classList.add('snackbar_snack_fadeout');
        setTimeout(() => el.remove(), 200);
    }
    show(options, callback) {
        if (this.options.consecutive) {
            const snacks = document.querySelectorAll('.snackbar_snack');
            snacks.forEach(s => this.remove(s));
            if (snacks.length > 0)
                setTimeout(() => this._show(options, callback), 200 + 20);
            else
                this._show(options, callback);
            return;
        }
        this._show(options, callback);
    }
    _show(options, callback) {
        options = Object.assign(Object.assign({}, this.options), options);
        const container = this.getParentElement(options.parentId || this.defaultParentId);
        // adjust offsetY
        if (typeof options.offsetY === 'number')
            container.style.bottom = `${options.offsetY}px`;
        const Snack = (_message, _actions) => {
            const actionsArray = _actions.map((action) => {
                return (0, core_js_1.h)('a', {
                    class: 'snackbar_action',
                    style: `color: ${action.color || this.defaultActionColor}`,
                    onClick: () => {
                        if (callback)
                            callback({ name: action.name, id: action.id });
                        this.remove(el);
                    }
                }, action.name.toUpperCase());
            });
            const message = (0, core_js_1.h)('div', { class: 'snackbar_message' }, _message);
            const actions = (0, core_js_1.h)('div', { class: 'snackbar_actions' }, actionsArray);
            const snack = (0, core_js_1.h)('div', { class: 'snackbar_snack' }, message, actions);
            return snack;
        };
        const el = Snack(options.message, options.actions || []);
        // autoHide options
        if (options.autoHide === true)
            setTimeout(() => this.remove(el), 5000);
        else if (typeof options.autoHide === 'number')
            setTimeout(() => this.remove(el), options.autoHide);
        container.appendChild(el);
    }
}
exports.Snackbar = Snackbar;
//# sourceMappingURL=snackbar.js.map

/***/ }),

/***/ "./lib/ui/tabs.js":
/*!************************!*\
  !*** ./lib/ui/tabs.js ***!
  \************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Tabs = exports.Tab = void 0;
const component_js_1 = __webpack_require__(/*! ../component.js */ "./lib/component.js");
const core_js_1 = __webpack_require__(/*! ../core.js */ "./lib/core.js");
const _config_js_1 = __webpack_require__(/*! ./_config.js */ "./lib/ui/_config.js");
const _helpers_js_1 = __webpack_require__(/*! ./_helpers.js */ "./lib/ui/_helpers.js");
const Tab = (props) => {
    const classes = [props.itemClass, props.rippleClass];
    if (props.active)
        classes.push('active');
    const link = props.href ? { href: props.href } : {};
    const a = (0, core_js_1.h)('a', Object.assign({}, link), props.children);
    return (0, core_js_1.h)('li', { class: classes.join(' '), onClick: () => props.onClickHandler({ index: props.index }) }, a);
};
exports.Tab = Tab;
class Tabs extends component_js_1.Component {
    constructor() {
        super(...arguments);
        this.active = this.props.active || 0;
    }
    didMount() {
        const adjustLine = (item) => {
            var _a;
            if (!item)
                return;
            const first = this.items[0].getBoundingClientRect();
            const active = item.getBoundingClientRect();
            this.line.style.left = `${active.x - first.x}px`;
            this.line.style.width = `${active.width}px`;
            // disable old
            (_a = document.querySelector('.tabs_item.active')) === null || _a === void 0 ? void 0 : _a.classList.remove('active');
            // enable new
            item.classList.add('active');
        };
        const scrollIntoView = (item) => {
            if (!this.props.scroll)
                return;
            item.scrollIntoView({
                behavior: 'smooth',
                block: 'center',
                inline: 'center'
            });
        };
        // @ts-ignore
        (0, core_js_1.tick)(() => {
            adjustLine(this.items[this.active]);
            scrollIntoView(this.items[this.active]);
        });
        for (let i = 0; i < this.items.length; i++) {
            const item = this.items[i];
            item.addEventListener('click', () => {
                this.active = i;
                // looks hacky, but works well :)
                setTimeout(() => adjustLine(item), 50);
                setTimeout(() => adjustLine(item), 100);
                setTimeout(() => adjustLine(item), 150);
                // does not work in safari
                scrollIntoView(item);
            });
        }
    }
    render() {
        var _a;
        const ripple = (0, _config_js_1.rippleEffect)('#ffffff70', '#5902db');
        const { scroll = false, children, active } = this.props;
        const cssHash = (0, core_js_1.strToHash)(scroll.toString() + (children === null || children === void 0 ? void 0 : children.length) + active + ripple.class);
        const styles = `
      .tabs_container-${cssHash} {
        background: #6204ee;

        width: 100%;
        height: 48px;

        overflow-x: ${this.props.scroll ? 'scroll' : 'hidden'};
        overflow-y: hidden;

        ${_config_js_1.userSelect}
      }

      /* Hide scrollbar for Chrome, Safari and Opera */
      .tabs_container-${cssHash}::-webkit-scrollbar {
        display: none;
      }

      /* Hide scrollbar for IE, Edge and Firefox */
      .tabs_container-${cssHash} {
        -ms-overflow-style: none; /* IE and Edge */
        scrollbar-width: none; /* Firefox */
      }

      .tabs_list-${cssHash} {
        ${!this.props.scroll ? 'display: flex; justify-content: space-evenly;' : ''}

        height: 100%;
        display: flex;
        list-style-type: none;
        margin: 0;
        padding: 0;
        cursor: pointer;
      }

      .tabs_item-${cssHash} {
        ${!this.props.scroll ? 'width: 100%; text-align: center;' : ''}

        padding-top: 16px;
        font-size: 14px;
        text-transform: uppercase;
        color: rgba(255, 255, 255, 0.75);
        transition: color 0.2s;
      }
      
      
      .tabs_item-${cssHash} a {
        font-size: 14px;
        padding: 16px 32px;
        text-decoration: none;
        text-transform: uppercase;
        color: rgba(255, 255, 255, 0.75);
        transition: color 0.2s;
      }

      .tabs_item-${cssHash}.active a {
        color: rgba(255, 255, 255, 1);
      }

      .tabs_item-${cssHash}:active {
        background: #5902db;
      }

      /* if the primary input mechanism system of the device can hover over elements with ease, we use hover */
      @media (hover: hover) {
        .tabs_item-${cssHash}:hover {
          background: #5902db;
        }
      }

      ${ripple.styles}

      .tabs_line-${cssHash} {
        border-bottom: 2px solid white;
        position: relative;
        top: -2px;

        opacity: 0;
        
        left: 50%;
        width: 0px;

        transition: left 0.5s, width 0.5s;

        animation-name: tabs_line_fadein;
        animation-duration: 0.25s;
        animation-delay: 0.25s;
        animation-fill-mode: forwards;
      }
      
      @keyframes tabs_line_fadein {
        from {opacity: 0;}
        to {opacity: 1;}
      }
      `;
        (0, _helpers_js_1.addStylesToHead)(styles, cssHash);
        // set the active tab
        (_a = this.props.children) === null || _a === void 0 ? void 0 : _a.forEach((c, i) => {
            // is active
            if (i === this.active)
                c.props = Object.assign(Object.assign({}, c.props), { active: true });
            // add ripple class
            c.props = Object.assign(Object.assign({}, c.props), { rippleClass: ripple.class, itemClass: `tabs_item-${cssHash}`, index: i });
            // add click events
            c.props.onClickHandler = (event) => this.props.onClick(event);
        });
        this.items = (0, core_js_1.render)(this.props.children);
        const list = (0, core_js_1.h)('ul', { class: `tabs_list-${cssHash}` }, this.items);
        this.line = (0, core_js_1.h)('div', { class: `tabs_line-${cssHash}` });
        const container = (0, core_js_1.h)('div', { class: `tabs_container-${cssHash}` }, list, this.line);
        return container;
    }
}
exports.Tabs = Tabs;
//# sourceMappingURL=tabs.js.map

/***/ }),

/***/ "./lib/ui/toolbar.js":
/*!***************************!*\
  !*** ./lib/ui/toolbar.js ***!
  \***************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Toolbar = void 0;
const component_js_1 = __webpack_require__(/*! ../component.js */ "./lib/component.js");
const core_js_1 = __webpack_require__(/*! ../core.js */ "./lib/core.js");
const classes = {
    bar: 'toolbar_container',
    left: 'toolbar_left',
    right: 'toolbar_right',
    icon: 'toolbar_icon'
};
class Toolbar extends component_js_1.Component {
    static setTitle(title) {
        const el = document.querySelector('.toolbar_title');
        if (el)
            el.innerText = title;
    }
    render() {
        const styles = `
      .toolbar_container {
        padding: 16px;
      }

      .toolbar_container .toolbar_text {
        font-size: 20px;
        margin-left: 24px;
        cursor: pointer;
      }

      .toolbar_container .toolbar_icon {
        width: 22px;
        height: 22px;
        margin-left: 24px;
        cursor: pointer;

        display: inline-block;
        content: '';

        /*-webkit-mask: url(YOUR_SVG_URL) no-repeat 50% 50%;
        mask: url(YOUR_SVG_URL) no-repeat 50% 50%;*/

        -webkit-mask-size: cover;
        mask-size: cover; 

        background-color: white;
      }

      .toolbar_navigation_box {
        padding: 4px;
        width: 20px;
        height: 16px;
        margin-right: 32px;
        cursor: pointer;
      }

      .toolbar_hamburger_button,
      .toolbar_hamburger_button::before,
      .toolbar_hamburger_button::after {
        position: absolute;
        width: 20px;
        height: 2px;
        border-radius: 2px;
        background: white;
        content: '';
      }
      .toolbar_hamburger_button::before {
        top: 6px;
      }
      .toolbar_hamburger_button::after {
        top: 12px;
      }

      .toolbar_button_wrapper {
        width: 24px;
        height: 24px;
        padding: 2px;
        position: relative;
        top: -2px;
      }

      .toolbar_back_button,
      .toolbar_back_button::before,
      .toolbar_back_button::after {
        position: relative;
        top: 7px;
        width: 20px;
        height: 2px;
        border-radius: 2px;
        background: white;
        content: '';
      }

      .toolbar_back_button::before {
        position: absolute;
        top: -5px;
        transform: translate3d(-4px,0,0) rotate(-45deg) scaleX(.7);
      }

      .toolbar_back_button::after {
        position: absolute;
        top: 5px;
        transform: translate3d(-4px,0,0) rotate(45deg) scaleX(.7);
      }
    `;
        document.head.appendChild((0, core_js_1.h)('style', {}, styles));
        const { back = false, actionClick = () => { }, menu } = this.props;
        const navigationAction = menu
            ? (0, core_js_1.h)('div', {
                class: 'toolbar_button_wrapper',
                onClick: actionClick
            }, (0, core_js_1.h)('div', { class: 'toolbar_hamburger_button' }))
            : back
                ? (0, core_js_1.h)('div', {
                    class: 'toolbar_button_wrapper',
                    onClick: actionClick
                }, (0, core_js_1.h)('div', {
                    class: 'toolbar_back_button'
                }))
                : null;
        const navigation = navigationAction ? (0, core_js_1.h)('div', { class: 'toolbar_navigation_box' }, navigationAction) : null;
        const title = this.props.title ? (0, core_js_1.h)('div', { class: 'toolbar_title' }, this.props.title) : null;
        const left = (0, core_js_1.h)('div', { class: classes.left }, navigation, title);
        const right = (0, core_js_1.h)('div', { class: classes.right }, this.props.children);
        const bar = (0, core_js_1.h)('div', { class: classes.bar }, left, right);
        return bar;
    }
}
exports.Toolbar = Toolbar;
//# sourceMappingURL=toolbar.js.map

/***/ }),

/***/ "./lib/version.js":
/*!************************!*\
  !*** ./lib/version.js ***!
  \************************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.VERSION = void 0;
// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
exports.VERSION = '0.0.37';
//# sourceMappingURL=version.js.map

/***/ }),

/***/ "./lib/withStyles.js":
/*!***************************!*\
  !*** ./lib/withStyles.js ***!
  \***************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.withStyles = void 0;
const core_js_1 = __webpack_require__(/*! ./core.js */ "./lib/core.js");
const component_js_1 = __webpack_require__(/*! ./component.js */ "./lib/component.js");
const fragment_js_1 = __webpack_require__(/*! ./fragment.js */ "./lib/fragment.js");
const helmet_js_1 = __webpack_require__(/*! ./components/helmet.js */ "./lib/components/helmet.js");
const withStyles = (...styles) => (WrappedComponent) => {
    return class extends component_js_1.Component {
        render() {
            const _a = this.props, { children } = _a, rest = __rest(_a, ["children"]);
            const helmets = [];
            styles.forEach(style => {
                var _a;
                if (typeof style === 'string') {
                    helmets.push((0, core_js_1.h)(helmet_js_1.Helmet, null, (0, core_js_1.h)('style', null, style)));
                }
                else if (typeof style === 'function') {
                    const _style = style();
                    if (typeof _style === 'string') {
                        helmets.push((0, core_js_1.h)(helmet_js_1.Helmet, null, (0, core_js_1.h)('style', null, _style)));
                    }
                }
                else if (typeof style === 'object') {
                    const _style = (_a = style.toString) === null || _a === void 0 ? void 0 : _a.call(style);
                    if (typeof _style === 'string') {
                        helmets.push((0, core_js_1.h)(helmet_js_1.Helmet, null, (0, core_js_1.h)('style', null, _style)));
                    }
                }
            });
            const component = children && children.length > 0
                ? (0, core_js_1.h)(WrappedComponent, Object.assign({}, rest), children)
                : (0, core_js_1.h)(WrappedComponent, Object.assign({}, this.props));
            return (0, core_js_1.h)(fragment_js_1.Fragment, null, ...helmets, component);
        }
    };
};
exports.withStyles = withStyles;
//# sourceMappingURL=withStyles.js.map

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __webpack_exports__ = __webpack_require__("./lib/bundles/bundle.full.js");
/******/ 	nanoJSX = __webpack_exports__["default"];
/******/ 	
/******/ })()
;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibmFuby5kZXYubWluLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsb0NBQW9DO0FBQ25EO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLDBDQUEwQyw0QkFBNEI7QUFDdEUsQ0FBQztBQUNEO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGVBQWUsR0FBRyxvQkFBb0I7QUFDdEM7QUFDQSxrQkFBa0IsbUJBQU8sQ0FBQyxpQ0FBWTtBQUN0QyxrQkFBa0IsbUJBQU8sQ0FBQyxpQ0FBWTtBQUN0QyxxQkFBcUIsbUJBQU8sQ0FBQyx1Q0FBZTtBQUM1QztBQUNBLHVCQUF1QixtQkFBTyxDQUFDLDJDQUFpQjtBQUNoRCxzQkFBc0IsbUJBQU8sQ0FBQyx5Q0FBZ0I7QUFDOUMsbUJBQW1CLG1CQUFPLENBQUMsbUNBQWE7QUFDeEMscUJBQXFCLG1CQUFPLENBQUMsdUNBQWU7QUFDNUMsd0JBQXdCLG1CQUFPLENBQUMsNkNBQWtCO0FBQ2xEO0FBQ0Esb0JBQW9CLG1CQUFPLENBQUMsMkRBQXlCO0FBQ3JELGtCQUFrQixtQkFBTyxDQUFDLHVEQUF1QjtBQUNqRCxpQkFBaUIsbUJBQU8sQ0FBQyxxREFBc0I7QUFDL0MscUJBQXFCLG1CQUFPLENBQUMsNkRBQTBCO0FBQ3ZELDRCQUE0QixtQkFBTyxDQUFDLDJEQUF5QjtBQUM3RDtBQUNBLGdDQUFnQyxtQkFBTyxDQUFDLDZEQUEwQjtBQUNsRTtBQUNBLGlCQUFpQixtQkFBTyxDQUFDLCtCQUFXO0FBQ3BDO0FBQ0Esd0JBQXdCLG1CQUFPLENBQUMseUNBQWdCO0FBQ2hELGtCQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixtQkFBTyxDQUFDLHVDQUFlO0FBQzFDLGdEQUErQyxFQUFFLHFDQUFxQyxxQ0FBcUMsRUFBQztBQUM1SCxtQkFBbUIsbUJBQU8sQ0FBQyx1Q0FBZTtBQUMxQywyQ0FBMEMsRUFBRSxxQ0FBcUMsZ0NBQWdDLEVBQUM7QUFDbEg7Ozs7Ozs7Ozs7QUM1RWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsaUJBQWlCO0FBQ2pCLHFCQUFxQixtQkFBTyxDQUFDLHNDQUFjO0FBQzNDLGtCQUFrQixtQkFBTyxDQUFDLGdDQUFXO0FBQ3JDLG1CQUFtQixtQkFBTyxDQUFDLGtDQUFZO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RDtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsR0FBRyxJQUFJO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCOzs7Ozs7Ozs7O0FDbklhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGNBQWM7QUFDZCx1QkFBdUIsbUJBQU8sQ0FBQywyQ0FBaUI7QUFDaEQsa0JBQWtCLG1CQUFPLENBQUMsaUNBQVk7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsSUFBSSxJQUFJLE1BQU07QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHFCQUFxQjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixrQ0FBa0M7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLHFCQUFxQjtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLGVBQWU7QUFDM0M7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLGdDQUFnQztBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCwrQ0FBK0M7QUFDL0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7Ozs7Ozs7Ozs7QUMzSWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTZELGNBQWM7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxXQUFXO0FBQ1gsdUJBQXVCLG1CQUFPLENBQUMsMkNBQWlCO0FBQ2hELGtCQUFrQixtQkFBTyxDQUFDLGlDQUFZO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixXQUFXO0FBQzNCO0FBQ0EscUJBQXFCLDhCQUE4QixHQUFHLGdEQUFnRDtBQUN0RztBQUNBLDhCQUE4QixJQUFJO0FBQ2xDO0FBQ0E7QUFDQSw0QkFBNEIsbUNBQW1DO0FBQy9EO0FBQ0E7QUFDQSxpQ0FBaUMsK0NBQStDO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtFQUErRTtBQUMvRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVMsSUFBSSxtQkFBbUI7QUFDaEM7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLG9EQUFvRDtBQUNyRjtBQUNBO0FBQ0EsdUVBQXVFLEtBQUs7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRCxrQkFBa0I7QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLFdBQVc7QUFDNUM7QUFDQSxrQ0FBa0MsWUFBWTtBQUM5QyxvQkFBb0IsZ0JBQWdCO0FBQ3BDLDJEQUEyRCxPQUFPO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDs7Ozs7Ozs7OztBQzFGYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQsY0FBYztBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELFlBQVk7QUFDWix1QkFBdUIsbUJBQU8sQ0FBQywyQ0FBaUI7QUFDaEQsb0JBQW9CLG1CQUFPLENBQUMsK0NBQWE7QUFDekMsa0JBQWtCLG1CQUFPLENBQUMsaUNBQVk7QUFDdEMsc0JBQXNCLG1CQUFPLENBQUMseUNBQWdCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUZBQW1GLFlBQVk7QUFDL0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTLElBQUksbUJBQW1CO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixrQkFBa0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdELHdEQUF3RDtBQUNoSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiwwQ0FBMEM7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLGdDQUFnQztBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdEO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCx3REFBd0Q7QUFDNUc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaOzs7Ozs7Ozs7O0FDckdhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTZELGNBQWM7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCwyQkFBMkIsR0FBRyxnQkFBZ0IsR0FBRyxZQUFZLEdBQUcsVUFBVSxHQUFHLGFBQWEsR0FBRyxjQUFjLEdBQUcsY0FBYyxHQUFHLGlCQUFpQjtBQUNoSix1QkFBdUIsbUJBQU8sQ0FBQywyQ0FBaUI7QUFDaEQsa0JBQWtCLG1CQUFPLENBQUMsaUNBQVk7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHVCQUF1QjtBQUNuQyxVQUFVLE9BQU87QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVELGFBQWEsY0FBYztBQUNsRjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLEtBQUs7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBLHdCQUF3QixnQ0FBZ0M7QUFDeEQ7QUFDQSxvQkFBb0IscUJBQXFCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixPQUFPO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZCxpQkFBaUIsdUJBQXVCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RCxrQkFBa0IsU0FBUyxpQ0FBaUM7QUFDcEgsS0FBSztBQUNMO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVSx3QkFBd0I7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsMENBQTBDO0FBQzNGO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxhQUFhLDRCQUE0QjtBQUM1RixLQUFLO0FBQ0w7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjs7Ozs7Ozs7OztBQ2hPYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxlQUFlO0FBQ2Ysa0JBQWtCLG1CQUFPLENBQUMsaUNBQVk7QUFDdEMsdUJBQXVCLG1CQUFPLENBQUMsMkNBQWlCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVMsSUFBSSxtQkFBbUI7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsNkNBQTZDO0FBQzFGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7Ozs7Ozs7Ozs7QUNsQ2E7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsa0JBQWtCLEdBQUcscUJBQXFCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EscUJBQXFCLHlFQUF5RSxZQUFZLGVBQWU7QUFDekgsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjs7Ozs7Ozs7OztBQzFCYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxTQUFTLEdBQUcsZUFBZSxHQUFHLGVBQWUsR0FBRyxjQUFjLEdBQUcsc0JBQXNCLEdBQUcsaUJBQWlCLEdBQUcsMkJBQTJCLEdBQUcsWUFBWSxHQUFHLGFBQWE7QUFDeEssbUJBQU8sQ0FBQyxrQ0FBWTtBQUNwQjtBQUNBLGFBQWE7QUFDYjtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixjQUFjO0FBQ2xDO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLFFBQVE7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2QsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixrQkFBa0I7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyw0QkFBNEI7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBLFlBQVksbUJBQW1CO0FBQy9CO0FBQ0E7QUFDQTtBQUNBLFlBQVksbUJBQW1CO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLG9CQUFvQjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLG9FQUFvRSxZQUFZLG9CQUFvQjtBQUNySDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixFQUFFLEdBQUcsWUFBWTtBQUM5Qyx3QkFBd0I7QUFDeEIsZ0RBQWdELG9CQUFvQjtBQUNwRSwwQkFBMEIsUUFBUTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7Ozs7Ozs7OztBQzVSYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCw4QkFBOEI7QUFDOUIsa0JBQWtCLG1CQUFPLENBQUMsZ0NBQVc7QUFDckMsNkZBQTZGO0FBQzdGO0FBQ0EsaURBQWlELGNBQWM7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsZ0RBQWdEO0FBQzNGLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSw4QkFBOEI7QUFDOUI7Ozs7Ozs7Ozs7QUM3RmE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjs7Ozs7Ozs7OztBQ1BhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELG9CQUFvQixHQUFHLGtCQUFrQixHQUFHLG9CQUFvQixHQUFHLGlCQUFpQixHQUFHLG9CQUFvQixHQUFHLFlBQVk7QUFDMUgscUJBQXFCLG1CQUFPLENBQUMsc0NBQWM7QUFDM0M7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQyxnQ0FBZ0M7QUFDaEMsZ0NBQWdDO0FBQ2hDLGtDQUFrQztBQUNsQyxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBLHlDQUF5QyxxQkFBcUI7QUFDOUQsa0NBQWtDLE1BQU0saUlBQWlJLG9CQUFvQjtBQUM3TDtBQUNBLG9CQUFvQjtBQUNwQjs7Ozs7Ozs7OztBQ2pFYTtBQUNiO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELG1DQUFtQyxtQkFBTyxDQUFDLDBDQUFnQjtBQUMzRCxrQkFBZTtBQUNmOzs7Ozs7Ozs7O0FDUGE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsYUFBYSxHQUFHLGdCQUFnQixHQUFHLGVBQWU7QUFDbEQsdUJBQXVCLG1CQUFPLENBQUMsOENBQWdCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsRUFBRSxPQUFPLEVBQUUsSUFBSSxHQUFHO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGdCQUFnQjtBQUMvQixtQkFBbUIsa0NBQWtDO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGtCQUFrQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsWUFBWSxXQUFXO0FBQ3ZCO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isa0JBQWtCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlEO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0Esc0NBQXNDLE1BQU07QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJEO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEM7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtEO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isb0JBQW9CO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qix1QkFBdUI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjs7Ozs7Ozs7OztBQ2pTYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxZQUFZO0FBQ1osWUFBWTtBQUNaOzs7Ozs7Ozs7O0FDSmE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsdUJBQXVCLG1CQUFPLENBQUMsOENBQWdCO0FBQy9DLG1CQUFtQixtQkFBTyxDQUFDLHNDQUFZO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBZTtBQUNmOzs7Ozs7Ozs7O0FDNUJhO0FBQ2I7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsV0FBVztBQUNYLGtCQUFrQixtQkFBTyxDQUFDLGdDQUFXO0FBQ3JDLGlDQUFpQyxtQkFBTyxDQUFDLDhCQUFVO0FBQ25EO0FBQ0EsV0FBVztBQUNYOzs7Ozs7Ozs7O0FDVmE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsbUJBQW1CO0FBQ25CLGtCQUFrQixtQkFBTyxDQUFDLGdDQUFXO0FBQ3JDLHFCQUFxQixtQkFBTyxDQUFDLDREQUF5QjtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjs7Ozs7Ozs7OztBQ1ZhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELG1CQUFtQixHQUFHLGNBQWM7QUFDcEM7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7Ozs7Ozs7Ozs7QUNWYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxhQUFhO0FBQ2Isa0JBQWtCLG1CQUFPLENBQUMsZ0NBQVc7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiOzs7Ozs7Ozs7O0FDL0VhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Q7Ozs7Ozs7Ozs7QUNOYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxjQUFjLEdBQUcsb0JBQW9CLEdBQUcsa0JBQWtCLEdBQUcsaUJBQWlCO0FBQzlFLGtCQUFrQixtQkFBTyxDQUFDLGlDQUFZO0FBQ3RDLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsK0NBQStDO0FBQ2pGO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyxZQUFZO0FBQ2pCLGtCQUFrQixVQUFVLDBDQUEwQyxVQUFVO0FBQ2hGO0FBQ0E7QUFDQSxLQUFLLFlBQVk7QUFDakIsa0JBQWtCLFVBQVUsMENBQTBDLFVBQVU7QUFDaEY7QUFDQTtBQUNBLEtBQUssWUFBWTtBQUNqQix3QkFBd0I7QUFDeEI7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCLGNBQWM7QUFDZCxtQkFBbUI7QUFDbkIsZ0JBQWdCO0FBQ2hCLGNBQWM7QUFDZCxxQkFBcUI7QUFDckIsY0FBYztBQUNkLGdCQUFnQjtBQUNoQixlQUFlO0FBQ2YsbUJBQW1CO0FBQ25CLGlCQUFpQjtBQUNqQjtBQUNBOzs7Ozs7Ozs7O0FDeERhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHVCQUF1QixHQUFHLG9CQUFvQjtBQUM5QyxrQkFBa0IsbUJBQU8sQ0FBQyxpQ0FBWTtBQUN0QztBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQSwwREFBMEQsS0FBSztBQUMvRDtBQUNBLHlEQUF5RCx1QkFBdUI7QUFDaEY7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCOzs7Ozs7Ozs7O0FDdkJhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGNBQWM7QUFDZCx1QkFBdUIsbUJBQU8sQ0FBQywyQ0FBaUI7QUFDaEQsa0JBQWtCLG1CQUFPLENBQUMsaUNBQVk7QUFDdEMscUJBQXFCLG1CQUFPLENBQUMseUNBQWM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsMENBQTBDO0FBQzFEO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEIsZUFBZTtBQUNmO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsb0NBQW9DLG9CQUFvQixHQUFHO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RDtBQUM5RDtBQUNBO0FBQ0EsbURBQW1ELFVBQVUsbUJBQW1CLEVBQUUsWUFBWSxHQUFHO0FBQ2pHO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDs7Ozs7Ozs7OztBQ3JJYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQsY0FBYztBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGNBQWM7QUFDZCxrQkFBa0IsbUJBQU8sQ0FBQyxpQ0FBWTtBQUN0QyxxQkFBcUIsbUJBQU8sQ0FBQyx5Q0FBYztBQUMzQyxzQkFBc0IsbUJBQU8sQ0FBQywyQ0FBZTtBQUM3QyxrQkFBa0IsbUJBQU8sQ0FBQyxtQ0FBVztBQUNyQztBQUNBLFlBQVksK0hBQStIO0FBQzNJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkIsZUFBZTtBQUNmLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMscUJBQXFCO0FBQ2hFLG1EQUFtRCx1QkFBdUIsaUJBQWlCO0FBQzNGO0FBQ0EsMkNBQTJDLEtBQUssT0FBTztBQUN2RDtBQUNBO0FBQ0Esc0RBQXNELDBCQUEwQixTQUFTLEVBQUUsY0FBYyxFQUFFLFVBQVUsd0JBQXdCLG1EQUFtRCwyQkFBMkIsbUJBQW1CLGFBQWEsYUFBYSxHQUFHO0FBQzNRO0FBQ0EsY0FBYztBQUNkOzs7Ozs7Ozs7O0FDbEVhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGNBQWM7QUFDZCxrQkFBa0IsbUJBQU8sQ0FBQyxpQ0FBWTtBQUN0QyxxQkFBcUIsbUJBQU8sQ0FBQyx5Q0FBYztBQUMzQyxvQkFBb0IsbUJBQU8sQ0FBQyx1Q0FBYTtBQUN6QztBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixrREFBa0Q7QUFDcEUsa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRDtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLFlBQVk7QUFDWixVQUFVO0FBQ1Y7QUFDQTtBQUNBLDhEQUE4RDtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRDtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0Msd0NBQXdDO0FBQ2hGO0FBQ0EsbUNBQW1DLGtDQUFrQztBQUNyRTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYixtREFBbUQsNENBQTRDO0FBQy9GLG1EQUFtRCxzQkFBc0I7QUFDekUsc0RBQXNELHlCQUF5QjtBQUMvRSxxREFBcUQsMEZBQTBGO0FBQy9JO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLG1CQUFtQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrRUFBa0U7QUFDbEU7QUFDQTtBQUNBLGNBQWM7QUFDZDs7Ozs7Ozs7OztBQ25PYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxXQUFXO0FBQ1gsdUJBQXVCLG1CQUFPLENBQUMsMkNBQWlCO0FBQ2hELGtCQUFrQixtQkFBTyxDQUFDLGlDQUFZO0FBQ3RDLHFCQUFxQixtQkFBTyxDQUFDLHlDQUFjO0FBQzNDLHNCQUFzQixtQkFBTyxDQUFDLDJDQUFlO0FBQzdDO0FBQ0E7QUFDQSxnQkFBZ0IsNkhBQTZIO0FBQzdJO0FBQ0E7QUFDQSwyQ0FBMkMsUUFBUTtBQUNuRDtBQUNBLFNBQVM7QUFDVCxVQUFVLG9CQUFvQixrQ0FBa0MsaUJBQWlCO0FBQ2pGLGtCQUFrQixPQUFPO0FBQ3pCO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkIsa0JBQWtCLGtEQUFrRDtBQUNwRSxVQUFVLG1CQUFtQixpQkFBaUI7QUFDOUMsVUFBVSxzQ0FBc0MsV0FBVztBQUMzRCxVQUFVO0FBQ1YsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixXQUFXO0FBQzNCLHlDQUF5Qyw4Q0FBOEM7QUFDdkY7QUFDQTtBQUNBLFdBQVc7QUFDWDs7Ozs7Ozs7OztBQ3hDYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQsY0FBYztBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELFlBQVk7QUFDWix1QkFBdUIsbUJBQU8sQ0FBQywyQ0FBaUI7QUFDaEQsa0JBQWtCLG1CQUFPLENBQUMsaUNBQVk7QUFDdEMsc0JBQXNCLG1CQUFPLENBQUMsMkNBQWU7QUFDN0M7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFLGFBQWE7QUFDOUU7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLCtEQUErRDtBQUNoRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLGVBQWUsS0FBSztBQUNwQixnQkFBZ0IsS0FBSztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRDtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0EsYUFBYSxhQUFhLGlCQUFpQjtBQUMzQywwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0EsMEdBQTBHLG9FQUFvRTtBQUM5SywrQ0FBK0MsZ0JBQWdCLHFCQUFxQixZQUFZLGdCQUFnQixvQkFBb0I7QUFDcEksaUNBQWlDLGFBQWE7QUFDOUM7QUFDQSwwQ0FBMEMsYUFBYTtBQUN2RCx5RUFBeUUsMEJBQTBCLFdBQVcsMEJBQTBCO0FBQ3hJO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjs7Ozs7Ozs7OztBQy9EYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxhQUFhLEdBQUcsV0FBVyxHQUFHLFlBQVksR0FBRyxnQkFBZ0IsR0FBRyxZQUFZLEdBQUcsZ0JBQWdCLEdBQUcsWUFBWSxHQUFHLFlBQVksR0FBRyxXQUFXLEdBQUcsY0FBYyxHQUFHLGNBQWMsR0FBRyx3QkFBd0IsR0FBRyxrQkFBa0IsR0FBRyxlQUFlLEdBQUcsY0FBYztBQUNoUSxrQkFBa0IsbUJBQU8sQ0FBQywyQ0FBaUI7QUFDM0MsMENBQXlDLEVBQUUscUNBQXFDLDhCQUE4QixFQUFDO0FBQy9HLG1CQUFtQixtQkFBTyxDQUFDLDZDQUFrQjtBQUM3QywyQ0FBMEMsRUFBRSxxQ0FBcUMsZ0NBQWdDLEVBQUM7QUFDbEgsc0JBQXNCLG1CQUFPLENBQUMsbURBQXFCO0FBQ25ELDhDQUE2QyxFQUFFLHFDQUFxQyxzQ0FBc0MsRUFBQztBQUMzSCxvREFBbUQsRUFBRSxxQ0FBcUMsNENBQTRDLEVBQUM7QUFDdkksa0JBQWtCLG1CQUFPLENBQUMsMkNBQWlCO0FBQzNDLDBDQUF5QyxFQUFFLHFDQUFxQyw4QkFBOEIsRUFBQztBQUMvRyxrQkFBa0IsbUJBQU8sQ0FBQywyQ0FBaUI7QUFDM0MsMENBQXlDLEVBQUUscUNBQXFDLDhCQUE4QixFQUFDO0FBQy9HLGVBQWUsbUJBQU8sQ0FBQyxxQ0FBYztBQUNyQyx1Q0FBc0MsRUFBRSxxQ0FBcUMsd0JBQXdCLEVBQUM7QUFDdEcsZ0JBQWdCLG1CQUFPLENBQUMsdUNBQWU7QUFDdkMsd0NBQXVDLEVBQUUscUNBQXFDLDBCQUEwQixFQUFDO0FBQ3pHLGdCQUFnQixtQkFBTyxDQUFDLHVDQUFlO0FBQ3ZDLHdDQUF1QyxFQUFFLHFDQUFxQywwQkFBMEIsRUFBQztBQUN6Ryw0Q0FBMkMsRUFBRSxxQ0FBcUMsOEJBQThCLEVBQUM7QUFDakgsZ0JBQWdCLG1CQUFPLENBQUMsdUNBQWU7QUFDdkMsd0NBQXVDLEVBQUUscUNBQXFDLDBCQUEwQixFQUFDO0FBQ3pHLG9CQUFvQixtQkFBTyxDQUFDLCtDQUFtQjtBQUMvQyw0Q0FBMkMsRUFBRSxxQ0FBcUMsa0NBQWtDLEVBQUM7QUFDckgsZ0JBQWdCLG1CQUFPLENBQUMsdUNBQWU7QUFDdkMsd0NBQXVDLEVBQUUscUNBQXFDLDBCQUEwQixFQUFDO0FBQ3pHLHVDQUFzQyxFQUFFLHFDQUFxQyx5QkFBeUIsRUFBQztBQUN2RyxpQkFBaUIsbUJBQU8sQ0FBQyx5Q0FBZ0I7QUFDekMseUNBQXdDLEVBQUUscUNBQXFDLDRCQUE0QixFQUFDO0FBQzVHOzs7Ozs7Ozs7O0FDOUJhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELFlBQVksR0FBRyxnQkFBZ0I7QUFDL0IsdUJBQXVCLG1CQUFPLENBQUMsMkNBQWlCO0FBQ2hELGtCQUFrQixtQkFBTyxDQUFDLGlDQUFZO0FBQ3RDLGtCQUFrQixtQkFBTyxDQUFDLG1DQUFXO0FBQ3JDLHNCQUFzQixtQkFBTyxDQUFDLDJDQUFlO0FBQzdDO0FBQ0E7QUFDQSxnQkFBZ0IsV0FBVztBQUMzQixnQkFBZ0Isc0JBQXNCO0FBQ3RDLG1EQUFtRDtBQUNuRCxpRUFBaUUscUNBQXFDLGdCQUFnQjtBQUN0SDtBQUNBLHdDQUF3QyxtRUFBbUUsRUFBRSxlQUFlLEdBQUc7QUFDL0g7QUFDQSw0REFBNEQsNkRBQTZEO0FBQ3pIO0FBQ0Esd0NBQXdDLGtFQUFrRSxtQkFBbUIsR0FBRztBQUNoSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0Esd0NBQXdDO0FBQ3hDLHdDQUF3QyxnQkFBZ0I7QUFDeEQ7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0EsZ0JBQWdCLGdCQUFnQjtBQUNoQyx1REFBdUQsaUJBQWlCO0FBQ3hFO0FBQ0EsY0FBYyxjQUFjO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxjQUFjO0FBQzVCO0FBQ0Esc0JBQXNCLGdCQUFnQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsY0FBYztBQUM1QjtBQUNBO0FBQ0E7QUFDQSxjQUFjLGNBQWM7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxlQUFlLGFBQWEsR0FBRztBQUN4RTtBQUNBO0FBQ0EsWUFBWTtBQUNaOzs7Ozs7Ozs7O0FDakVhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELFlBQVk7QUFDWixrQkFBa0IsbUJBQU8sQ0FBQyxpQ0FBWTtBQUN0QyxxQkFBcUIsbUJBQU8sQ0FBQyx5Q0FBYztBQUMzQyxzQkFBc0IsbUJBQU8sQ0FBQywyQ0FBZTtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrREFBK0QsYUFBYTtBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRCxxQkFBcUI7QUFDL0U7QUFDQTtBQUNBLFNBQVM7QUFDVCw0Q0FBNEMscUJBQXFCLEdBQUcsR0FBRztBQUN2RTtBQUNBO0FBQ0EsdUJBQXVCLHFCQUFxQixHQUFHLEdBQUc7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGlCQUFpQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsSUFBSSxJQUFJLG1GQUFtRjtBQUNuRyxRQUFRLEtBQUssSUFBSSxpRkFBaUY7QUFDbEc7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQsYUFBYTtBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCx1QkFBdUIsYUFBYSxHQUFHO0FBQzNGLGtEQUFrRCwwREFBMEQsYUFBYSxHQUFHO0FBQzVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaOzs7Ozs7Ozs7O0FDL0VhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGtCQUFrQixHQUFHLHdCQUF3QjtBQUM3QyxrQkFBa0IsbUJBQU8sQ0FBQyxpQ0FBWTtBQUN0Qyx1QkFBdUIsbUJBQU8sQ0FBQywyQ0FBaUI7QUFDaEQscUJBQXFCLG1CQUFPLENBQUMseUNBQWM7QUFDM0Msa0JBQWtCLG1CQUFPLENBQUMsbUNBQVc7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsc0JBQXNCO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixpQkFBaUIsRUFBRSxRQUFRO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvR0FBb0csb0ZBQW9GO0FBQ3hMO0FBQ0EsU0FBUyx1REFBdUQscUNBQXFDLHlCQUF5QjtBQUM5SDtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvRUFBb0UsaUJBQWlCO0FBQ3JGO0FBQ0EscUNBQXFDLGlCQUFpQixFQUFFLEtBQUs7QUFDN0Q7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQSw4REFBOEQ7QUFDOUQsZ0JBQWdCLHFCQUFxQjtBQUNyQyxxREFBcUQsbUNBQW1DO0FBQ3hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCOzs7Ozs7Ozs7O0FDdElhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGFBQWE7QUFDYix1QkFBdUIsbUJBQU8sQ0FBQywyQ0FBaUI7QUFDaEQsa0JBQWtCLG1CQUFPLENBQUMsaUNBQVk7QUFDdEMscUJBQXFCLG1CQUFPLENBQUMseUNBQWM7QUFDM0Msc0JBQXNCLG1CQUFPLENBQUMsMkNBQWU7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsbUNBQW1DO0FBQ25ELHlEQUF5RCxLQUFLO0FBQzlEO0FBQ0E7QUFDQTtBQUNBLHFFQUFxRTtBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxvQ0FBb0MsSUFBSTtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQSxnQ0FBZ0MsT0FBTyxHQUFHO0FBQzFDLGNBQWMsRUFBRSxPQUFPO0FBQ3ZCLFlBQVksRUFBRSxPQUFPO0FBQ3JCO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQSx1Q0FBdUMsT0FBTyxHQUFHO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZCxZQUFZO0FBQ1o7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLHVDQUF1QyxRQUFRO0FBQy9DO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxvREFBb0Qsc0JBQXNCLFFBQVEsR0FBRztBQUNyRix1REFBdUQseUJBQXlCLFFBQVEsR0FBRztBQUMzRjtBQUNBLDZDQUE2QyxzQkFBc0IsUUFBUSxHQUFHO0FBQzlFLGtEQUFrRCwwQkFBMEIsUUFBUSxHQUFHO0FBQ3ZGO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjs7Ozs7Ozs7OztBQ2pIYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxnQkFBZ0I7QUFDaEIsa0JBQWtCLG1CQUFPLENBQUMsaUNBQVk7QUFDdEMscUJBQXFCLG1CQUFPLENBQUMseUNBQWM7QUFDM0M7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixpREFBaUQ7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQ7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IscUJBQXFCO0FBQ3ZDO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2QsWUFBWTtBQUNaO0FBQ0E7QUFDQSw4REFBOEQ7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdEO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxnQkFBZ0I7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsd0NBQXdDO0FBQzdFO0FBQ0E7QUFDQSx1Q0FBdUMsa0NBQWtDO0FBQ3pFO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiLHNEQUFzRCwyQkFBMkI7QUFDakYsc0RBQXNELDJCQUEyQjtBQUNqRixvREFBb0QseUJBQXlCO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7Ozs7Ozs7Ozs7QUMxSWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsWUFBWSxHQUFHLFdBQVc7QUFDMUIsdUJBQXVCLG1CQUFPLENBQUMsMkNBQWlCO0FBQ2hELGtCQUFrQixtQkFBTyxDQUFDLGlDQUFZO0FBQ3RDLHFCQUFxQixtQkFBTyxDQUFDLHlDQUFjO0FBQzNDLHNCQUFzQixtQkFBTyxDQUFDLDJDQUFlO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLG1CQUFtQjtBQUNuRCxvREFBb0Q7QUFDcEQsb0NBQW9DLGdFQUFnRSxvQkFBb0IsR0FBRztBQUMzSDtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsbUJBQW1CO0FBQ3pELHVDQUF1QyxhQUFhO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULHdCQUF3Qix1QkFBdUI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsbUNBQW1DO0FBQ25EO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixRQUFRO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCLGtDQUFrQztBQUNsQywrQkFBK0I7QUFDL0I7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQixVQUFVLHFDQUFxQyw4QkFBOEI7QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CLFVBQVUsbUNBQW1DLG1CQUFtQjtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsU0FBUztBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0I7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixRQUFRO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZCxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0QsY0FBYyxjQUFjO0FBQ3BGO0FBQ0Esb0RBQW9ELGNBQWMsbURBQW1ELFFBQVEsYUFBYTtBQUMxSTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsOENBQThDLG9CQUFvQixRQUFRLEdBQUc7QUFDN0UsOENBQThDLG9CQUFvQixRQUFRLEdBQUc7QUFDN0Usb0RBQW9ELHlCQUF5QixRQUFRLEdBQUc7QUFDeEY7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaOzs7Ozs7Ozs7O0FDckxhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGVBQWU7QUFDZix1QkFBdUIsbUJBQU8sQ0FBQywyQ0FBaUI7QUFDaEQsa0JBQWtCLG1CQUFPLENBQUMsaUNBQVk7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0Q7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQ7QUFDOUQsZ0JBQWdCLHFDQUFxQyxTQUFTO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSw0QkFBNEIsbUNBQW1DO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0Esd0VBQXdFLGlDQUFpQztBQUN6RyxtRUFBbUUsd0JBQXdCO0FBQzNGLCtDQUErQyxxQkFBcUI7QUFDcEUsZ0RBQWdELHNCQUFzQjtBQUN0RSw4Q0FBOEMsb0JBQW9CO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjs7Ozs7Ozs7OztBQ2hJYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxlQUFlO0FBQ2Y7QUFDQSxlQUFlO0FBQ2Y7Ozs7Ozs7Ozs7QUNMYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQsY0FBYztBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGtCQUFrQjtBQUNsQixrQkFBa0IsbUJBQU8sQ0FBQyxnQ0FBVztBQUNyQyx1QkFBdUIsbUJBQU8sQ0FBQywwQ0FBZ0I7QUFDL0Msc0JBQXNCLG1CQUFPLENBQUMsd0NBQWU7QUFDN0Msb0JBQW9CLG1CQUFPLENBQUMsMERBQXdCO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxXQUFXO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLHFFQUFxRTtBQUNyRSxxRUFBcUU7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7Ozs7OztVQ2pEQTtVQUNBOztVQUVBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBOztVQUVBO1VBQ0E7O1VBRUE7VUFDQTtVQUNBOzs7O1VFdEJBO1VBQ0E7VUFDQTtVQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmFub0pTWC8uL2xpYi9idW5kbGVzL2J1bmRsZS5mdWxsLmpzIiwid2VicGFjazovL25hbm9KU1gvLi9saWIvY29tcG9uZW50LmpzIiwid2VicGFjazovL25hbm9KU1gvLi9saWIvY29tcG9uZW50cy9oZWxtZXQuanMiLCJ3ZWJwYWNrOi8vbmFub0pTWC8uL2xpYi9jb21wb25lbnRzL2ltZy5qcyIsIndlYnBhY2s6Ly9uYW5vSlNYLy4vbGliL2NvbXBvbmVudHMvbGluay5qcyIsIndlYnBhY2s6Ly9uYW5vSlNYLy4vbGliL2NvbXBvbmVudHMvcm91dGVyLmpzIiwid2VicGFjazovL25hbm9KU1gvLi9saWIvY29tcG9uZW50cy92aXNpYmxlLmpzIiwid2VicGFjazovL25hbm9KU1gvLi9saWIvY29udGV4dC5qcyIsIndlYnBhY2s6Ly9uYW5vSlNYLy4vbGliL2NvcmUuanMiLCJ3ZWJwYWNrOi8vbmFub0pTWC8uL2xpYi9jdXN0b21FbGVtZW50c01vZGUuanMiLCJ3ZWJwYWNrOi8vbmFub0pTWC8uL2xpYi9mcmFnbWVudC5qcyIsIndlYnBhY2s6Ly9uYW5vSlNYLy4vbGliL2hlbHBlcnMuanMiLCJ3ZWJwYWNrOi8vbmFub0pTWC8uL2xpYi9odG0uanMiLCJ3ZWJwYWNrOi8vbmFub0pTWC8uL2xpYi9odG0vYnVpbGQuanMiLCJ3ZWJwYWNrOi8vbmFub0pTWC8uL2xpYi9odG0vY29uc3RhbnRzLmpzIiwid2VicGFjazovL25hbm9KU1gvLi9saWIvaHRtL2luZGV4LmpzIiwid2VicGFjazovL25hbm9KU1gvLi9saWIvanN4LmpzIiwid2VicGFjazovL25hbm9KU1gvLi9saWIvbGF6eS5qcyIsIndlYnBhY2s6Ly9uYW5vSlNYLy4vbGliL3N0YXRlLmpzIiwid2VicGFjazovL25hbm9KU1gvLi9saWIvc3RvcmUuanMiLCJ3ZWJwYWNrOi8vbmFub0pTWC8uL2xpYi90eXBlcy5qcyIsIndlYnBhY2s6Ly9uYW5vSlNYLy4vbGliL3VpL19jb25maWcuanMiLCJ3ZWJwYWNrOi8vbmFub0pTWC8uL2xpYi91aS9faGVscGVycy5qcyIsIndlYnBhY2s6Ly9uYW5vSlNYLy4vbGliL3VpL2FwcEJhci5qcyIsIndlYnBhY2s6Ly9uYW5vSlNYLy4vbGliL3VpL2J1dHRvbi5qcyIsIndlYnBhY2s6Ly9uYW5vSlNYLy4vbGliL3VpL2RpYWxvZy5qcyIsIndlYnBhY2s6Ly9uYW5vSlNYLy4vbGliL3VpL2ZhYi5qcyIsIndlYnBhY2s6Ly9uYW5vSlNYLy4vbGliL3VpL2ljb24uanMiLCJ3ZWJwYWNrOi8vbmFub0pTWC8uL2xpYi91aS9pbmRleC5qcyIsIndlYnBhY2s6Ly9uYW5vSlNYLy4vbGliL3VpL2xpc3QuanMiLCJ3ZWJwYWNrOi8vbmFub0pTWC8uL2xpYi91aS9tZW51LmpzIiwid2VicGFjazovL25hbm9KU1gvLi9saWIvdWkvbmF2aWdhdGlvbi5qcyIsIndlYnBhY2s6Ly9uYW5vSlNYLy4vbGliL3VpL3NoZWV0LmpzIiwid2VicGFjazovL25hbm9KU1gvLi9saWIvdWkvc25hY2tiYXIuanMiLCJ3ZWJwYWNrOi8vbmFub0pTWC8uL2xpYi91aS90YWJzLmpzIiwid2VicGFjazovL25hbm9KU1gvLi9saWIvdWkvdG9vbGJhci5qcyIsIndlYnBhY2s6Ly9uYW5vSlNYLy4vbGliL3ZlcnNpb24uanMiLCJ3ZWJwYWNrOi8vbmFub0pTWC8uL2xpYi93aXRoU3R5bGVzLmpzIiwid2VicGFjazovL25hbm9KU1gvd2VicGFjay9ib290c3RyYXAiLCJ3ZWJwYWNrOi8vbmFub0pTWC93ZWJwYWNrL2JlZm9yZS1zdGFydHVwIiwid2VicGFjazovL25hbm9KU1gvd2VicGFjay9zdGFydHVwIiwid2VicGFjazovL25hbm9KU1gvd2VicGFjay9hZnRlci1zdGFydHVwIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xuICAgIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XG4gICAgICBkZXNjID0geyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX3NldE1vZHVsZURlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9fc2V0TW9kdWxlRGVmYXVsdCkgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgdikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBcImRlZmF1bHRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdiB9KTtcbn0pIDogZnVuY3Rpb24obywgdikge1xuICAgIG9bXCJkZWZhdWx0XCJdID0gdjtcbn0pO1xudmFyIF9faW1wb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyKSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKGsgIT09IFwiZGVmYXVsdFwiICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSBfX2NyZWF0ZUJpbmRpbmcocmVzdWx0LCBtb2QsIGspO1xuICAgIF9fc2V0TW9kdWxlRGVmYXVsdChyZXN1bHQsIG1vZCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlZFUlNJT04gPSBleHBvcnRzLnByaW50VmVyc2lvbiA9IHZvaWQgMDtcbi8vIGNvcmVcbmNvbnN0IGNvcmVfanNfMSA9IHJlcXVpcmUoXCIuLi9jb3JlLmpzXCIpO1xuY29uc3QgbGF6eV9qc18xID0gcmVxdWlyZShcIi4uL2xhenkuanNcIik7XG5jb25zdCBoZWxwZXJzX2pzXzEgPSByZXF1aXJlKFwiLi4vaGVscGVycy5qc1wiKTtcbi8vIHVzZWZ1bCB0b29sc1xuY29uc3QgY29tcG9uZW50X2pzXzEgPSByZXF1aXJlKFwiLi4vY29tcG9uZW50LmpzXCIpO1xuY29uc3QgZnJhZ21lbnRfanNfMSA9IHJlcXVpcmUoXCIuLi9mcmFnbWVudC5qc1wiKTtcbmNvbnN0IHN0b3JlX2pzXzEgPSByZXF1aXJlKFwiLi4vc3RvcmUuanNcIik7XG5jb25zdCBjb250ZXh0X2pzXzEgPSByZXF1aXJlKFwiLi4vY29udGV4dC5qc1wiKTtcbmNvbnN0IHdpdGhTdHlsZXNfanNfMSA9IHJlcXVpcmUoXCIuLi93aXRoU3R5bGVzLmpzXCIpO1xuLy8gYnVpbHQtaW4gY29tcG9uZW50c1xuY29uc3QgaGVsbWV0X2pzXzEgPSByZXF1aXJlKFwiLi4vY29tcG9uZW50cy9oZWxtZXQuanNcIik7XG5jb25zdCBsaW5rX2pzXzEgPSByZXF1aXJlKFwiLi4vY29tcG9uZW50cy9saW5rLmpzXCIpO1xuY29uc3QgaW1nX2pzXzEgPSByZXF1aXJlKFwiLi4vY29tcG9uZW50cy9pbWcuanNcIik7XG5jb25zdCB2aXNpYmxlX2pzXzEgPSByZXF1aXJlKFwiLi4vY29tcG9uZW50cy92aXNpYmxlLmpzXCIpO1xuY29uc3QgUm91dGVyID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuLi9jb21wb25lbnRzL3JvdXRlci5qc1wiKSk7XG4vLyBjdXN0b21FbGVtZW50XG5jb25zdCBjdXN0b21FbGVtZW50c01vZGVfanNfMSA9IHJlcXVpcmUoXCIuLi9jdXN0b21FbGVtZW50c01vZGUuanNcIik7XG4vLyB0YWdnZWQgdGVtcGxhdGVzXG5jb25zdCBqc3hfanNfMSA9IHJlcXVpcmUoXCIuLi9qc3guanNcIik7XG4vLyB1aVxuY29uc3QgVUkgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4uL3VpL2luZGV4LmpzXCIpKTtcbmV4cG9ydHMuZGVmYXVsdCA9IHtcbiAgICBDb21wb25lbnQ6IGNvbXBvbmVudF9qc18xLkNvbXBvbmVudCxcbiAgICBGcmFnbWVudDogZnJhZ21lbnRfanNfMS5GcmFnbWVudCxcbiAgICBIZWxtZXQ6IGhlbG1ldF9qc18xLkhlbG1ldCxcbiAgICBJbWc6IGltZ19qc18xLkltZyxcbiAgICBMaW5rOiBsaW5rX2pzXzEuTGluayxcbiAgICBSb3V0ZXIsXG4gICAgU3RvcmU6IHN0b3JlX2pzXzEuU3RvcmUsXG4gICAgVUksXG4gICAgVmlzaWJsZTogdmlzaWJsZV9qc18xLlZpc2libGUsXG4gICAgY3JlYXRlQ29udGV4dDogY29udGV4dF9qc18xLmNyZWF0ZUNvbnRleHQsXG4gICAgaDogY29yZV9qc18xLmgsXG4gICAgaHlkcmF0ZTogY29yZV9qc18xLmh5ZHJhdGUsXG4gICAgaHlkcmF0ZUxhenk6IGxhenlfanNfMS5oeWRyYXRlTGF6eSxcbiAgICBqc3g6IGpzeF9qc18xLmpzeCxcbiAgICBub2RlVG9TdHJpbmc6IGhlbHBlcnNfanNfMS5ub2RlVG9TdHJpbmcsXG4gICAgcmVtb3ZlQWxsQ2hpbGROb2RlczogY29yZV9qc18xLnJlbW92ZUFsbENoaWxkTm9kZXMsXG4gICAgcmVuZGVyOiBjb3JlX2pzXzEucmVuZGVyLFxuICAgIHRhc2s6IGhlbHBlcnNfanNfMS50YXNrLFxuICAgIHRpY2s6IGNvcmVfanNfMS50aWNrLFxuICAgIHdpdGhTdHlsZXM6IHdpdGhTdHlsZXNfanNfMS53aXRoU3R5bGVzLFxuICAgIGRlZmluZUFzQ3VzdG9tRWxlbWVudHM6IGN1c3RvbUVsZW1lbnRzTW9kZV9qc18xLmRlZmluZUFzQ3VzdG9tRWxlbWVudHNcbn07XG4vLyB2ZXJzaW9uXG52YXIgaGVscGVyc19qc18yID0gcmVxdWlyZShcIi4uL2hlbHBlcnMuanNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJwcmludFZlcnNpb25cIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGhlbHBlcnNfanNfMi5wcmludFZlcnNpb247IH0gfSk7XG52YXIgdmVyc2lvbl9qc18xID0gcmVxdWlyZShcIi4uL3ZlcnNpb24uanNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJWRVJTSU9OXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB2ZXJzaW9uX2pzXzEuVkVSU0lPTjsgfSB9KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJ1bmRsZS5mdWxsLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Db21wb25lbnQgPSB2b2lkIDA7XG5jb25zdCBoZWxwZXJzX2pzXzEgPSByZXF1aXJlKFwiLi9oZWxwZXJzLmpzXCIpO1xuY29uc3QgY29yZV9qc18xID0gcmVxdWlyZShcIi4vY29yZS5qc1wiKTtcbmNvbnN0IHN0YXRlX2pzXzEgPSByZXF1aXJlKFwiLi9zdGF0ZS5qc1wiKTtcbmNsYXNzIENvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IocHJvcHMpIHtcbiAgICAgICAgdGhpcy5fZWxlbWVudHMgPSBbXTtcbiAgICAgICAgdGhpcy5fc2tpcFVubW91bnQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5faGFzVW5tb3VudGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMucHJvcHMgPSBwcm9wcyB8fCB7fTtcbiAgICAgICAgdGhpcy5pZCA9IHRoaXMuX2dldEhhc2goKTtcbiAgICB9XG4gICAgc3RhdGljIGdldCBpc0NsYXNzKCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgZ2V0IGlzQ2xhc3MoKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBzZXRTdGF0ZShzdGF0ZSwgc2hvdWxkVXBkYXRlID0gZmFsc2UpIHtcbiAgICAgICAgY29uc3QgaXNPYmplY3QgPSB0eXBlb2Ygc3RhdGUgPT09ICdvYmplY3QnICYmIHN0YXRlICE9PSBudWxsO1xuICAgICAgICAvLyBpZiBzdGF0ZSBpcyBhbiBvYmplY3QsIHdlIG1lcmdlIHRoZSBvYmplY3RzXG4gICAgICAgIGlmIChpc09iamVjdCAmJiB0aGlzLnN0YXRlICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLnN0YXRlKSwgc3RhdGUpO1xuICAgICAgICAvLyBlbHNlLCB3ZSBqdXN0IG92ZXJ3cml0ZSBpdFxuICAgICAgICBlbHNlXG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gc3RhdGU7XG4gICAgICAgIGlmIChzaG91bGRVcGRhdGUpXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZSgpO1xuICAgIH1cbiAgICBzZXQgc3RhdGUoc3RhdGUpIHtcbiAgICAgICAgc3RhdGVfanNfMS5fc3RhdGUuc2V0KHRoaXMuaWQsIHN0YXRlKTtcbiAgICB9XG4gICAgZ2V0IHN0YXRlKCkge1xuICAgICAgICByZXR1cm4gc3RhdGVfanNfMS5fc3RhdGUuZ2V0KHRoaXMuaWQpO1xuICAgIH1cbiAgICBzZXQgaW5pdFN0YXRlKHN0YXRlKSB7XG4gICAgICAgIGlmICh0aGlzLnN0YXRlID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gc3RhdGU7XG4gICAgfVxuICAgIC8qKiBSZXR1cm5zIGFsbCBjdXJyZW50bHkgcmVuZGVyZWQgbm9kZSBlbGVtZW50cyAqL1xuICAgIGdldCBlbGVtZW50cygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2VsZW1lbnRzIHx8IFtdO1xuICAgIH1cbiAgICBzZXQgZWxlbWVudHMoZWxlbWVudHMpIHtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGVsZW1lbnRzKSlcbiAgICAgICAgICAgIGVsZW1lbnRzID0gW2VsZW1lbnRzXTtcbiAgICAgICAgZWxlbWVudHMuZm9yRWFjaChlbGVtZW50ID0+IHtcbiAgICAgICAgICAgIHRoaXMuX2VsZW1lbnRzLnB1c2goZWxlbWVudCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBfYWRkTm9kZVJlbW92ZUxpc3RlbmVyKCkge1xuICAgICAgICAvLyBjaGVjayBpZiBkaWRVbm1vdW50IGlzIHVudXNlZFxuICAgICAgICBpZiAoL15bXntdK3tcXHMrfSQvZ20udGVzdCh0aGlzLmRpZFVubW91bnQudG9TdHJpbmcoKSkpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIC8vIGxpc3RlbiBpZiB0aGUgcm9vdCBlbGVtZW50cyBnZXRzIHJlbW92ZWRcbiAgICAgICAgKDAsIGhlbHBlcnNfanNfMS5vbk5vZGVSZW1vdmUpKHRoaXMuZWxlbWVudHNbMF0sICgpID0+IHtcbiAgICAgICAgICAgIGlmICghdGhpcy5fc2tpcFVubW91bnQpXG4gICAgICAgICAgICAgICAgdGhpcy5fZGlkVW5tb3VudCgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIF9kaWRNb3VudCgpIHtcbiAgICAgICAgdGhpcy5fYWRkTm9kZVJlbW92ZUxpc3RlbmVyKCk7XG4gICAgICAgIHRoaXMuZGlkTW91bnQoKTtcbiAgICB9XG4gICAgX3dpbGxVcGRhdGUoKSB7XG4gICAgICAgIHRoaXMud2lsbFVwZGF0ZSgpO1xuICAgIH1cbiAgICBfZGlkVXBkYXRlKCkge1xuICAgICAgICB0aGlzLmRpZFVwZGF0ZSgpO1xuICAgIH1cbiAgICBfZGlkVW5tb3VudCgpIHtcbiAgICAgICAgaWYgKHRoaXMuX2hhc1VubW91bnRlZClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdGhpcy5kaWRVbm1vdW50KCk7XG4gICAgICAgIHRoaXMuX2hhc1VubW91bnRlZCA9IHRydWU7XG4gICAgfVxuICAgIHdpbGxNb3VudCgpIHsgfVxuICAgIGRpZE1vdW50KCkgeyB9XG4gICAgd2lsbFVwZGF0ZSgpIHsgfVxuICAgIGRpZFVwZGF0ZSgpIHsgfVxuICAgIGRpZFVubW91bnQoKSB7IH1cbiAgICByZW5kZXIoX3VwZGF0ZSkgeyB9XG4gICAgLyoqIFdpbGwgZm9yY2VSZW5kZXIgdGhlIGNvbXBvbmVudCAqL1xuICAgIHVwZGF0ZSh1cGRhdGUpIHtcbiAgICAgICAgdGhpcy5fc2tpcFVubW91bnQgPSB0cnVlO1xuICAgICAgICB0aGlzLl93aWxsVXBkYXRlKCk7XG4gICAgICAgIC8vIGdldCBhbGwgY3VycmVudCByZW5kZXJlZCBub2RlIGVsZW1lbnRzXG4gICAgICAgIGNvbnN0IG9sZEVsZW1lbnRzID0gWy4uLnRoaXMuZWxlbWVudHNdO1xuICAgICAgICAvLyBjbGVhclxuICAgICAgICB0aGlzLl9lbGVtZW50cyA9IFtdO1xuICAgICAgICBsZXQgZWwgPSB0aGlzLnJlbmRlcih1cGRhdGUpO1xuICAgICAgICBlbCA9ICgwLCBjb3JlX2pzXzEuX3JlbmRlcikoZWwpO1xuICAgICAgICB0aGlzLmVsZW1lbnRzID0gZWw7XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCdvbGQ6ICcsIG9sZEVsZW1lbnRzKVxuICAgICAgICAvLyBjb25zb2xlLmxvZygnbmV3OiAnLCB0aGlzLmVsZW1lbnRzKVxuICAgICAgICAvLyBnZXQgdmFsaWQgcGFyZW50IG5vZGVcbiAgICAgICAgY29uc3QgcGFyZW50ID0gb2xkRWxlbWVudHNbMF0ucGFyZW50RWxlbWVudDtcbiAgICAgICAgLy8gbWFrZSBzdXJlIHdlIGhhdmUgYSBwYXJlbnRcbiAgICAgICAgaWYgKCFwYXJlbnQpXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ0NvbXBvbmVudCBuZWVkcyBhIHBhcmVudCBlbGVtZW50IHRvIGdldCB1cGRhdGVkIScpO1xuICAgICAgICAvLyBhZGQgYWxsIG5ldyBub2RlIGVsZW1lbnRzXG4gICAgICAgIHRoaXMuZWxlbWVudHMuZm9yRWFjaCgoY2hpbGQpID0+IHtcbiAgICAgICAgICAgIGlmIChwYXJlbnQpXG4gICAgICAgICAgICAgICAgcGFyZW50Lmluc2VydEJlZm9yZShjaGlsZCwgb2xkRWxlbWVudHNbMF0pO1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gcmVtb3ZlIGFsbCBlbGVtZW50c1xuICAgICAgICBvbGRFbGVtZW50cy5mb3JFYWNoKChjaGlsZCkgPT4ge1xuICAgICAgICAgICAgLy8gd2VlIGtlZXAgdGhlIGVsZW1lbnQgaWYgaXQgaXMgdGhlIHNhbWUsIGZvciBleGFtcGxlIGlmIHBhc3NlZCBhcyBhIGNoaWxkXG4gICAgICAgICAgICBpZiAoIXRoaXMuZWxlbWVudHMuaW5jbHVkZXMoY2hpbGQpKSB7XG4gICAgICAgICAgICAgICAgY2hpbGQucmVtb3ZlKCk7XG4gICAgICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgICAgIGNoaWxkID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIC8vIGxpc3RlbiBmb3Igbm9kZSByZW1vdmFsXG4gICAgICAgIHRoaXMuX2FkZE5vZGVSZW1vdmVMaXN0ZW5lcigpO1xuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICgwLCBjb3JlX2pzXzEudGljaykoKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5fc2tpcFVubW91bnQgPSBmYWxzZTtcbiAgICAgICAgICAgIGlmICghdGhpcy5lbGVtZW50c1swXS5pc0Nvbm5lY3RlZClcbiAgICAgICAgICAgICAgICB0aGlzLl9kaWRVbm1vdW50KCk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgdGhpcy5fZGlkVXBkYXRlKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBfZ2V0SGFzaCgpIHsgfVxufVxuZXhwb3J0cy5Db21wb25lbnQgPSBDb21wb25lbnQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb21wb25lbnQuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkhlbG1ldCA9IHZvaWQgMDtcbmNvbnN0IGNvbXBvbmVudF9qc18xID0gcmVxdWlyZShcIi4uL2NvbXBvbmVudC5qc1wiKTtcbmNvbnN0IGNvcmVfanNfMSA9IHJlcXVpcmUoXCIuLi9jb3JlLmpzXCIpO1xuY2xhc3MgQXR0cmlidXRlcyBleHRlbmRzIE1hcCB7XG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIGxldCBzdHJpbmcgPSAnJztcbiAgICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgdGhpcylcbiAgICAgICAgICAgIHN0cmluZyArPSBgICR7a2V5fT1cIiR7dmFsdWV9XCJgO1xuICAgICAgICByZXR1cm4gc3RyaW5nLnRyaW0oKTtcbiAgICB9XG59XG5jbGFzcyBIZWxtZXQgZXh0ZW5kcyBjb21wb25lbnRfanNfMS5Db21wb25lbnQge1xuICAgIHN0YXRpYyBTU1IoYm9keSkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBjb25zdCByZWcgPSAvKDxoZWxtZXRcXGJbXj5dKj4pKCgufFxccnxcXG4pKj8pKDxcXC9oZWxtZXQ+KS9nbTtcbiAgICAgICAgLy8gY29sbGVjdCBhbGwgZWxlbWVudHNcbiAgICAgICAgY29uc3QgaGVhZCA9IFtdO1xuICAgICAgICBjb25zdCBmb290ZXIgPSBbXTtcbiAgICAgICAgY29uc3QgYXR0cmlidXRlcyA9IHtcbiAgICAgICAgICAgIGh0bWw6IG5ldyBBdHRyaWJ1dGVzKCksXG4gICAgICAgICAgICBib2R5OiBuZXcgQXR0cmlidXRlcygpXG4gICAgICAgIH07XG4gICAgICAgIC8vIGdldCB3aGF0J3MgaW4gdGhlIGhlYWRcbiAgICAgICAgaWYgKHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgZG9jdW1lbnQuaGVhZCkge1xuICAgICAgICAgICAgbGV0IGNoaWxkcmVuID0gW107XG4gICAgICAgICAgICBjaGlsZHJlbiA9IFtdLnNsaWNlLmNhbGwoZG9jdW1lbnQuaGVhZC5jaGlsZHJlbik7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgLy8gY2hlY2sgaWYgdGhlIHNhbWUgZWxlbWVudCBhbHJlYWR5IGV4aXN0c1xuICAgICAgICAgICAgICAgIGlmIChoZWFkLmluZGV4T2YoY2hpbGRyZW5baV0pID09PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICBoZWFkLnB1c2goY2hpbGRyZW5baV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgcmVzdWx0O1xuICAgICAgICB3aGlsZSAoKHJlc3VsdCA9IHJlZy5leGVjKGJvZHkpKSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgY29uc3QgZmlyc3QgPSByZXN1bHRbMV07XG4gICAgICAgICAgICBsZXQgc2Vjb25kID0gcmVzdWx0WzJdO1xuICAgICAgICAgICAgY29uc3QgcmVnSFRNTCA9IC88aHRtbFxccyhbXj5dKyk+PFxcL2h0bWw+L2dtO1xuICAgICAgICAgICAgY29uc3QgcmVnQm9keSA9IC88Ym9keVxccyhbXj5dKyk+PFxcL2JvZHk+L2dtO1xuICAgICAgICAgICAgY29uc3QgcmVnQXR0ciA9IC8oXFx3Kyk9XCIoW15cIl0rKVwiL2dtO1xuICAgICAgICAgICAgbGV0IHJlcyA9IG51bGw7XG4gICAgICAgICAgICAvLyBleHRyYWN0IGh0bWwgYXR0cmlidXRlc1xuICAgICAgICAgICAgKF9hID0gYm9keS5tYXRjaChyZWdIVE1MKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmZvckVhY2goaCA9PiB7XG4gICAgICAgICAgICAgICAgc2Vjb25kID0gc2Vjb25kLnJlcGxhY2UoaCwgJycpO1xuICAgICAgICAgICAgICAgIHdoaWxlICgocmVzID0gcmVnQXR0ci5leGVjKGgpKSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzLmh0bWwuc2V0KHJlc1sxXSwgcmVzWzJdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIGV4dHJhY3QgYm9keSBhdHRyaWJ1dGVzXG4gICAgICAgICAgICAoX2IgPSBib2R5Lm1hdGNoKHJlZ0JvZHkpKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuZm9yRWFjaChiID0+IHtcbiAgICAgICAgICAgICAgICBzZWNvbmQgPSBzZWNvbmQucmVwbGFjZShiLCAnJyk7XG4gICAgICAgICAgICAgICAgd2hpbGUgKChyZXMgPSByZWdBdHRyLmV4ZWMoYikpICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXMuYm9keS5zZXQocmVzWzFdLCByZXNbMl0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgdG9IZWFkID0gZmlyc3QuaW5jbHVkZXMoJ2RhdGEtcGxhY2VtZW50PVwiaGVhZFwiJyk7XG4gICAgICAgICAgICAvLyBkbyBub3QgYWRkIGFuIGVsZW1lbnQgaWYgaXQgYWxyZWFkeSBleGlzdHNcbiAgICAgICAgICAgIGlmICh0b0hlYWQgJiYgIWhlYWQuaW5jbHVkZXMoc2Vjb25kKSlcbiAgICAgICAgICAgICAgICBoZWFkLnB1c2goc2Vjb25kKTtcbiAgICAgICAgICAgIGVsc2UgaWYgKCF0b0hlYWQgJiYgIWZvb3Rlci5pbmNsdWRlcyhzZWNvbmQpKVxuICAgICAgICAgICAgICAgIGZvb3Rlci5wdXNoKHNlY29uZCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gY2xlYW4gdGhlIGJvZHkgZnJvbSBhbGwgbWF0Y2hlc1xuICAgICAgICBjb25zdCBjbGVhbkJvZHkgPSBib2R5LnJlcGxhY2UocmVnLCAnJyk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBib2R5OiBjbGVhbkJvZHksXG4gICAgICAgICAgICBoZWFkOiBoZWFkLFxuICAgICAgICAgICAgZm9vdGVyOiBmb290ZXIsXG4gICAgICAgICAgICBhdHRyaWJ1dGVzXG4gICAgICAgIH07XG4gICAgfVxuICAgIGRpZE1vdW50KCkge1xuICAgICAgICB0aGlzLnByb3BzLmNoaWxkcmVuLmZvckVhY2goKGVsZW1lbnQpID0+IHtcbiAgICAgICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgICAgICAgICAgIC8vIHJldHVybiBpZiBpdCBpcyBub3QgYW4gaHRtbCBlbGVtZW50XG4gICAgICAgICAgICBpZiAoIShlbGVtZW50IGluc3RhbmNlb2YgSFRNTEVsZW1lbnQpKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGNvbnN0IHBhcmVudCA9IHRoaXMucHJvcHMuZm9vdGVyID8gZG9jdW1lbnQuYm9keSA6IGRvY3VtZW50LmhlYWQ7XG4gICAgICAgICAgICBjb25zdCB0YWcgPSBlbGVtZW50LnRhZ05hbWU7XG4gICAgICAgICAgICBsZXQgYXR0cnMgPSBbXTtcbiAgICAgICAgICAgIC8vIGdldCB0aGUgaW5uZXIgdGV4dFxuICAgICAgICAgICAgYXR0cnMucHVzaChlbGVtZW50LmlubmVyVGV4dCk7XG4gICAgICAgICAgICAvLyBnZXQgYWxsIGF0dHJpYnV0ZXNcbiAgICAgICAgICAgIGZvciAobGV0IGF0dHIgPSAwOyBhdHRyIDwgZWxlbWVudC5hdHRyaWJ1dGVzLmxlbmd0aDsgYXR0cisrKSB7XG4gICAgICAgICAgICAgICAgYXR0cnMucHVzaCgoX2EgPSBlbGVtZW50LmF0dHJpYnV0ZXMuaXRlbShhdHRyKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm5hbWUudG9Mb3dlckNhc2UoKSk7XG4gICAgICAgICAgICAgICAgYXR0cnMucHVzaCgoX2IgPSBlbGVtZW50LmF0dHJpYnV0ZXMuaXRlbShhdHRyKSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnZhbHVlLnRvTG93ZXJDYXNlKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gaGFuZGxlIHNwZWNpYWwgdGFnc1xuICAgICAgICAgICAgaWYgKHRhZyA9PT0gJ0hUTUwnIHx8IHRhZyA9PT0gJ0JPRFknKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaHRtbFRhZyA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKHRhZylbMF07XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgYXR0ciA9IDE7IGF0dHIgPCBhdHRycy5sZW5ndGg7IGF0dHIgKz0gMikge1xuICAgICAgICAgICAgICAgICAgICBodG1sVGFnLnNldEF0dHJpYnV0ZShhdHRyc1thdHRyXSwgYXR0cnNbYXR0ciArIDFdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGFnID09PSAnVElUTEUnKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdGl0bGVUYWdzID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ1RJVExFJyk7XG4gICAgICAgICAgICAgICAgaWYgKHRpdGxlVGFncy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGUgPSBlbGVtZW50O1xuICAgICAgICAgICAgICAgICAgICB0aXRsZVRhZ3NbMF0udGV4dCA9IGUudGV4dDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRpdGxlVGFnID0gKDAsIGNvcmVfanNfMS5oKSgndGl0bGUnLCBudWxsLCBlbGVtZW50LmlubmVySFRNTCk7XG4gICAgICAgICAgICAgICAgICAgICgwLCBjb3JlX2pzXzEuYXBwZW5kQ2hpbGRyZW4pKHBhcmVudCwgW3RpdGxlVGFnXSwgZmFsc2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBjaGVjayBpZiB0aGUgZWxlbWVudCBhbHJlYWR5IGV4aXN0c1xuICAgICAgICAgICAgbGV0IGV4aXN0cyA9IGZhbHNlO1xuICAgICAgICAgICAgYXR0cnMgPSBhdHRycy5zb3J0KCk7XG4gICAgICAgICAgICBjb25zdCBlbCA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKHRhZyk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGVsLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbGV0IGF0dHJzMiA9IFtdO1xuICAgICAgICAgICAgICAgIC8vIGdldCB0aGUgaW5uZXIgdGV4dFxuICAgICAgICAgICAgICAgIGF0dHJzMi5wdXNoKGVsW2ldLmlubmVyVGV4dCk7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgYXR0ciA9IDA7IGF0dHIgPCBlbFtpXS5hdHRyaWJ1dGVzLmxlbmd0aDsgYXR0cisrKSB7XG4gICAgICAgICAgICAgICAgICAgIGF0dHJzMi5wdXNoKChfYyA9IGVsW2ldLmF0dHJpYnV0ZXMuaXRlbShhdHRyKSkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLm5hbWUudG9Mb3dlckNhc2UoKSk7XG4gICAgICAgICAgICAgICAgICAgIGF0dHJzMi5wdXNoKChfZCA9IGVsW2ldLmF0dHJpYnV0ZXMuaXRlbShhdHRyKSkgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLnZhbHVlLnRvTG93ZXJDYXNlKCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBhdHRyczIgPSBhdHRyczIuc29ydCgpO1xuICAgICAgICAgICAgICAgIGlmIChhdHRycy5sZW5ndGggPiAwICYmIGF0dHJzMi5sZW5ndGggPiAwICYmIEpTT04uc3RyaW5naWZ5KGF0dHJzKSA9PT0gSlNPTi5zdHJpbmdpZnkoYXR0cnMyKSlcbiAgICAgICAgICAgICAgICAgICAgZXhpc3RzID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGFkZCB0byBkb21cbiAgICAgICAgICAgIGlmICghZXhpc3RzKVxuICAgICAgICAgICAgICAgICgwLCBjb3JlX2pzXzEuYXBwZW5kQ2hpbGRyZW4pKHBhcmVudCwgW2VsZW1lbnRdLCBmYWxzZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIGNvbnN0IHBsYWNlbWVudCA9IHRoaXMucHJvcHMuZm9vdGVyID8gJ2Zvb3RlcicgOiAnaGVhZCc7XG4gICAgICAgIGlmICgoMCwgY29yZV9qc18xLmlzU1NSKSgpKVxuICAgICAgICAgICAgcmV0dXJuICgwLCBjb3JlX2pzXzEuaCkoJ2hlbG1ldCcsIHsgJ2RhdGEtc3NyJzogdHJ1ZSwgJ2RhdGEtcGxhY2VtZW50JzogcGxhY2VtZW50IH0sIHRoaXMucHJvcHMuY2hpbGRyZW4pO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgfVxufVxuZXhwb3J0cy5IZWxtZXQgPSBIZWxtZXQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1oZWxtZXQuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19yZXN0ID0gKHRoaXMgJiYgdGhpcy5fX3Jlc3QpIHx8IGZ1bmN0aW9uIChzLCBlKSB7XG4gICAgdmFyIHQgPSB7fTtcbiAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkgJiYgZS5pbmRleE9mKHApIDwgMClcbiAgICAgICAgdFtwXSA9IHNbcF07XG4gICAgaWYgKHMgIT0gbnVsbCAmJiB0eXBlb2YgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyA9PT0gXCJmdW5jdGlvblwiKVxuICAgICAgICBmb3IgKHZhciBpID0gMCwgcCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMocyk7IGkgPCBwLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoZS5pbmRleE9mKHBbaV0pIDwgMCAmJiBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwocywgcFtpXSkpXG4gICAgICAgICAgICAgICAgdFtwW2ldXSA9IHNbcFtpXV07XG4gICAgICAgIH1cbiAgICByZXR1cm4gdDtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkltZyA9IHZvaWQgMDtcbmNvbnN0IGNvbXBvbmVudF9qc18xID0gcmVxdWlyZShcIi4uL2NvbXBvbmVudC5qc1wiKTtcbmNvbnN0IGNvcmVfanNfMSA9IHJlcXVpcmUoXCIuLi9jb3JlLmpzXCIpO1xuLyoqXG4gKiBBIHVzZWZ1bCBJbWFnZSBjb21wb25lbnRcbiAqIEFkZCA8SW1nIGxhenkgLi4uLCB0byBsYXp5IGxvYWQgdGhlIGltZyBzb3VyY2VcbiAqIEFkZCA8SW1nIHdpZHRoPVwiMTAwXCIgaGVpZ2h0PVwiMTAwXCIgLi4uLCB0byBzcGVjaWZ5IGltZyBlbGVtZW50J3Mgc2l6ZS5cbiAqIEFkZCA8SW1nIHBsYWNlaG9sZGVyPVwic3JjIG9yIGVsZW1lbnRcIiAuLi4uLCB0byBwcmVwYXJlIHBsYWNlaG9sZGVyIGZvciBpbWcuXG4gKi9cbmNsYXNzIEltZyBleHRlbmRzIGNvbXBvbmVudF9qc18xLkNvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IocHJvcHMpIHtcbiAgICAgICAgc3VwZXIocHJvcHMpO1xuICAgICAgICBjb25zdCB7IHNyYywga2V5IH0gPSBwcm9wcztcbiAgICAgICAgLy8gaWQgaGFzIHRvIGJlIHVuaXF1ZVxuICAgICAgICB0aGlzLmlkID0gYCR7KDAsIGNvcmVfanNfMS5zdHJUb0hhc2gpKHNyYyl9LSR7KDAsIGNvcmVfanNfMS5zdHJUb0hhc2gpKEpTT04uc3RyaW5naWZ5KHByb3BzKSl9YDtcbiAgICAgICAgaWYgKGtleSlcbiAgICAgICAgICAgIHRoaXMuaWQgKz0gYGtleS0ke2tleX1gO1xuICAgICAgICAvLyB0aGlzIGNvdWxkIGFsc28gYmUgZG9uZSBpbiB3aWxsTW91bnQoKVxuICAgICAgICBpZiAoIXRoaXMuc3RhdGUpXG4gICAgICAgICAgICB0aGlzLnNldFN0YXRlKHsgaXNMb2FkZWQ6IGZhbHNlLCBpbWFnZTogdW5kZWZpbmVkIH0pO1xuICAgIH1cbiAgICBkaWRNb3VudCgpIHtcbiAgICAgICAgY29uc3QgX2EgPSB0aGlzLnByb3BzLCB7IGxhenkgPSB0cnVlLCBwbGFjZWhvbGRlciwgY2hpbGRyZW4sIGtleSwgcmVmIH0gPSBfYSwgcmVzdCA9IF9fcmVzdChfYSwgW1wibGF6eVwiLCBcInBsYWNlaG9sZGVyXCIsIFwiY2hpbGRyZW5cIiwgXCJrZXlcIiwgXCJyZWZcIl0pO1xuICAgICAgICBpZiAodHlwZW9mIGxhenkgPT09ICdib29sZWFuJyAmJiBsYXp5ID09PSBmYWxzZSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc3Qgb2JzZXJ2ZXIgPSBuZXcgSW50ZXJzZWN0aW9uT2JzZXJ2ZXIoKGVudHJpZXMsIG9ic2VydmVyKSA9PiB7XG4gICAgICAgICAgICBlbnRyaWVzLmZvckVhY2goZW50cnkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChlbnRyeS5pc0ludGVyc2VjdGluZykge1xuICAgICAgICAgICAgICAgICAgICBvYnNlcnZlci5kaXNjb25uZWN0KCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUuaW1hZ2UgPSAoMCwgY29yZV9qc18xLmgpKCdpbWcnLCBPYmplY3QuYXNzaWduKHt9LCByZXN0KSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnN0YXRlLmltYWdlLmNvbXBsZXRlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlLmlzTG9hZGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlLmltYWdlLm9ubG9hZCA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlLmlzTG9hZGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LCB7IHRocmVzaG9sZDogWzAsIDFdIH0pO1xuICAgICAgICBvYnNlcnZlci5vYnNlcnZlKHRoaXMuZWxlbWVudHNbMF0pO1xuICAgIH1cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIGNvbnN0IF9hID0gdGhpcy5wcm9wcywgeyBzcmMsIHBsYWNlaG9sZGVyLCBjaGlsZHJlbiwgbGF6eSA9IHRydWUsIGtleSwgcmVmIH0gPSBfYSwgcmVzdCA9IF9fcmVzdChfYSwgW1wic3JjXCIsIFwicGxhY2Vob2xkZXJcIiwgXCJjaGlsZHJlblwiLCBcImxhenlcIiwgXCJrZXlcIiwgXCJyZWZcIl0pO1xuICAgICAgICAvLyByZXR1cm4gdGhlIGltZyB0YWcgaWYgbm90IGxhenkgbG9hZGVkXG4gICAgICAgIGlmICh0eXBlb2YgbGF6eSA9PT0gJ2Jvb2xlYW4nICYmIGxhenkgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICB0aGlzLnN0YXRlLmltYWdlID0gKDAsIGNvcmVfanNfMS5oKSgnaW1nJywgT2JqZWN0LmFzc2lnbih7IHNyYyB9LCByZXN0KSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zdGF0ZS5pbWFnZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBpZiBpdCBpcyB2aXNpYmxlIGFuZCBsb2FkZWQsIHNob3cgdGhlIGltYWdlXG4gICAgICAgIGlmICh0aGlzLnN0YXRlLmlzTG9hZGVkKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zdGF0ZS5pbWFnZTtcbiAgICAgICAgICAgIC8vIGlmIHRoZSBwbGFjZWhvbGRlciBpcyBhbiBpbWFnZSBzcmNcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChwbGFjZWhvbGRlciAmJiB0eXBlb2YgcGxhY2Vob2xkZXIgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICByZXR1cm4gKDAsIGNvcmVfanNfMS5oKSgnaW1nJywgT2JqZWN0LmFzc2lnbih7IHNyYzogcGxhY2Vob2xkZXIgfSwgcmVzdCkpO1xuICAgICAgICAgICAgLy8gaWYgdGhlIHBsYWNlaG9sZGVyIGlzIGFuIEpTWCBlbGVtZW50XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocGxhY2Vob2xkZXIgJiYgdHlwZW9mIHBsYWNlaG9sZGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICByZXR1cm4gcGxhY2Vob2xkZXIoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIHJlbmRlciBhIHNpbXBsZSBib3hcbiAgICAgICAgICAgIGNvbnN0IHN0eWxlID0ge307XG4gICAgICAgICAgICBpZiAocmVzdC53aWR0aClcbiAgICAgICAgICAgICAgICBzdHlsZS53aWR0aCA9IGAke3Jlc3Qud2lkdGh9cHhgO1xuICAgICAgICAgICAgaWYgKHJlc3QuaGVpZ2h0KVxuICAgICAgICAgICAgICAgIHN0eWxlLmhlaWdodCA9IGAke3Jlc3QuaGVpZ2h0fXB4YDtcbiAgICAgICAgICAgIGNvbnN0IHsgd2lkdGgsIGhlaWdodCB9ID0gcmVzdCwgb3RoZXJzID0gX19yZXN0KHJlc3QsIFtcIndpZHRoXCIsIFwiaGVpZ2h0XCJdKTtcbiAgICAgICAgICAgIHJldHVybiAoMCwgY29yZV9qc18xLmgpKCdkaXYnLCBPYmplY3QuYXNzaWduKHsgc3R5bGUgfSwgb3RoZXJzKSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLkltZyA9IEltZztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWltZy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX3Jlc3QgPSAodGhpcyAmJiB0aGlzLl9fcmVzdCkgfHwgZnVuY3Rpb24gKHMsIGUpIHtcbiAgICB2YXIgdCA9IHt9O1xuICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSAmJiBlLmluZGV4T2YocCkgPCAwKVxuICAgICAgICB0W3BdID0gc1twXTtcbiAgICBpZiAocyAhPSBudWxsICYmIHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzID09PSBcImZ1bmN0aW9uXCIpXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBwID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhzKTsgaSA8IHAubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChlLmluZGV4T2YocFtpXSkgPCAwICYmIE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChzLCBwW2ldKSlcbiAgICAgICAgICAgICAgICB0W3BbaV1dID0gc1twW2ldXTtcbiAgICAgICAgfVxuICAgIHJldHVybiB0O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuTGluayA9IHZvaWQgMDtcbmNvbnN0IGNvbXBvbmVudF9qc18xID0gcmVxdWlyZShcIi4uL2NvbXBvbmVudC5qc1wiKTtcbmNvbnN0IGhlbG1ldF9qc18xID0gcmVxdWlyZShcIi4vaGVsbWV0LmpzXCIpO1xuY29uc3QgY29yZV9qc18xID0gcmVxdWlyZShcIi4uL2NvcmUuanNcIik7XG5jb25zdCBmcmFnbWVudF9qc18xID0gcmVxdWlyZShcIi4uL2ZyYWdtZW50LmpzXCIpO1xuLyoqXG4gKiBBIHNpbXBsZSBMaW5rIGNvbXBvbmVudFxuICogQWRkIDxMaW5rIHByZWZldGNoIC4uLiwgdG8gcHJlZmV0Y2ggdGhlIGh0bWwgZG9jdW1lbnRcbiAqIEFkZCA8TGluayBwcmVmZXRjaD1cImhvdmVyXCIgLi4uLCB0byBwcmVmZXRjaCB0aGUgaHRtbCBkb2N1bWVudCBvbiBob3ZlcmluZyBvdmVyIHRoZSBsaW5rIGVsZW1lbnQuXG4gKi9cbmNsYXNzIExpbmsgZXh0ZW5kcyBjb21wb25lbnRfanNfMS5Db21wb25lbnQge1xuICAgIHByZWZldGNoT25Ib3ZlcigpIHtcbiAgICAgICAgdGhpcy5lbGVtZW50c1swXS5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW92ZXInLCAoKSA9PiB0aGlzLmFkZFByZWZldGNoKCksIHsgb25jZTogdHJ1ZSB9KTtcbiAgICB9XG4gICAgcHJlZmV0Y2hPblZpc2libGUoKSB7XG4gICAgICAgIGNvbnN0IG9ic2VydmVyID0gbmV3IEludGVyc2VjdGlvbk9ic2VydmVyKChlbnRyaWVzLCBvYnNlcnZlcikgPT4ge1xuICAgICAgICAgICAgZW50cmllcy5mb3JFYWNoKGVudHJ5ID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoZW50cnkuaXNJbnRlcnNlY3RpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgb2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFkZFByZWZldGNoKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sIHsgdGhyZXNob2xkOiBbMCwgMV0gfSk7XG4gICAgICAgIG9ic2VydmVyLm9ic2VydmUodGhpcy5lbGVtZW50c1swXSk7XG4gICAgfVxuICAgIGFkZFByZWZldGNoKCkge1xuICAgICAgICBsZXQgZG9lc0FscmVhZHlFeGlzdCA9IGZhbHNlO1xuICAgICAgICAvLyBjaGVjayBpZiBpdCBpcyBhbHJlYWR5IG9uIHRoZSBkb21cbiAgICAgICAgY29uc3QgbGlua3MgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnbGluaycpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxpbmtzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAvLyBpZiBpdCBpcyBub3QgYWxyZWFkeSBvbiB0aGUgZG9tLCBhZGQgaXRcbiAgICAgICAgICAgIGlmIChsaW5rc1tpXS5nZXRBdHRyaWJ1dGUoJ3JlbCcpID09PSAncHJlZmV0Y2gnICYmIGxpbmtzW2ldLmdldEF0dHJpYnV0ZSgnaHJlZicpID09PSB0aGlzLnByb3BzLmhyZWYpIHtcbiAgICAgICAgICAgICAgICBkb2VzQWxyZWFkeUV4aXN0ID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIWRvZXNBbHJlYWR5RXhpc3QpIHtcbiAgICAgICAgICAgIGNvbnN0IHByZWZldGNoID0gKDAsIGNvcmVfanNfMS5oKSgnbGluaycsIHsgcmVsOiAncHJlZmV0Y2gnLCBocmVmOiB0aGlzLnByb3BzLmhyZWYsIGFzOiAnZG9jdW1lbnQnIH0pO1xuICAgICAgICAgICAgZG9jdW1lbnQuaGVhZC5hcHBlbmRDaGlsZChwcmVmZXRjaCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZGlkTW91bnQoKSB7XG4gICAgICAgIGNvbnN0IHsgaHJlZiwgcHJlZmV0Y2gsIGRlbGF5ID0gMCwgYmFjayA9IGZhbHNlIH0gPSB0aGlzLnByb3BzO1xuICAgICAgICBpZiAoYmFjaylcbiAgICAgICAgICAgIHRoaXMuZWxlbWVudHNbMF0uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoZSkgPT4ge1xuICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICBjb25zdCB0YXJnZXQgPSBlLnRhcmdldDtcbiAgICAgICAgICAgICAgICBpZiAodGFyZ2V0LmhyZWYgPT09IGRvY3VtZW50LnJlZmVycmVyKVxuICAgICAgICAgICAgICAgICAgICB3aW5kb3cuaGlzdG9yeS5iYWNrKCk7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICB3aW5kb3cubG9jYXRpb24uaHJlZiA9IHRhcmdldC5ocmVmO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIGlmIChkZWxheSA+IDApXG4gICAgICAgICAgICB0aGlzLmVsZW1lbnRzWzBdLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKGUpID0+IHtcbiAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiAod2luZG93LmxvY2F0aW9uLmhyZWYgPSBocmVmKSwgZGVsYXkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIGlmIChwcmVmZXRjaCkge1xuICAgICAgICAgICAgaWYgKHByZWZldGNoID09PSAnaG92ZXInKVxuICAgICAgICAgICAgICAgIHRoaXMucHJlZmV0Y2hPbkhvdmVyKCk7XG4gICAgICAgICAgICBlbHNlIGlmIChwcmVmZXRjaCA9PT0gJ3Zpc2libGUnKVxuICAgICAgICAgICAgICAgIHRoaXMucHJlZmV0Y2hPblZpc2libGUoKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICB0aGlzLmFkZFByZWZldGNoKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVuZGVyKCkge1xuICAgICAgICAvLyBzZXBhcmF0ZSBjaGlsZHJlbiBhbmQgcHJlZmV0Y2ggZnJvbSBwcm9wc1xuICAgICAgICBjb25zdCBfYSA9IHRoaXMucHJvcHMsIHsgY2hpbGRyZW4sIHByZWZldGNoLCBiYWNrLCByZWYgfSA9IF9hLCByZXN0ID0gX19yZXN0KF9hLCBbXCJjaGlsZHJlblwiLCBcInByZWZldGNoXCIsIFwiYmFja1wiLCBcInJlZlwiXSk7XG4gICAgICAgIC8vIHNvbWUgd2FybmluZyBtZXNzYWdlc1xuICAgICAgICBpZiAoIXRoaXMucHJvcHMuaHJlZilcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignUGxlYXNlIGFkZCBcImhyZWZcIiB0byA8TGluaz4nKTtcbiAgICAgICAgaWYgKGNoaWxkcmVuLmxlbmd0aCAhPT0gMSlcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignUGxlYXNlIGFkZCBPTkUgY2hpbGQgdG8gPExpbms+ICg8TGluaz5jaGlsZDwvTGluaz4pJyk7XG4gICAgICAgIGNvbnN0IGEgPSAoMCwgY29yZV9qc18xLmgpKCdhJywgT2JqZWN0LmFzc2lnbih7fSwgcmVzdCksIC4uLmNoaWxkcmVuKTtcbiAgICAgICAgLy8gaWYgc3NyXG4gICAgICAgIGlmIChwcmVmZXRjaCA9PT0gdHJ1ZSAmJiAhKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5kb2N1bWVudCkpIHtcbiAgICAgICAgICAgIC8vIDxsaW5rIHJlbD1cInByZWZldGNoXCIgaHJlZj1cIi9pbmRleC5odG1sXCIgYXM9XCJkb2N1bWVudFwiPjwvbGluaz5cbiAgICAgICAgICAgIGNvbnN0IGxpbmsgPSAoMCwgY29yZV9qc18xLmgpKCdsaW5rJywgeyByZWw6ICdwcmVmZXRjaCcsIGhyZWY6IHRoaXMucHJvcHMuaHJlZiwgYXM6ICdkb2N1bWVudCcgfSk7XG4gICAgICAgICAgICBjb25zdCBoZWxtZXQgPSAoMCwgY29yZV9qc18xLmgpKGhlbG1ldF9qc18xLkhlbG1ldCwgbnVsbCwgbGluayk7XG4gICAgICAgICAgICByZXR1cm4gKDAsIGNvcmVfanNfMS5oKShmcmFnbWVudF9qc18xLkZyYWdtZW50LCBudWxsLCBbaGVsbWV0LCBhXSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gaWYgbm90IHNzclxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBhO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5MaW5rID0gTGluaztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxpbmsuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vLyBpbnNwaXJlZCBieSBodHRwczovL2NvZGVzYW5kYm94LmlvL3MvYnVpbGQtb3duLXJlYWN0LXJvdXRlci12NC1tcHNselxudmFyIF9fcmVzdCA9ICh0aGlzICYmIHRoaXMuX19yZXN0KSB8fCBmdW5jdGlvbiAocywgZSkge1xuICAgIHZhciB0ID0ge307XG4gICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApICYmIGUuaW5kZXhPZihwKSA8IDApXG4gICAgICAgIHRbcF0gPSBzW3BdO1xuICAgIGlmIChzICE9IG51bGwgJiYgdHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPT09IFwiZnVuY3Rpb25cIilcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIHAgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHMpOyBpIDwgcC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKGUuaW5kZXhPZihwW2ldKSA8IDAgJiYgT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHMsIHBbaV0pKVxuICAgICAgICAgICAgICAgIHRbcFtpXV0gPSBzW3BbaV1dO1xuICAgICAgICB9XG4gICAgcmV0dXJuIHQ7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5wYXJzZVBhcmFtc0Zyb21QYXRoID0gZXhwb3J0cy5MaXN0ZW5lciA9IGV4cG9ydHMuTGluayA9IGV4cG9ydHMudG8gPSBleHBvcnRzLlJvdXRlID0gZXhwb3J0cy5Sb3V0ZXMgPSBleHBvcnRzLlN3aXRjaCA9IGV4cG9ydHMubWF0Y2hQYXRoID0gdm9pZCAwO1xuY29uc3QgY29tcG9uZW50X2pzXzEgPSByZXF1aXJlKFwiLi4vY29tcG9uZW50LmpzXCIpO1xuY29uc3QgY29yZV9qc18xID0gcmVxdWlyZShcIi4uL2NvcmUuanNcIik7XG5jb25zdCBpbnN0YW5jZXMgPSBbXTtcbmNvbnN0IHJlZ2lzdGVyID0gKGNvbXApID0+IGluc3RhbmNlcy5wdXNoKGNvbXApO1xuY29uc3QgdW5yZWdpc3RlciA9IChjb21wKSA9PiBpbnN0YW5jZXMuc3BsaWNlKGluc3RhbmNlcy5pbmRleE9mKGNvbXApLCAxKTtcbmNvbnN0IGhpc3RvcnlQdXNoID0gKHBhdGgpID0+IHtcbiAgICB3aW5kb3cuaGlzdG9yeS5wdXNoU3RhdGUoe30sICcnLCBwYXRoKTtcbiAgICBpbnN0YW5jZXMuZm9yRWFjaChpbnN0YW5jZSA9PiBpbnN0YW5jZS5oYW5kbGVDaGFuZ2VzKCkpO1xuICAgIHdpbmRvdy5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudCgncHVzaHN0YXRlJykpO1xufTtcbmNvbnN0IGhpc3RvcnlSZXBsYWNlID0gKHBhdGgpID0+IHtcbiAgICB3aW5kb3cuaGlzdG9yeS5yZXBsYWNlU3RhdGUoe30sICcnLCBwYXRoKTtcbiAgICBpbnN0YW5jZXMuZm9yRWFjaChpbnN0YW5jZSA9PiBpbnN0YW5jZS5oYW5kbGVDaGFuZ2VzKCkpO1xuICAgIHdpbmRvdy5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudCgncmVwbGFjZXN0YXRlJykpO1xufTtcbmNvbnN0IG1hdGNoUGF0aCA9IChwYXRobmFtZSwgb3B0aW9ucykgPT4ge1xuICAgIGNvbnN0IHsgZXhhY3QgPSBmYWxzZSwgcmVnZXggfSA9IG9wdGlvbnM7XG4gICAgbGV0IHsgcGF0aCB9ID0gb3B0aW9ucztcbiAgICBpZiAoIXBhdGgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHBhdGg6IG51bGwsXG4gICAgICAgICAgICB1cmw6IHBhdGhuYW1lLFxuICAgICAgICAgICAgaXNFeGFjdDogdHJ1ZSxcbiAgICAgICAgICAgIHBhcmFtczoge31cbiAgICAgICAgfTtcbiAgICB9XG4gICAgbGV0IG1hdGNoO1xuICAgIGxldCBwYXJhbXMgPSB7fTtcbiAgICAvLyBwYXRoIHdpdGggcGFyYW1zXG4gICAgaWYgKHBhdGguaW5jbHVkZXMoJy86JykpIHtcbiAgICAgICAgY29uc3QgcGF0aEFyciA9IHBhdGguc3BsaXQoJy8nKTtcbiAgICAgICAgY29uc3QgcGF0aG5hbWVBcnIgPSBwYXRobmFtZS5zcGxpdCgnLycpO1xuICAgICAgICBwYXRoQXJyLmZvckVhY2goKHAsIGkpID0+IHtcbiAgICAgICAgICAgIGlmICgvXjovLnRlc3QocCkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBrZXkgPSBwLnNsaWNlKDEpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gcGF0aG5hbWVBcnJbaV07XG4gICAgICAgICAgICAgICAgLy8gaWYgYSByZWdleCBpcyBwcm92aWRlZCwgY2hlY2sgaXQgaXQgbWF0Y2hlc1xuICAgICAgICAgICAgICAgIGlmIChyZWdleCAmJiByZWdleFtrZXldKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlZ2V4TWF0Y2ggPSByZWdleFtrZXldLnRlc3QodmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXJlZ2V4TWF0Y2gpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcGFyYW1zID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBwYXJhbXMpLCB7IFtrZXldOiB2YWx1ZSB9KTtcbiAgICAgICAgICAgICAgICBwYXRoQXJyW2ldID0gcGF0aG5hbWVBcnJbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBwYXRoID0gcGF0aEFyci5qb2luKCcvJyk7XG4gICAgfVxuICAgIC8vIGNhdGNoIGFsbFxuICAgIGlmIChwYXRoID09PSAnKicpXG4gICAgICAgIG1hdGNoID0gW3BhdGhuYW1lXTtcbiAgICAvLyByZWd1bGFyIHBhdGhcbiAgICBpZiAoIW1hdGNoKVxuICAgICAgICBtYXRjaCA9IG5ldyBSZWdFeHAoYF4ke3BhdGh9YCkuZXhlYyhwYXRobmFtZSk7XG4gICAgaWYgKCFtYXRjaClcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgY29uc3QgdXJsID0gbWF0Y2hbMF07XG4gICAgY29uc3QgaXNFeGFjdCA9IHBhdGhuYW1lID09PSB1cmw7XG4gICAgaWYgKGV4YWN0ICYmICFpc0V4YWN0KVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICByZXR1cm4ge1xuICAgICAgICBwYXRoLFxuICAgICAgICB1cmwsXG4gICAgICAgIGlzRXhhY3QsXG4gICAgICAgIHBhcmFtc1xuICAgIH07XG59O1xuZXhwb3J0cy5tYXRjaFBhdGggPSBtYXRjaFBhdGg7XG5jbGFzcyBTd2l0Y2ggZXh0ZW5kcyBjb21wb25lbnRfanNfMS5Db21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLmluZGV4ID0gMDtcbiAgICAgICAgdGhpcy5wYXRoID0gJyc7XG4gICAgICAgIHRoaXMubWF0Y2ggPSB7IGluZGV4OiAtMSwgcGF0aDogJycgfTtcbiAgICB9XG4gICAgZGlkTW91bnQoKSB7XG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdwb3BzdGF0ZScsIHRoaXMuaGFuZGxlQ2hhbmdlcy5iaW5kKHRoaXMpKTtcbiAgICAgICAgcmVnaXN0ZXIodGhpcyk7XG4gICAgfVxuICAgIGRpZFVubW91bnQoKSB7XG4gICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdwb3BzdGF0ZScsIHRoaXMuaGFuZGxlQ2hhbmdlcy5iaW5kKHRoaXMpKTtcbiAgICAgICAgdW5yZWdpc3Rlcih0aGlzKTtcbiAgICB9XG4gICAgaGFuZGxlQ2hhbmdlcygpIHtcbiAgICAgICAgdGhpcy5maW5kQ2hpbGQoKTtcbiAgICAgICAgaWYgKHRoaXMuc2hvdWxkVXBkYXRlKCkpXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZSgpO1xuICAgIH1cbiAgICBmaW5kQ2hpbGQoKSB7XG4gICAgICAgIHRoaXMubWF0Y2ggPSB7IGluZGV4OiAtMSwgcGF0aDogJycgfTtcbiAgICAgICAgLy8gZmxhdHRlbiBjaGlsZHJlblxuICAgICAgICB0aGlzLnByb3BzLmNoaWxkcmVuID0gdGhpcy5wcm9wcy5jaGlsZHJlbi5mbGF0KCk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5wcm9wcy5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgY2hpbGQgPSB0aGlzLnByb3BzLmNoaWxkcmVuW2ldO1xuICAgICAgICAgICAgY29uc3QgeyBwYXRoLCBleGFjdCwgcmVnZXggfSA9IGNoaWxkLnByb3BzO1xuICAgICAgICAgICAgY29uc3QgbWF0Y2ggPSAoMCwgZXhwb3J0cy5tYXRjaFBhdGgpKCgwLCBjb3JlX2pzXzEuaXNTU1IpKCkgPyBfbmFuby5sb2NhdGlvbi5wYXRobmFtZSA6IHdpbmRvdy5sb2NhdGlvbi5wYXRobmFtZSwge1xuICAgICAgICAgICAgICAgIHBhdGgsXG4gICAgICAgICAgICAgICAgZXhhY3QsXG4gICAgICAgICAgICAgICAgcmVnZXhcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tYXRjaC5pbmRleCA9IGk7XG4gICAgICAgICAgICAgICAgdGhpcy5tYXRjaC5wYXRoID0gcGF0aDtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgc2hvdWxkVXBkYXRlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wYXRoICE9PSB0aGlzLm1hdGNoLnBhdGggfHwgdGhpcy5pbmRleCAhPT0gdGhpcy5tYXRjaC5pbmRleDtcbiAgICB9XG4gICAgcmVuZGVyKCkge1xuICAgICAgICB0aGlzLmZpbmRDaGlsZCgpO1xuICAgICAgICBjb25zdCBjaGlsZCA9IHRoaXMucHJvcHMuY2hpbGRyZW5bdGhpcy5tYXRjaC5pbmRleF07XG4gICAgICAgIGlmICh0aGlzLm1hdGNoLmluZGV4ID09PSAtMSkge1xuICAgICAgICAgICAgdGhpcy5wYXRoID0gJyc7XG4gICAgICAgICAgICB0aGlzLmluZGV4ID0gMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2hpbGQpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgcGF0aCB9ID0gY2hpbGQucHJvcHM7XG4gICAgICAgICAgICB0aGlzLnBhdGggPSBwYXRoO1xuICAgICAgICAgICAgdGhpcy5pbmRleCA9IHRoaXMubWF0Y2guaW5kZXg7XG4gICAgICAgICAgICBjb25zdCBlbCA9ICgwLCBjb3JlX2pzXzEuX3JlbmRlcikoY2hpbGQpO1xuICAgICAgICAgICAgcmV0dXJuICgwLCBjb3JlX2pzXzEuaCkoJ2RpdicsIHt9LCAoMCwgY29yZV9qc18xLl9yZW5kZXIpKGVsKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5wcm9wcy5mYWxsYmFjaykge1xuICAgICAgICAgICAgcmV0dXJuICgwLCBjb3JlX2pzXzEuaCkoJ2RpdicsIHt9LCAoMCwgY29yZV9qc18xLl9yZW5kZXIpKHRoaXMucHJvcHMuZmFsbGJhY2spKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiAoMCwgY29yZV9qc18xLmgpKCdkaXYnLCB7fSwgJ25vdCBmb3VuZCcpO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5Td2l0Y2ggPSBTd2l0Y2g7XG4vLyBhbGlhcyBmb3IgPFN3aXRjaCAvPlxuY2xhc3MgUm91dGVzIGV4dGVuZHMgU3dpdGNoIHtcbn1cbmV4cG9ydHMuUm91dGVzID0gUm91dGVzO1xuY29uc3QgUm91dGUgPSAoeyBwYXRoLCByZWdleCwgY2hpbGRyZW4gfSkgPT4ge1xuICAgIC8vIGxvb2t1cCBwYXRobmFtZSBhbmQgcGFyYW1ldGVyc1xuICAgIGNvbnN0IHBhdGhuYW1lID0gKDAsIGNvcmVfanNfMS5pc1NTUikoKSA/IF9uYW5vLmxvY2F0aW9uLnBhdGhuYW1lIDogd2luZG93LmxvY2F0aW9uLnBhdGhuYW1lO1xuICAgIGNvbnN0IHBhcmFtcyA9ICgwLCBleHBvcnRzLnBhcnNlUGFyYW1zRnJvbVBhdGgpKHBhdGgpO1xuICAgIC8vIHBhc3MgdGhlIHJvdXRlIGFzIHByb3BzIHRvIHRoZSBjaGlsZHJlblxuICAgIGNoaWxkcmVuLmZvckVhY2goKGNoaWxkKSA9PiB7XG4gICAgICAgIGlmIChjaGlsZC5wcm9wcylcbiAgICAgICAgICAgIGNoaWxkLnByb3BzID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBjaGlsZC5wcm9wcyksIHsgcm91dGU6IHsgcGF0aCwgcmVnZXgsIHBhdGhuYW1lLCBwYXJhbXMgfSB9KTtcbiAgICB9KTtcbiAgICByZXR1cm4gY2hpbGRyZW47XG59O1xuZXhwb3J0cy5Sb3V0ZSA9IFJvdXRlO1xuY29uc3QgdG8gPSAodG8sIHJlcGxhY2UgPSBmYWxzZSkgPT4ge1xuICAgIHJlcGxhY2UgPyBoaXN0b3J5UmVwbGFjZSh0bykgOiBoaXN0b3J5UHVzaCh0byk7XG59O1xuZXhwb3J0cy50byA9IHRvO1xuY29uc3QgTGluayA9IChfYSkgPT4ge1xuICAgIHZhciB7IHRvLCByZXBsYWNlLCBjaGlsZHJlbiB9ID0gX2EsIHJlc3QgPSBfX3Jlc3QoX2EsIFtcInRvXCIsIFwicmVwbGFjZVwiLCBcImNoaWxkcmVuXCJdKTtcbiAgICBjb25zdCBoYW5kbGVDbGljayA9IChldmVudCkgPT4ge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICByZXBsYWNlID8gaGlzdG9yeVJlcGxhY2UodG8pIDogaGlzdG9yeVB1c2godG8pO1xuICAgIH07XG4gICAgcmV0dXJuICgwLCBjb3JlX2pzXzEuaCkoJ2EnLCBPYmplY3QuYXNzaWduKHsgaHJlZjogdG8sIG9uQ2xpY2s6IChlKSA9PiBoYW5kbGVDbGljayhlKSB9LCByZXN0KSwgY2hpbGRyZW4pO1xufTtcbmV4cG9ydHMuTGluayA9IExpbms7XG5jbGFzcyBDTGlzdGVuZXIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLl9saXN0ZW5lcnMgPSBuZXcgTWFwKCk7XG4gICAgICAgIGlmICgoMCwgY29yZV9qc18xLmlzU1NSKSgpKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0aGlzLl9yb3V0ZSA9IHdpbmRvdy5sb2NhdGlvbi5wYXRobmFtZTtcbiAgICAgICAgY29uc3QgZXZlbnQgPSAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBuZXdSb3V0ZSA9IHdpbmRvdy5sb2NhdGlvbi5wYXRobmFtZTtcbiAgICAgICAgICAgIHRoaXMuX2xpc3RlbmVycy5mb3JFYWNoKGZuYyA9PiB7XG4gICAgICAgICAgICAgICAgZm5jKG5ld1JvdXRlLCB0aGlzLl9yb3V0ZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuX3JvdXRlID0gbmV3Um91dGU7XG4gICAgICAgIH07XG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdwdXNoc3RhdGUnLCBldmVudCk7XG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXBsYWNlc3RhdGUnLCBldmVudCk7XG4gICAgfVxuICAgIHVzZSgpIHtcbiAgICAgICAgY29uc3QgaWQgPSBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zdWJzdHJpbmcoMik7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzdWJzY3JpYmU6IChmbmMpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLl9saXN0ZW5lcnMuc2V0KGlkLCBmbmMpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNhbmNlbDogKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9saXN0ZW5lcnMuaGFzKGlkKSlcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbGlzdGVuZXJzLmRlbGV0ZShpZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxufVxubGV0IGxpc3RlbmVyO1xuY29uc3QgTGlzdGVuZXIgPSAoKSA9PiB7XG4gICAgaWYgKCFsaXN0ZW5lcilcbiAgICAgICAgbGlzdGVuZXIgPSBuZXcgQ0xpc3RlbmVyKCk7XG4gICAgcmV0dXJuIGxpc3RlbmVyO1xufTtcbmV4cG9ydHMuTGlzdGVuZXIgPSBMaXN0ZW5lcjtcbi8qKiBQYXNzIFwidGhpcy5wcm9wcy5yb3V0ZS5wYXRoXCIgdG8gaXQuICovXG5jb25zdCBwYXJzZVBhcmFtc0Zyb21QYXRoID0gKHBhdGgpID0+IHtcbiAgICBsZXQgcGFyYW1zID0ge307XG4gICAgY29uc3QgX3BhdGhuYW1lID0gKDAsIGNvcmVfanNfMS5pc1NTUikoKSA/IF9uYW5vLmxvY2F0aW9uLnBhdGhuYW1lLnNwbGl0KCcvJykgOiB3aW5kb3cubG9jYXRpb24ucGF0aG5hbWUuc3BsaXQoJy8nKTtcbiAgICBwYXRoLnNwbGl0KCcvJykuZm9yRWFjaCgocCwgaSkgPT4ge1xuICAgICAgICBpZiAocC5zdGFydHNXaXRoKCc6JykpXG4gICAgICAgICAgICBwYXJhbXMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHBhcmFtcyksIHsgW3Auc2xpY2UoMSldOiBfcGF0aG5hbWVbaV0gfSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHBhcmFtcztcbn07XG5leHBvcnRzLnBhcnNlUGFyYW1zRnJvbVBhdGggPSBwYXJzZVBhcmFtc0Zyb21QYXRoO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cm91dGVyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5WaXNpYmxlID0gdm9pZCAwO1xuY29uc3QgY29yZV9qc18xID0gcmVxdWlyZShcIi4uL2NvcmUuanNcIik7XG5jb25zdCBjb21wb25lbnRfanNfMSA9IHJlcXVpcmUoXCIuLi9jb21wb25lbnQuanNcIik7XG5jbGFzcyBWaXNpYmxlIGV4dGVuZHMgY29tcG9uZW50X2pzXzEuQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5pc1Zpc2libGUgPSBmYWxzZTtcbiAgICB9XG4gICAgZGlkTW91bnQoKSB7XG4gICAgICAgIGNvbnN0IG9ic2VydmVyID0gbmV3IEludGVyc2VjdGlvbk9ic2VydmVyKChlbnRyaWVzLCBvYnNlcnZlcikgPT4ge1xuICAgICAgICAgICAgZW50cmllcy5mb3JFYWNoKGVudHJ5ID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoZW50cnkuaXNJbnRlcnNlY3RpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgb2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmlzVmlzaWJsZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sIHsgdGhyZXNob2xkOiBbMCwgMV0gfSk7XG4gICAgICAgIG9ic2VydmVyLm9ic2VydmUodGhpcy5lbGVtZW50c1swXSk7XG4gICAgfVxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzVmlzaWJsZSkge1xuICAgICAgICAgICAgcmV0dXJuICgwLCBjb3JlX2pzXzEuaCkoJ2RpdicsIHsgJ2RhdGEtdmlzaWJsZSc6IGZhbHNlLCB2aXNpYmlsaXR5OiAnaGlkZGVuJyB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnByb3BzLm9uVmlzaWJsZSlcbiAgICAgICAgICAgICAgICB0aGlzLnByb3BzLm9uVmlzaWJsZSgpO1xuICAgICAgICAgICAgcmV0dXJuICgwLCBjb3JlX2pzXzEucmVuZGVyKSh0aGlzLnByb3BzLmNvbXBvbmVudCB8fCB0aGlzLnByb3BzLmNoaWxkcmVuWzBdKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuVmlzaWJsZSA9IFZpc2libGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD12aXNpYmxlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy51c2VDb250ZXh0ID0gZXhwb3J0cy5jcmVhdGVDb250ZXh0ID0gdm9pZCAwO1xuY29uc3QgY3JlYXRlQ29udGV4dCA9IChjdHgpID0+IHtcbiAgICBsZXQgX2N0eCA9IGN0eDtcbiAgICByZXR1cm4ge1xuICAgICAgICBQcm92aWRlcjogKHByb3BzKSA9PiB7XG4gICAgICAgICAgICBpZiAocHJvcHMudmFsdWUpXG4gICAgICAgICAgICAgICAgX2N0eCA9IHByb3BzLnZhbHVlO1xuICAgICAgICAgICAgcmV0dXJuIHByb3BzLmNoaWxkcmVuO1xuICAgICAgICB9LFxuICAgICAgICBDb25zdW1lcjogKHByb3BzKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4geyBjb21wb25lbnQ6IHByb3BzLmNoaWxkcmVuWzBdKF9jdHgpLCBwcm9wczogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBwcm9wcyksIHsgY29udGV4dDogX2N0eCB9KSB9O1xuICAgICAgICB9LFxuICAgICAgICBnZXQ6ICgpID0+IF9jdHgsXG4gICAgICAgIHNldDogKGN0eCkgPT4gKF9jdHggPSBjdHgpXG4gICAgfTtcbn07XG5leHBvcnRzLmNyZWF0ZUNvbnRleHQgPSBjcmVhdGVDb250ZXh0O1xuY29uc3QgdXNlQ29udGV4dCA9IChjdHgpID0+IHtcbiAgICBjb25zdCBfY3R4ID0gY3R4O1xuICAgIGlmIChfY3R4ICYmIHR5cGVvZiBfY3R4LmdldCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gX2N0eC5nZXQoKTtcbiAgICB9XG59O1xuZXhwb3J0cy51c2VDb250ZXh0ID0gdXNlQ29udGV4dDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbnRleHQuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmggPSBleHBvcnRzLl9yZW5kZXIgPSBleHBvcnRzLmh5ZHJhdGUgPSBleHBvcnRzLnJlbmRlciA9IGV4cG9ydHMuYXBwZW5kQ2hpbGRyZW4gPSBleHBvcnRzLnN0clRvSGFzaCA9IGV4cG9ydHMucmVtb3ZlQWxsQ2hpbGROb2RlcyA9IGV4cG9ydHMudGljayA9IGV4cG9ydHMuaXNTU1IgPSB2b2lkIDA7XG5yZXF1aXJlKFwiLi90eXBlcy5qc1wiKTtcbmNvbnN0IGlzU1NSID0gKCkgPT4gdHlwZW9mIF9uYW5vICE9PSAndW5kZWZpbmVkJyAmJiBfbmFuby5pc1NTUiA9PT0gdHJ1ZTtcbmV4cG9ydHMuaXNTU1IgPSBpc1NTUjtcbi8qKiBDcmVhdGVzIGEgbmV3IE1pY3JvdGFzayB1c2luZyBQcm9taXNlKCkgKi9cbmV4cG9ydHMudGljayA9IFByb21pc2UucHJvdG90eXBlLnRoZW4uYmluZChQcm9taXNlLnJlc29sdmUoKSk7XG5jb25zdCByZW1vdmVBbGxDaGlsZE5vZGVzID0gKHBhcmVudCkgPT4ge1xuICAgIHdoaWxlIChwYXJlbnQuZmlyc3RDaGlsZCkge1xuICAgICAgICBwYXJlbnQucmVtb3ZlQ2hpbGQocGFyZW50LmZpcnN0Q2hpbGQpO1xuICAgIH1cbn07XG5leHBvcnRzLnJlbW92ZUFsbENoaWxkTm9kZXMgPSByZW1vdmVBbGxDaGlsZE5vZGVzO1xuLy8gaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzc2MTY0ODQvMTI2NTY4NTVcbmNvbnN0IHN0clRvSGFzaCA9IChzKSA9PiB7XG4gICAgbGV0IGhhc2ggPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBjaHIgPSBzLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIGhhc2ggPSAoaGFzaCA8PCA1KSAtIGhhc2ggKyBjaHI7XG4gICAgICAgIGhhc2ggfD0gMDsgLy8gQ29udmVydCB0byAzMmJpdCBpbnRlZ2VyXG4gICAgfVxuICAgIHJldHVybiBNYXRoLmFicyhoYXNoKS50b1N0cmluZygzMik7XG59O1xuZXhwb3J0cy5zdHJUb0hhc2ggPSBzdHJUb0hhc2g7XG5jb25zdCBhcHBlbmRDaGlsZHJlbiA9IChlbGVtZW50LCBjaGlsZHJlbiwgZXNjYXBlID0gdHJ1ZSkgPT4ge1xuICAgIC8vIGlmIHRoZSBjaGlsZCBpcyBhbiBodG1sIGVsZW1lbnRcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoY2hpbGRyZW4pKSB7XG4gICAgICAgICgwLCBleHBvcnRzLmFwcGVuZENoaWxkcmVuKShlbGVtZW50LCBbY2hpbGRyZW5dLCBlc2NhcGUpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIGh0bWxDb2xsZWN0aW9uIHRvIGFycmF5XG4gICAgaWYgKHR5cGVvZiBjaGlsZHJlbiA9PT0gJ29iamVjdCcpXG4gICAgICAgIGNoaWxkcmVuID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoY2hpbGRyZW4pO1xuICAgIGNoaWxkcmVuLmZvckVhY2goY2hpbGQgPT4ge1xuICAgICAgICAvLyBpZiBjaGlsZCBpcyBhbiBhcnJheSBvZiBjaGlsZHJlbiwgYXBwZW5kIHRoZW0gaW5zdGVhZFxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShjaGlsZCkpXG4gICAgICAgICAgICAoMCwgZXhwb3J0cy5hcHBlbmRDaGlsZHJlbikoZWxlbWVudCwgY2hpbGQsIGVzY2FwZSk7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gcmVuZGVyIHRoZSBjb21wb25lbnRcbiAgICAgICAgICAgIGNvbnN0IGMgPSAoMCwgZXhwb3J0cy5fcmVuZGVyKShjaGlsZCk7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgLy8gaWYgYyBpcyBhbiBhcnJheSBvZiBjaGlsZHJlbiwgYXBwZW5kIHRoZW0gaW5zdGVhZFxuICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGMpKVxuICAgICAgICAgICAgICAgICAgICAoMCwgZXhwb3J0cy5hcHBlbmRDaGlsZHJlbikoZWxlbWVudCwgYywgZXNjYXBlKTtcbiAgICAgICAgICAgICAgICAvLyBhcHBseSB0aGUgY29tcG9uZW50IHRvIHBhcmVudCBlbGVtZW50XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICgoMCwgZXhwb3J0cy5pc1NTUikoKSAmJiAhZXNjYXBlKVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5hcHBlbmRDaGlsZChjLm5vZGVUeXBlID09IG51bGwgPyBjLnRvU3RyaW5nKCkgOiBjKTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5hcHBlbmRDaGlsZChjLm5vZGVUeXBlID09IG51bGwgPyBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShjLnRvU3RyaW5nKCkpIDogYyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG59O1xuZXhwb3J0cy5hcHBlbmRDaGlsZHJlbiA9IGFwcGVuZENoaWxkcmVuO1xuLyoqXG4gKiBBIHNpbXBsZSBjb21wb25lbnQgZm9yIHJlbmRlcmluZyBTVkdzXG4gKi9cbmNvbnN0IFNWRyA9IChwcm9wcykgPT4ge1xuICAgIGNvbnN0IGNoaWxkID0gcHJvcHMuY2hpbGRyZW5bMF07XG4gICAgY29uc3QgYXR0cnMgPSBjaGlsZC5hdHRyaWJ1dGVzO1xuICAgIGlmICgoMCwgZXhwb3J0cy5pc1NTUikoKSlcbiAgICAgICAgcmV0dXJuIGNoaWxkO1xuICAgIGNvbnN0IHN2ZyA9IGhOUygnc3ZnJyk7XG4gICAgZm9yIChsZXQgaSA9IGF0dHJzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIHN2Zy5zZXRBdHRyaWJ1dGUoYXR0cnNbaV0ubmFtZSwgYXR0cnNbaV0udmFsdWUpO1xuICAgIH1cbiAgICBzdmcuaW5uZXJIVE1MID0gY2hpbGQuaW5uZXJIVE1MO1xuICAgIHJldHVybiBzdmc7XG59O1xuLyoqIFJldHVybnMgdGhlIHBvcHVsYXRlZCBwYXJlbnQgaWYgYXZhaWxhYmxlIGVsc2UgIG9uZSBjaGlsZCBvciBhbiBhcnJheSBvZiBjaGlsZHJlbiAqL1xuY29uc3QgcmVuZGVyID0gKGNvbXBvbmVudCwgcGFyZW50ID0gbnVsbCwgcmVtb3ZlQ2hpbGROb2RlcyA9IHRydWUpID0+IHtcbiAgICBsZXQgZWwgPSAoMCwgZXhwb3J0cy5fcmVuZGVyKShjb21wb25lbnQpO1xuICAgIGlmIChBcnJheS5pc0FycmF5KGVsKSkge1xuICAgICAgICBlbCA9IGVsLm1hcChlID0+ICgwLCBleHBvcnRzLl9yZW5kZXIpKGUpKTtcbiAgICAgICAgaWYgKGVsLmxlbmd0aCA9PT0gMSlcbiAgICAgICAgICAgIGVsID0gZWxbMF07XG4gICAgfVxuICAgIGlmIChwYXJlbnQpIHtcbiAgICAgICAgaWYgKHJlbW92ZUNoaWxkTm9kZXMpXG4gICAgICAgICAgICAoMCwgZXhwb3J0cy5yZW1vdmVBbGxDaGlsZE5vZGVzKShwYXJlbnQpO1xuICAgICAgICAvLyBpZiBwYXJlbnQgYW5kIGNoaWxkIGFyZSB0aGUgc2FtZSwgd2UgcmVwbGFjZSB0aGUgcGFyZW50IGluc3RlYWQgb2YgYXBwZW5kaW5nIHRvIGl0XG4gICAgICAgIGlmIChlbCAmJiBwYXJlbnQuaWQgJiYgcGFyZW50LmlkID09PSBlbC5pZCAmJiBwYXJlbnQucGFyZW50RWxlbWVudCkge1xuICAgICAgICAgICAgcGFyZW50LnBhcmVudEVsZW1lbnQucmVwbGFjZUNoaWxkKGVsLCBwYXJlbnQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gYXBwZW5kIGVsZW1lbnQocykgdG8gdGhlIHBhcmVudFxuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZWwpKVxuICAgICAgICAgICAgICAgIGVsLmZvckVhY2goKGUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgKDAsIGV4cG9ydHMuYXBwZW5kQ2hpbGRyZW4pKHBhcmVudCwgKDAsIGV4cG9ydHMuX3JlbmRlcikoZSkpO1xuICAgICAgICAgICAgICAgICAgICAvL3BhcmVudC5hcHBlbmRDaGlsZChfcmVuZGVyKGUpKVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICgwLCBleHBvcnRzLmFwcGVuZENoaWxkcmVuKShwYXJlbnQsICgwLCBleHBvcnRzLl9yZW5kZXIpKGVsKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBhcmVudDtcbiAgICB9XG4gICAgLy8gcmV0dXJuaW5nIG9uZSBjaGlsZCBvciBhbiBhcnJheSBvZiBjaGlsZHJlblxuICAgIGVsc2Uge1xuICAgICAgICBpZiAoKDAsIGV4cG9ydHMuaXNTU1IpKCkgJiYgIUFycmF5LmlzQXJyYXkoZWwpKVxuICAgICAgICAgICAgcmV0dXJuIFtlbF07XG4gICAgICAgIHJldHVybiBlbDtcbiAgICB9XG59O1xuZXhwb3J0cy5yZW5kZXIgPSByZW5kZXI7XG5leHBvcnRzLmh5ZHJhdGUgPSBleHBvcnRzLnJlbmRlcjtcbmNvbnN0IF9yZW5kZXIgPSAoY29tcCkgPT4ge1xuICAgIC8vIG51bGwsIGZhbHNlLCB1bmRlZmluZWRcbiAgICBpZiAoY29tcCA9PT0gbnVsbCB8fCBjb21wID09PSBmYWxzZSB8fCB0eXBlb2YgY29tcCA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgICAgIHJldHVybiBbXTtcbiAgICAvLyBzdHJpbmcsIG51bWJlclxuICAgIGlmICh0eXBlb2YgY29tcCA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIGNvbXAgPT09ICdudW1iZXInKVxuICAgICAgICByZXR1cm4gY29tcC50b1N0cmluZygpO1xuICAgIC8vIFNWR0VsZW1lbnRcbiAgICBpZiAoY29tcC50YWdOYW1lICYmIGNvbXAudGFnTmFtZS50b0xvd2VyQ2FzZSgpID09PSAnc3ZnJylcbiAgICAgICAgcmV0dXJuIFNWRyh7IGNoaWxkcmVuOiBbY29tcF0gfSk7XG4gICAgLy8gSFRNTEVsZW1lbnRcbiAgICBpZiAoY29tcC50YWdOYW1lKVxuICAgICAgICByZXR1cm4gY29tcDtcbiAgICAvLyBURVhUTm9kZSAoTm9kZS5URVhUX05PREUgPT09IDMpXG4gICAgaWYgKGNvbXAgJiYgY29tcC5ub2RlVHlwZSA9PT0gMylcbiAgICAgICAgcmV0dXJuIGNvbXA7XG4gICAgLy8gQ2xhc3MgQ29tcG9uZW50XG4gICAgaWYgKGNvbXAgJiYgY29tcC5jb21wb25lbnQgJiYgY29tcC5jb21wb25lbnQuaXNDbGFzcylcbiAgICAgICAgcmV0dXJuIHJlbmRlckNsYXNzQ29tcG9uZW50KGNvbXApO1xuICAgIC8vIENsYXNzIENvbXBvbmVudCAoVW5pbml0aWFsaXplZClcbiAgICBpZiAoY29tcC5pc0NsYXNzKVxuICAgICAgICByZXR1cm4gcmVuZGVyQ2xhc3NDb21wb25lbnQoeyBjb21wb25lbnQ6IGNvbXAsIHByb3BzOiB7fSB9KTtcbiAgICAvLyBGdW5jdGlvbmFsIENvbXBvbmVudFxuICAgIGlmIChjb21wLmNvbXBvbmVudCAmJiB0eXBlb2YgY29tcC5jb21wb25lbnQgPT09ICdmdW5jdGlvbicpXG4gICAgICAgIHJldHVybiByZW5kZXJGdW5jdGlvbmFsQ29tcG9uZW50KGNvbXApO1xuICAgIC8vIEFycmF5IChyZW5kZXIgZWFjaCBjaGlsZCBhbmQgcmV0dXJuIHRoZSBhcnJheSkgKGlzIHByb2JhYmx5IGEgZnJhZ21lbnQpXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoY29tcCkpXG4gICAgICAgIHJldHVybiBjb21wLm1hcChjID0+ICgwLCBleHBvcnRzLl9yZW5kZXIpKGMpKS5mbGF0KCk7XG4gICAgLy8gZnVuY3Rpb25cbiAgICBpZiAodHlwZW9mIGNvbXAgPT09ICdmdW5jdGlvbicgJiYgIWNvbXAuaXNDbGFzcylcbiAgICAgICAgcmV0dXJuICgwLCBleHBvcnRzLl9yZW5kZXIpKGNvbXAoKSk7XG4gICAgLy8gaWYgY29tcG9uZW50IGlzIGEgSFRNTEVsZW1lbnQgKHJhcmUgY2FzZSlcbiAgICBpZiAoY29tcC5jb21wb25lbnQgJiYgY29tcC5jb21wb25lbnQudGFnTmFtZSAmJiB0eXBlb2YgY29tcC5jb21wb25lbnQudGFnTmFtZSA9PT0gJ3N0cmluZycpXG4gICAgICAgIHJldHVybiAoMCwgZXhwb3J0cy5fcmVuZGVyKShjb21wLmNvbXBvbmVudCk7XG4gICAgLy8gKHJhcmUgY2FzZSlcbiAgICBpZiAoQXJyYXkuaXNBcnJheShjb21wLmNvbXBvbmVudCkpXG4gICAgICAgIHJldHVybiAoMCwgZXhwb3J0cy5fcmVuZGVyKShjb21wLmNvbXBvbmVudCk7XG4gICAgLy8gKHJhcmUgY2FzZSlcbiAgICBpZiAoY29tcC5jb21wb25lbnQpXG4gICAgICAgIHJldHVybiAoMCwgZXhwb3J0cy5fcmVuZGVyKShjb21wLmNvbXBvbmVudCk7XG4gICAgLy8gb2JqZWN0XG4gICAgaWYgKHR5cGVvZiBjb21wID09PSAnb2JqZWN0JylcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIGNvbnNvbGUud2FybignU29tZXRoaW5nIHVuZXhwZWN0ZWQgaGFwcGVuZWQgd2l0aDonLCBjb21wKTtcbn07XG5leHBvcnRzLl9yZW5kZXIgPSBfcmVuZGVyO1xuY29uc3QgcmVuZGVyRnVuY3Rpb25hbENvbXBvbmVudCA9IChmbmNDb21wKSA9PiB7XG4gICAgY29uc3QgeyBjb21wb25lbnQsIHByb3BzIH0gPSBmbmNDb21wO1xuICAgIHJldHVybiAoMCwgZXhwb3J0cy5fcmVuZGVyKShjb21wb25lbnQocHJvcHMpKTtcbn07XG5jb25zdCByZW5kZXJDbGFzc0NvbXBvbmVudCA9IChjbGFzc0NvbXApID0+IHtcbiAgICBjb25zdCB7IGNvbXBvbmVudCwgcHJvcHMgfSA9IGNsYXNzQ29tcDtcbiAgICAvLyBjYWxjIGhhc2hcbiAgICBjb25zdCBoYXNoID0gKDAsIGV4cG9ydHMuc3RyVG9IYXNoKShjb21wb25lbnQudG9TdHJpbmcoKSk7XG4gICAgLy8gbWFrZSBoYXNoIGFjY2Vzc2libGUgaW4gY29uc3RydWN0b3IsIHdpdGhvdXQgcGFzc2luZyBpdCB0byBpdFxuICAgIGNvbXBvbmVudC5wcm90b3R5cGUuX2dldEhhc2ggPSAoKSA9PiBoYXNoO1xuICAgIGNvbnN0IENvbXBvbmVudCA9IG5ldyBjb21wb25lbnQocHJvcHMpO1xuICAgIGlmICghKDAsIGV4cG9ydHMuaXNTU1IpKCkpXG4gICAgICAgIENvbXBvbmVudC53aWxsTW91bnQoKTtcbiAgICBsZXQgZWwgPSBDb21wb25lbnQucmVuZGVyKCk7XG4gICAgZWwgPSAoMCwgZXhwb3J0cy5fcmVuZGVyKShlbCk7XG4gICAgQ29tcG9uZW50LmVsZW1lbnRzID0gZWw7XG4gICAgLy8gcGFzcyB0aGUgY29tcG9uZW50IGluc3RhbmNlIGFzIHJlZlxuICAgIGlmIChwcm9wcyAmJiBwcm9wcy5yZWYpXG4gICAgICAgIHByb3BzLnJlZihDb21wb25lbnQpO1xuICAgIGlmICghKDAsIGV4cG9ydHMuaXNTU1IpKCkpXG4gICAgICAgICgwLCBleHBvcnRzLnRpY2spKCgpID0+IHtcbiAgICAgICAgICAgIENvbXBvbmVudC5fZGlkTW91bnQoKTtcbiAgICAgICAgfSk7XG4gICAgcmV0dXJuIGVsO1xufTtcbmNvbnN0IGhOUyA9ICh0YWcpID0+IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUygnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnLCB0YWcpO1xuLy8gaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzQyNDA1Njk0LzEyNjU2ODU1XG5jb25zdCBoID0gKHRhZ05hbWVPckNvbXBvbmVudCwgcHJvcHMgPSB7fSwgLi4uY2hpbGRyZW4pID0+IHtcbiAgICAvLyBpZiBjaGlsZHJlbiBpcyBwYXNzZWQgYXMgcHJvcHMsIG1lcmdlIHdpdGggLi4uY2hpbGRyZW5cbiAgICBpZiAocHJvcHMgJiYgcHJvcHMuY2hpbGRyZW4pIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoY2hpbGRyZW4pKSB7XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShwcm9wcy5jaGlsZHJlbikpXG4gICAgICAgICAgICAgICAgY2hpbGRyZW4gPSBbLi4ucHJvcHMuY2hpbGRyZW4sIC4uLmNoaWxkcmVuXTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBjaGlsZHJlbi5wdXNoKHByb3BzLmNoaWxkcmVuKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHByb3BzLmNoaWxkcmVuKSlcbiAgICAgICAgICAgICAgICBjaGlsZHJlbiA9IHByb3BzLmNoaWxkcmVuO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIGNoaWxkcmVuID0gW3Byb3BzLmNoaWxkcmVuXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyByZW5kZXIgV2ViQ29tcG9uZW50IGluIFNTUlxuICAgIGlmICgoMCwgZXhwb3J0cy5pc1NTUikoKSAmJiBfbmFuby5zc3JUcmlja3MuaXNXZWJDb21wb25lbnQodGFnTmFtZU9yQ29tcG9uZW50KSkge1xuICAgICAgICBjb25zdCBlbGVtZW50ID0gX25hbm8uc3NyVHJpY2tzLnJlbmRlcldlYkNvbXBvbmVudCh0YWdOYW1lT3JDb21wb25lbnQsIHByb3BzLCBjaGlsZHJlbiwgZXhwb3J0cy5fcmVuZGVyKTtcbiAgICAgICAgaWYgKGVsZW1lbnQgPT09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gYEVSUk9SOiBcIjwke3RhZ05hbWVPckNvbXBvbmVudH0gLz5cImA7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHJldHVybiBlbGVtZW50O1xuICAgIH1cbiAgICAvLyBpZiB0YWdOYW1lT3JDb21wb25lbnQgaXMgYSBjb21wb25lbnRcbiAgICBpZiAodHlwZW9mIHRhZ05hbWVPckNvbXBvbmVudCAhPT0gJ3N0cmluZycpXG4gICAgICAgIHJldHVybiB7IGNvbXBvbmVudDogdGFnTmFtZU9yQ29tcG9uZW50LCBwcm9wczogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBwcm9wcyksIHsgY2hpbGRyZW46IGNoaWxkcmVuIH0pIH07XG4gICAgLy8gY3VzdG9tIG1lc3NhZ2UgaWYgZG9jdW1lbnQgaXMgbm90IGRlZmluZWQgaW4gU1NSXG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKCgwLCBleHBvcnRzLmlzU1NSKSgpICYmIHR5cGVvZiB0YWdOYW1lT3JDb21wb25lbnQgPT09ICdzdHJpbmcnICYmICFkb2N1bWVudClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignZG9jdW1lbnQgaXMgbm90IGRlZmluZWQnKTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycikge1xuICAgICAgICBjb25zb2xlLmxvZygnRVJST1I6JywgZXJyLm1lc3NhZ2UsICdcXG4gPiBQbGVhc2UgcmVhZDogaHR0cHM6Ly9naXRodWIuY29tL25hbm9qc3gvbmFuby9pc3N1ZXMvMTA2Jyk7XG4gICAgfVxuICAgIGxldCByZWY7XG4gICAgY29uc3QgZWxlbWVudCA9IHRhZ05hbWVPckNvbXBvbmVudCA9PT0gJ3N2ZydcbiAgICAgICAgPyBoTlMoJ3N2ZycpXG4gICAgICAgIDogZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWdOYW1lT3JDb21wb25lbnQpO1xuICAgIC8vIGNoZWNrIGlmIHRoZSBlbGVtZW50IGluY2x1ZGVzIHRoZSBldmVudCAoZm9yIGV4YW1wbGUgJ29uaW5wdXQnKVxuICAgIGNvbnN0IGlzRXZlbnQgPSAoZWwsIHApID0+IHtcbiAgICAgICAgLy8gY2hlY2sgaWYgdGhlIGV2ZW50IGJlZ2lucyB3aXRoICdvbidcbiAgICAgICAgaWYgKDAgIT09IHAuaW5kZXhPZignb24nKSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgLy8gd2UgcmV0dXJuIHRydWUgaWYgU1NSLCBzaW5jZSBvdGhlcndpc2UgaXQgd2lsbCBnZXQgcmVuZGVyZWRcbiAgICAgICAgaWYgKGVsLl9zc3IpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgLy8gY2hlY2sgaWYgdGhlIGV2ZW50IGlzIHByZXNlbnQgaW4gdGhlIGVsZW1lbnQgYXMgb2JqZWN0IChudWxsKSBvciBhcyBmdW5jdGlvblxuICAgICAgICByZXR1cm4gdHlwZW9mIGVsW3BdID09PSAnb2JqZWN0JyB8fCB0eXBlb2YgZWxbcF0gPT09ICdmdW5jdGlvbic7XG4gICAgfTtcbiAgICBmb3IgKGNvbnN0IHAgaW4gcHJvcHMpIHtcbiAgICAgICAgLy8gaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzQ1MjA1NjQ1LzEyNjU2ODU1XG4gICAgICAgIC8vIHN0eWxlIG9iamVjdCB0byBzdHlsZSBzdHJpbmdcbiAgICAgICAgaWYgKHAgPT09ICdzdHlsZScgJiYgdHlwZW9mIHByb3BzW3BdID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgY29uc3Qgc3R5bGVzID0gT2JqZWN0LmtleXMocHJvcHNbcF0pXG4gICAgICAgICAgICAgICAgLm1hcChrID0+IGAke2t9OiR7cHJvcHNbcF1ba119YClcbiAgICAgICAgICAgICAgICAuam9pbignOycpXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoL1tBLVpdL2csIG1hdGNoID0+IGAtJHttYXRjaC50b0xvd2VyQ2FzZSgpfWApO1xuICAgICAgICAgICAgcHJvcHNbcF0gPSBgJHtzdHlsZXN9O2A7XG4gICAgICAgIH1cbiAgICAgICAgLy8gaGFuZGVsIHJlZlxuICAgICAgICBpZiAocCA9PT0gJ3JlZicpXG4gICAgICAgICAgICByZWYgPSBwcm9wc1twXTtcbiAgICAgICAgLy8gaGFuZGxlIGV2ZW50c1xuICAgICAgICBlbHNlIGlmIChpc0V2ZW50KGVsZW1lbnQsIHAudG9Mb3dlckNhc2UoKSkpXG4gICAgICAgICAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIocC50b0xvd2VyQ2FzZSgpLnN1YnN0cmluZygyKSwgKGUpID0+IHByb3BzW3BdKGUpKTtcbiAgICAgICAgLy8gZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUxcbiAgICAgICAgZWxzZSBpZiAocCA9PT0gJ2Rhbmdlcm91c2x5U2V0SW5uZXJIVE1MJyAmJiBwcm9wc1twXS5fX2h0bWwpIHtcbiAgICAgICAgICAgIGlmICghKDAsIGV4cG9ydHMuaXNTU1IpKCkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBmcmFnbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2ZyYWdtZW50Jyk7XG4gICAgICAgICAgICAgICAgZnJhZ21lbnQuaW5uZXJIVE1MID0gcHJvcHNbcF0uX19odG1sO1xuICAgICAgICAgICAgICAgIGVsZW1lbnQuYXBwZW5kQ2hpbGQoZnJhZ21lbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZWxlbWVudC5pbm5lckhUTUwgPSBwcm9wc1twXS5fX2h0bWw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gbW9kZXJuIGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MXG4gICAgICAgIGVsc2UgaWYgKHAgPT09ICdpbm5lckhUTUwnICYmIHByb3BzW3BdLl9fZGFuZ2Vyb3VzSHRtbCkge1xuICAgICAgICAgICAgaWYgKCEoMCwgZXhwb3J0cy5pc1NTUikoKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGZyYWdtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZnJhZ21lbnQnKTtcbiAgICAgICAgICAgICAgICBmcmFnbWVudC5pbm5lckhUTUwgPSBwcm9wc1twXS5fX2Rhbmdlcm91c0h0bWw7XG4gICAgICAgICAgICAgICAgZWxlbWVudC5hcHBlbmRDaGlsZChmcmFnbWVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBlbGVtZW50LmlubmVySFRNTCA9IHByb3BzW3BdLl9fZGFuZ2Vyb3VzSHRtbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBjbGFzc05hbWVcbiAgICAgICAgZWxzZSBpZiAoL15jbGFzc05hbWUkL2kudGVzdChwKSlcbiAgICAgICAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKCdjbGFzcycsIHByb3BzW3BdKTtcbiAgICAgICAgLy8gc2V0QXR0cmlidXRlXG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBwcm9wc1twXSAhPT0gJ3VuZGVmaW5lZCcpXG4gICAgICAgICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZShwLCBwcm9wc1twXSk7XG4gICAgfVxuICAgIC8vIHRoZXNlIHRhZ3Mgc2hvdWxkIG5vdCBiZSBlc2NhcGVkIGJ5IGRlZmF1bHQgKGluIHNzcilcbiAgICBjb25zdCBlc2NhcGUgPSAhWydub3NjcmlwdCcsICdzY3JpcHQnLCAnc3R5bGUnXS5pbmNsdWRlcyh0YWdOYW1lT3JDb21wb25lbnQpO1xuICAgICgwLCBleHBvcnRzLmFwcGVuZENoaWxkcmVuKShlbGVtZW50LCBjaGlsZHJlbiwgZXNjYXBlKTtcbiAgICBpZiAocmVmKVxuICAgICAgICByZWYoZWxlbWVudCk7XG4gICAgcmV0dXJuIGVsZW1lbnQ7XG59O1xuZXhwb3J0cy5oID0gaDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvcmUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmRlZmluZUFzQ3VzdG9tRWxlbWVudHMgPSB2b2lkIDA7XG5jb25zdCBjb3JlX2pzXzEgPSByZXF1aXJlKFwiLi9jb3JlLmpzXCIpO1xuY29uc3QgZGVmaW5lQXNDdXN0b21FbGVtZW50c1NTUiA9IChjb21wb25lbnQsIGNvbXBvbmVudE5hbWUsIF9wdWJsaWNQcm9wcyA9IFtdLCBfb3B0aW9ucyA9IHt9KSA9PiB7XG4gICAgaWYgKCEvXlthLXpBLVowLTldKy1bYS16QS1aMC05XSskLy50ZXN0KGNvbXBvbmVudE5hbWUpKVxuICAgICAgICBjb25zb2xlLmxvZyhgRXJyb3I6IFdlYkNvbXBvbmVudCBuYW1lIFwiJHtjb21wb25lbnROYW1lfVwiIGlzIGludmFsaWQuYCk7XG4gICAgZWxzZVxuICAgICAgICBfbmFuby5jdXN0b21FbGVtZW50cy5zZXQoY29tcG9uZW50TmFtZSwgY29tcG9uZW50KTtcbn07XG5jb25zdCBkZWZpbmVBc0N1c3RvbUVsZW1lbnRzID0gZnVuY3Rpb24gKGNvbXBvbmVudCwgY29tcG9uZW50TmFtZSwgcHVibGljUHJvcHMsIHNoYWRvdykge1xuICAgIGlmICgoMCwgY29yZV9qc18xLmlzU1NSKSgpKSB7XG4gICAgICAgIGRlZmluZUFzQ3VzdG9tRWxlbWVudHNTU1IoY29tcG9uZW50LCBjb21wb25lbnROYW1lLCBwdWJsaWNQcm9wcyk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY3VzdG9tRWxlbWVudHMuZGVmaW5lKGNvbXBvbmVudE5hbWUsIGNsYXNzIGV4dGVuZHMgSFRNTEVsZW1lbnQge1xuICAgICAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgICAgIHN1cGVyKCk7XG4gICAgICAgICAgICBpZiAoc2hhZG93KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hdHRhY2hTaGFkb3coc2hhZG93KTtcbiAgICAgICAgICAgICAgICB0aGlzLiRyb290ID0gdGhpcy5zaGFkb3dSb290O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy4kcm9vdCA9IHRoaXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgcmVmO1xuICAgICAgICAgICAgY29uc3QgZWwgPSB0aGlzLmJ1aWxkRWwoKDAsIGNvcmVfanNfMS5fcmVuZGVyKSh7XG4gICAgICAgICAgICAgICAgY29tcG9uZW50LFxuICAgICAgICAgICAgICAgIHByb3BzOiB7XG4gICAgICAgICAgICAgICAgICAgIHJlZjogKHIpID0+IChyZWYgPSByKSxcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW46IEFycmF5LmZyb20odGhpcy5jaGlsZHJlbikubWFwKGMgPT4gKDAsIGNvcmVfanNfMS5yZW5kZXIpKGMpKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBmaXJzdCByZW5kZXJcbiAgICAgICAgICAgIHRoaXMuY29tcG9uZW50ID0gcmVmO1xuICAgICAgICAgICAgdGhpcy5pc0Z1bmN0aW9uYWxDb21wb25lbnQgPSAhY29tcG9uZW50LmlzQ2xhc3M7XG4gICAgICAgICAgICB0aGlzLmZ1bmN0aW9uYWxDb21wb25lbnRzUHJvcHMgPSB7fTtcbiAgICAgICAgICAgIHRoaXMuYXBwZW5kRWwoZWwpO1xuICAgICAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgICAgICBpZiAoIXRoaXMuaXNGdW5jdGlvbmFsQ29tcG9uZW50KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jb21wb25lbnQudXBkYXRlUHJvcHNWYWx1ZSA9IChuYW1lLCB2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5jb21wb25lbnQucHJvcHMpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbXBvbmVudC5wcm9wcyA9IHt9O1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbXBvbmVudC5wcm9wc1tuYW1lXSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbXBvbmVudFtuYW1lXSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGljIGdldCBvYnNlcnZlZEF0dHJpYnV0ZXMoKSB7XG4gICAgICAgICAgICByZXR1cm4gcHVibGljUHJvcHM7XG4gICAgICAgIH1cbiAgICAgICAgYnVpbGRFbChjb250ZW50cykge1xuICAgICAgICAgICAgLy8gYmVjYXVzZSBuYW5vLWpzeCB1cGRhdGUgbmVlZHMgcGFyZW50RWxlbWVudCwgd2UgbmVlZFxuICAgICAgICAgICAgLy8gdG8gd3JhcCB0aGUgZWxlbWVudCBpbiBhIGRpdiB3aGVuIHVzaW5nIHNoYWRvdyBtb2RlXG4gICAgICAgICAgICByZXR1cm4gKDAsIGNvcmVfanNfMS5oKSh0aGlzLnNoYWRvd1Jvb3QgPyAnZGl2JyA6ICd0ZW1wbGF0ZScsIG51bGwsIGNvbnRlbnRzKTtcbiAgICAgICAgfVxuICAgICAgICBhcHBlbmRFbChlbCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuc2hhZG93Um9vdCkge1xuICAgICAgICAgICAgICAgIC8vIGVsLmRhdGFzZXQud2NSb290ID0gdHJ1ZVxuICAgICAgICAgICAgICAgIHRoaXMuJHJvb3QuYXBwZW5kKGVsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuJHJvb3QuYXBwZW5kKC4uLmVsLmNoaWxkTm9kZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJlbW92ZUNoaWxkcmVuKCkge1xuICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgaWYgKHRoaXMuJHJvb3QpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjaGlsZHJlbiA9IEFycmF5LmZyb20oKF9hID0gdGhpcy4kcm9vdCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNoaWxkcmVuKSB8fCBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGVsIG9mIGNoaWxkcmVuKSB7XG4gICAgICAgICAgICAgICAgICAgIGVsLnJlbW92ZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2sobmFtZSwgXywgbmV3VmFsdWUpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5pc0Z1bmN0aW9uYWxDb21wb25lbnQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbXBvbmVudC51cGRhdGVQcm9wc1ZhbHVlKG5hbWUsIG5ld1ZhbHVlKTtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbXBvbmVudC51cGRhdGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlQ2hpbGRyZW4oKTtcbiAgICAgICAgICAgICAgICB0aGlzLmZ1bmN0aW9uYWxDb21wb25lbnRzUHJvcHNbbmFtZV0gPSBuZXdWYWx1ZTtcbiAgICAgICAgICAgICAgICBjb25zdCBlbCA9IHRoaXMuYnVpbGRFbCgoMCwgY29yZV9qc18xLl9yZW5kZXIpKHtcbiAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50LFxuICAgICAgICAgICAgICAgICAgICBwcm9wczogT2JqZWN0LmFzc2lnbih7IGNoaWxkcmVuOiBbXSwgcmVmOiAocikgPT4gKHRoaXMuY29tcG9uZW50ID0gcikgfSwgdGhpcy5mdW5jdGlvbmFsQ29tcG9uZW50c1Byb3BzKVxuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICB0aGlzLmFwcGVuZEVsKGVsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xufTtcbmV4cG9ydHMuZGVmaW5lQXNDdXN0b21FbGVtZW50cyA9IGRlZmluZUFzQ3VzdG9tRWxlbWVudHM7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jdXN0b21FbGVtZW50c01vZGUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkZyYWdtZW50ID0gdm9pZCAwO1xuY29uc3QgRnJhZ21lbnQgPSAocHJvcHMpID0+IHtcbiAgICByZXR1cm4gcHJvcHMuY2hpbGRyZW47XG59O1xuZXhwb3J0cy5GcmFnbWVudCA9IEZyYWdtZW50O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZnJhZ21lbnQuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnByaW50VmVyc2lvbiA9IGV4cG9ydHMuZXNjYXBlSHRtbCA9IGV4cG9ydHMub25Ob2RlUmVtb3ZlID0gZXhwb3J0cy5kZXRlY3RTU1IgPSBleHBvcnRzLm5vZGVUb1N0cmluZyA9IGV4cG9ydHMudGFzayA9IHZvaWQgMDtcbmNvbnN0IHZlcnNpb25fanNfMSA9IHJlcXVpcmUoXCIuL3ZlcnNpb24uanNcIik7XG4vKiogQ3JlYXRlcyBhIG5ldyBUYXNrIHVzaW5nIHNldFRpbWVvdXQoKSAqL1xuY29uc3QgdGFzayA9ICh0YXNrKSA9PiBzZXRUaW1lb3V0KHRhc2ssIDApO1xuZXhwb3J0cy50YXNrID0gdGFzaztcbmNvbnN0IG5vZGVUb1N0cmluZyA9IChub2RlKSA9PiB7XG4gICAgY29uc3QgdG1wTm9kZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIHRtcE5vZGUuYXBwZW5kQ2hpbGQobm9kZS5jbG9uZU5vZGUodHJ1ZSkpO1xuICAgIHJldHVybiB0bXBOb2RlLmlubmVySFRNTDtcbn07XG5leHBvcnRzLm5vZGVUb1N0cmluZyA9IG5vZGVUb1N0cmluZztcbmNvbnN0IGRldGVjdFNTUiA9ICgpID0+IHtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgY29uc3QgaXNEZW5vID0gdHlwZW9mIERlbm8gIT09ICd1bmRlZmluZWQnO1xuICAgIGNvbnN0IGhhc1dpbmRvdyA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gdHJ1ZSA6IGZhbHNlO1xuICAgIHJldHVybiAodHlwZW9mIF9uYW5vICE9PSAndW5kZWZpbmVkJyAmJiBfbmFuby5pc1NTUikgfHwgaXNEZW5vIHx8ICFoYXNXaW5kb3c7XG59O1xuZXhwb3J0cy5kZXRlY3RTU1IgPSBkZXRlY3RTU1I7XG5mdW5jdGlvbiBpc0Rlc2NlbmRhbnQoZGVzYywgcm9vdCkge1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICByZXR1cm4gISFkZXNjICYmIChkZXNjID09PSByb290IHx8IGlzRGVzY2VuZGFudChkZXNjLnBhcmVudE5vZGUsIHJvb3QpKTtcbn1cbi8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9NdXRhdGlvbk9ic2VydmVyXG5jb25zdCBvbk5vZGVSZW1vdmUgPSAoZWxlbWVudCwgY2FsbGJhY2spID0+IHtcbiAgICBsZXQgb2JzZXJ2ZXIgPSBuZXcgTXV0YXRpb25PYnNlcnZlcihtdXRhdGlvbnNMaXN0ID0+IHtcbiAgICAgICAgbXV0YXRpb25zTGlzdC5mb3JFYWNoKG11dGF0aW9uID0+IHtcbiAgICAgICAgICAgIG11dGF0aW9uLnJlbW92ZWROb2Rlcy5mb3JFYWNoKHJlbW92ZWQgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChpc0Rlc2NlbmRhbnQoZWxlbWVudCwgcmVtb3ZlZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9ic2VydmVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBhbGxvdyBnYXJiYWdlIGNvbGxlY3Rpb25cbiAgICAgICAgICAgICAgICAgICAgICAgIG9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgICAgICAgICAgICAgIG9ic2VydmVyID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH0pO1xuICAgIG9ic2VydmVyLm9ic2VydmUoZG9jdW1lbnQsIHtcbiAgICAgICAgY2hpbGRMaXN0OiB0cnVlLFxuICAgICAgICBzdWJ0cmVlOiB0cnVlXG4gICAgfSk7XG4gICAgcmV0dXJuIG9ic2VydmVyO1xufTtcbmV4cG9ydHMub25Ob2RlUmVtb3ZlID0gb25Ob2RlUmVtb3ZlO1xuLy8gaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzYyMzQ4MDRcbmNvbnN0IGVzY2FwZUh0bWwgPSAodW5zYWZlKSA9PiB7XG4gICAgaWYgKHVuc2FmZSAmJiB0eXBlb2YgdW5zYWZlID09PSAnc3RyaW5nJylcbiAgICAgICAgcmV0dXJuIHVuc2FmZVxuICAgICAgICAgICAgLnJlcGxhY2UoLyYvZywgJyZhbXA7JylcbiAgICAgICAgICAgIC5yZXBsYWNlKC88L2csICcmbHQ7JylcbiAgICAgICAgICAgIC5yZXBsYWNlKC8+L2csICcmZ3Q7JylcbiAgICAgICAgICAgIC5yZXBsYWNlKC9cIi9nLCAnJnF1b3Q7JylcbiAgICAgICAgICAgIC5yZXBsYWNlKC8nL2csICcmYXBvczsnKTtcbiAgICByZXR1cm4gdW5zYWZlO1xufTtcbmV4cG9ydHMuZXNjYXBlSHRtbCA9IGVzY2FwZUh0bWw7XG5jb25zdCBwcmludFZlcnNpb24gPSAoKSA9PiB7XG4gICAgY29uc3QgaW5mbyA9IGBQb3dlcmVkIGJ5IG5hbm8gSlNYIHYke3ZlcnNpb25fanNfMS5WRVJTSU9OfWA7XG4gICAgY29uc29sZS5sb2coYCVjICVjICVjICVjICVjICR7aW5mb30gJWMgaHR0cDovL25hbm9qc3guaW9gLCAnYmFja2dyb3VuZDogI2ZmMDAwMCcsICdiYWNrZ3JvdW5kOiAjZmZmZjAwJywgJ2JhY2tncm91bmQ6ICMwMGZmMDAnLCAnYmFja2dyb3VuZDogIzAwZmZmZicsICdjb2xvcjogI2ZmZjsgYmFja2dyb3VuZDogIzAwMDAwMDsnLCAnYmFja2dyb3VuZDogbm9uZScpO1xufTtcbmV4cG9ydHMucHJpbnRWZXJzaW9uID0gcHJpbnRWZXJzaW9uO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aGVscGVycy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IGluZGV4X2pzXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vaHRtL2luZGV4LmpzXCIpKTtcbmV4cG9ydHMuZGVmYXVsdCA9IGluZGV4X2pzXzEuZGVmYXVsdDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWh0bS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuYnVpbGQgPSBleHBvcnRzLmV2YWx1YXRlID0gZXhwb3J0cy50cmVlaWZ5ID0gdm9pZCAwO1xuY29uc3QgY29uc3RhbnRzX2pzXzEgPSByZXF1aXJlKFwiLi9jb25zdGFudHMuanNcIik7XG5jb25zdCBNT0RFX1NMQVNIID0gMDtcbmNvbnN0IE1PREVfVEVYVCA9IDE7XG5jb25zdCBNT0RFX1dISVRFU1BBQ0UgPSAyO1xuY29uc3QgTU9ERV9UQUdOQU1FID0gMztcbmNvbnN0IE1PREVfQ09NTUVOVCA9IDQ7XG5jb25zdCBNT0RFX1BST1BfU0VUID0gNTtcbmNvbnN0IE1PREVfUFJPUF9BUFBFTkQgPSA2O1xuY29uc3QgQ0hJTERfQVBQRU5EID0gMDtcbmNvbnN0IENISUxEX1JFQ1VSU0UgPSAyO1xuY29uc3QgVEFHX1NFVCA9IDM7XG5jb25zdCBQUk9QU19BU1NJR04gPSA0O1xuY29uc3QgUFJPUF9TRVQgPSBNT0RFX1BST1BfU0VUO1xuY29uc3QgUFJPUF9BUFBFTkQgPSBNT0RFX1BST1BfQVBQRU5EO1xuLy8gVHVybiBhIHJlc3VsdCBvZiBhIGJ1aWxkKC4uLikgY2FsbCBpbnRvIGEgdHJlZSB0aGF0IGlzIG1vcmVcbi8vIGNvbnZlbmllbnQgdG8gYW5hbHl6ZSBhbmQgdHJhbnNmb3JtIChlLmcuIEJhYmVsIHBsdWdpbnMpLlxuLy8gRm9yIGV4YW1wbGU6XG4vLyBcdHRyZWVpZnkoXG4vL1x0XHRidWlsZCc8ZGl2IGhyZWY9XCIxJHthfVwiIC4uLiR7Yn0+PCR7eH0gLz48L2Rpdj5gLFxuLy9cdFx0W1gsIFksIFpdXG4vL1x0KVxuLy8gcmV0dXJuczpcbi8vIFx0e1xuLy8gXHRcdHRhZzogJ2RpdicsXG4vL1x0XHRwcm9wczogWyB7IGhyZWY6IFtcIjFcIiwgWF0gfSxcdFkgXSxcbi8vIFx0XHRjaGlsZHJlbjogWyB7IHRhZzogWiwgcHJvcHM6IFtdLCBjaGlsZHJlbjogW10gfSBdXG4vLyBcdH1cbmNvbnN0IHRyZWVpZnkgPSAoYnVpbHQsIGZpZWxkcykgPT4ge1xuICAgIGNvbnN0IF90cmVlaWZ5ID0gKGJ1aWx0KSA9PiB7XG4gICAgICAgIGxldCB0YWcgPSAnJztcbiAgICAgICAgbGV0IGN1cnJlbnRQcm9wcyA9IG51bGw7XG4gICAgICAgIGNvbnN0IHByb3BzID0gW107XG4gICAgICAgIGNvbnN0IGNoaWxkcmVuID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgYnVpbHQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHR5cGUgPSBidWlsdFtpKytdO1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBidWlsdFtpXSA/IGZpZWxkc1tidWlsdFtpKytdIC0gMV0gOiBidWlsdFsrK2ldO1xuICAgICAgICAgICAgaWYgKHR5cGUgPT09IFRBR19TRVQpIHtcbiAgICAgICAgICAgICAgICB0YWcgPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGUgPT09IFBST1BTX0FTU0lHTikge1xuICAgICAgICAgICAgICAgIHByb3BzLnB1c2godmFsdWUpO1xuICAgICAgICAgICAgICAgIGN1cnJlbnRQcm9wcyA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlID09PSBQUk9QX1NFVCkge1xuICAgICAgICAgICAgICAgIGlmICghY3VycmVudFByb3BzKSB7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRQcm9wcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgICAgICAgICAgICAgIHByb3BzLnB1c2goY3VycmVudFByb3BzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY3VycmVudFByb3BzW2J1aWx0WysraV1dID0gW3ZhbHVlXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGUgPT09IFBST1BfQVBQRU5EKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFByb3BzW2J1aWx0WysraV1dLnB1c2godmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZSA9PT0gQ0hJTERfUkVDVVJTRSkge1xuICAgICAgICAgICAgICAgIGNoaWxkcmVuLnB1c2goX3RyZWVpZnkodmFsdWUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGUgPT09IENISUxEX0FQUEVORCkge1xuICAgICAgICAgICAgICAgIGNoaWxkcmVuLnB1c2godmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IHRhZywgcHJvcHMsIGNoaWxkcmVuIH07XG4gICAgfTtcbiAgICBjb25zdCB7IGNoaWxkcmVuIH0gPSBfdHJlZWlmeShidWlsdCk7XG4gICAgcmV0dXJuIGNoaWxkcmVuLmxlbmd0aCA+IDEgPyBjaGlsZHJlbiA6IGNoaWxkcmVuWzBdO1xufTtcbmV4cG9ydHMudHJlZWlmeSA9IHRyZWVpZnk7XG5jb25zdCBldmFsdWF0ZSA9IChoLCBidWlsdCwgZmllbGRzLCBhcmdzKSA9PiB7XG4gICAgbGV0IHRtcDtcbiAgICAvLyBgYnVpbGQoKWAgdXNlZCB0aGUgZmlyc3QgZWxlbWVudCBvZiB0aGUgb3BlcmF0aW9uIGxpc3QgYXNcbiAgICAvLyB0ZW1wb3Jhcnkgd29ya3NwYWNlLiBOb3cgdGhhdCBgYnVpbGQoKWAgaXMgZG9uZSB3ZSBjYW4gdXNlXG4gICAgLy8gdGhhdCBzcGFjZSB0byB0cmFjayB3aGV0aGVyIHRoZSBjdXJyZW50IGVsZW1lbnQgaXMgXCJkeW5hbWljXCJcbiAgICAvLyAoaS5lLiBpdCBvciBhbnkgb2YgaXRzIGRlc2NlbmRhbnRzIGRlcGVuZCBvbiBkeW5hbWljIHZhbHVlcykuXG4gICAgYnVpbHRbMF0gPSAwO1xuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgYnVpbHQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgdHlwZSA9IGJ1aWx0W2krK107XG4gICAgICAgIC8vIFNldCBgYnVpbHRbMF1gJ3MgYXBwcm9wcmlhdGUgYml0cyBpZiB0aGlzIGVsZW1lbnQgZGVwZW5kcyBvbiBhIGR5bmFtaWMgdmFsdWUuXG4gICAgICAgIGNvbnN0IHZhbHVlID0gYnVpbHRbaV0gPyAoKGJ1aWx0WzBdIHw9IHR5cGUgPyAxIDogMiksIGZpZWxkc1tidWlsdFtpKytdXSkgOiBidWlsdFsrK2ldO1xuICAgICAgICBpZiAodHlwZSA9PT0gVEFHX1NFVCkge1xuICAgICAgICAgICAgYXJnc1swXSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGUgPT09IFBST1BTX0FTU0lHTikge1xuICAgICAgICAgICAgYXJnc1sxXSA9IE9iamVjdC5hc3NpZ24oYXJnc1sxXSB8fCB7fSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGUgPT09IFBST1BfU0VUKSB7XG4gICAgICAgICAgICA7XG4gICAgICAgICAgICAoYXJnc1sxXSA9IGFyZ3NbMV0gfHwge30pW2J1aWx0WysraV1dID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZSA9PT0gUFJPUF9BUFBFTkQpIHtcbiAgICAgICAgICAgIGFyZ3NbMV1bYnVpbHRbKytpXV0gKz0gYCR7dmFsdWV9YDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlKSB7XG4gICAgICAgICAgICAvLyB0eXBlID09PSBDSElMRF9SRUNVUlNFXG4gICAgICAgICAgICAvLyBTZXQgdGhlIG9wZXJhdGlvbiBsaXN0IChpbmNsdWRpbmcgdGhlIHN0YXRpY25lc3MgYml0cykgYXNcbiAgICAgICAgICAgIC8vIGB0aGlzYCBmb3IgdGhlIGBoYCBjYWxsLlxuICAgICAgICAgICAgdG1wID0gaC5hcHBseSh2YWx1ZSwgKDAsIGV4cG9ydHMuZXZhbHVhdGUpKGgsIHZhbHVlLCBmaWVsZHMsIFsnJywgbnVsbF0pKTtcbiAgICAgICAgICAgIGFyZ3MucHVzaCh0bXApO1xuICAgICAgICAgICAgaWYgKHZhbHVlWzBdKSB7XG4gICAgICAgICAgICAgICAgLy8gU2V0IHRoZSAybmQgbG93ZXN0IGJpdCBpdCB0aGUgY2hpbGQgZWxlbWVudCBpcyBkeW5hbWljLlxuICAgICAgICAgICAgICAgIGJ1aWx0WzBdIHw9IDI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBSZXdyaXRlIHRoZSBvcGVyYXRpb24gbGlzdCBpbi1wbGFjZSBpZiB0aGUgY2hpbGQgZWxlbWVudCBpcyBzdGF0aWMuXG4gICAgICAgICAgICAgICAgLy8gVGhlIGN1cnJlbnRseSBldmFsdWF0ZWQgcGllY2UgYENISUxEX1JFQ1VSU0UsIDAsIFsuLi5dYCBiZWNvbWVzXG4gICAgICAgICAgICAgICAgLy8gYENISUxEX0FQUEVORCwgMCwgdG1wYC5cbiAgICAgICAgICAgICAgICAvLyBFc3NlbnRpYWxseSB0aGUgb3BlcmF0aW9uIGxpc3QgZ2V0cyBvcHRpbWl6ZWQgZm9yIHBvdGVudGlhbCBmdXR1cmVcbiAgICAgICAgICAgICAgICAvLyByZS1ldmFsdWF0aW9ucy5cbiAgICAgICAgICAgICAgICBidWlsdFtpIC0gMl0gPSBDSElMRF9BUFBFTkQ7XG4gICAgICAgICAgICAgICAgYnVpbHRbaV0gPSB0bXA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyB0eXBlID09PSBDSElMRF9BUFBFTkRcbiAgICAgICAgICAgIGFyZ3MucHVzaCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGFyZ3M7XG59O1xuZXhwb3J0cy5ldmFsdWF0ZSA9IGV2YWx1YXRlO1xuY29uc3QgYnVpbGQgPSBmdW5jdGlvbiAoc3RhdGljcywgLi4ucmVzdCkge1xuICAgIGNvbnN0IGZpZWxkcyA9IFtzdGF0aWNzLCAuLi5yZXN0XTtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgY29uc3QgaCA9IHRoaXM7XG4gICAgbGV0IG1vZGUgPSBNT0RFX1RFWFQ7XG4gICAgbGV0IGJ1ZmZlciA9ICcnO1xuICAgIGxldCBxdW90ZSA9ICcnO1xuICAgIGxldCBjdXJyZW50ID0gWzBdO1xuICAgIGxldCBjaGFyO1xuICAgIGxldCBwcm9wTmFtZTtcbiAgICBjb25zdCBjb21taXQgPSAoZmllbGQpID0+IHtcbiAgICAgICAgaWYgKG1vZGUgPT09IE1PREVfVEVYVCAmJiAoZmllbGQgfHwgKGJ1ZmZlciA9IGJ1ZmZlci5yZXBsYWNlKC9eXFxzKlxcblxccyp8XFxzKlxcblxccyokL2csICcnKSkpKSB7XG4gICAgICAgICAgICBpZiAoY29uc3RhbnRzX2pzXzEuTUlOSSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnQucHVzaChmaWVsZCA/IGZpZWxkc1tmaWVsZF0gOiBidWZmZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY3VycmVudC5wdXNoKENISUxEX0FQUEVORCwgZmllbGQsIGJ1ZmZlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobW9kZSA9PT0gTU9ERV9UQUdOQU1FICYmIChmaWVsZCB8fCBidWZmZXIpKSB7XG4gICAgICAgICAgICBpZiAoY29uc3RhbnRzX2pzXzEuTUlOSSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRbMV0gPSBmaWVsZCA/IGZpZWxkc1tmaWVsZF0gOiBidWZmZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50LnB1c2goVEFHX1NFVCwgZmllbGQsIGJ1ZmZlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBtb2RlID0gTU9ERV9XSElURVNQQUNFO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG1vZGUgPT09IE1PREVfV0hJVEVTUEFDRSAmJiBidWZmZXIgPT09ICcuLi4nICYmIGZpZWxkKSB7XG4gICAgICAgICAgICBpZiAoY29uc3RhbnRzX2pzXzEuTUlOSSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRbMl0gPSBPYmplY3QuYXNzaWduKGN1cnJlbnRbMl0gfHwge30sIGZpZWxkc1tmaWVsZF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY3VycmVudC5wdXNoKFBST1BTX0FTU0lHTiwgZmllbGQsIDApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG1vZGUgPT09IE1PREVfV0hJVEVTUEFDRSAmJiBidWZmZXIgJiYgIWZpZWxkKSB7XG4gICAgICAgICAgICBpZiAoY29uc3RhbnRzX2pzXzEuTUlOSSkge1xuICAgICAgICAgICAgICAgIDtcbiAgICAgICAgICAgICAgICAoY3VycmVudFsyXSA9IGN1cnJlbnRbMl0gfHwge30pW2J1ZmZlcl0gPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY3VycmVudC5wdXNoKFBST1BfU0VULCAwLCB0cnVlLCBidWZmZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG1vZGUgPj0gTU9ERV9QUk9QX1NFVCkge1xuICAgICAgICAgICAgaWYgKGNvbnN0YW50c19qc18xLk1JTkkpIHtcbiAgICAgICAgICAgICAgICBpZiAobW9kZSA9PT0gTU9ERV9QUk9QX1NFVCkge1xuICAgICAgICAgICAgICAgICAgICA7XG4gICAgICAgICAgICAgICAgICAgIChjdXJyZW50WzJdID0gY3VycmVudFsyXSB8fCB7fSlbcHJvcE5hbWVdID0gZmllbGRcbiAgICAgICAgICAgICAgICAgICAgICAgID8gYnVmZmVyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBidWZmZXIgKyBmaWVsZHNbZmllbGRdXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBmaWVsZHNbZmllbGRdXG4gICAgICAgICAgICAgICAgICAgICAgICA6IGJ1ZmZlcjtcbiAgICAgICAgICAgICAgICAgICAgbW9kZSA9IE1PREVfUFJPUF9BUFBFTkQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGZpZWxkIHx8IGJ1ZmZlcikge1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50WzJdW3Byb3BOYW1lXSArPSBmaWVsZCA/IGJ1ZmZlciArIGZpZWxkc1tmaWVsZF0gOiBidWZmZXI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKGJ1ZmZlciB8fCAoIWZpZWxkICYmIG1vZGUgPT09IE1PREVfUFJPUF9TRVQpKSB7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnQucHVzaChtb2RlLCAwLCBidWZmZXIsIHByb3BOYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgbW9kZSA9IE1PREVfUFJPUF9BUFBFTkQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChmaWVsZCkge1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50LnB1c2gobW9kZSwgZmllbGQsIDAsIHByb3BOYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgbW9kZSA9IE1PREVfUFJPUF9BUFBFTkQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGJ1ZmZlciA9ICcnO1xuICAgIH07XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdGF0aWNzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChpKSB7XG4gICAgICAgICAgICBpZiAobW9kZSA9PT0gTU9ERV9URVhUKSB7XG4gICAgICAgICAgICAgICAgY29tbWl0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb21taXQoaSk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBzdGF0aWNzW2ldLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICBjaGFyID0gc3RhdGljc1tpXVtqXTtcbiAgICAgICAgICAgIGlmIChtb2RlID09PSBNT0RFX1RFWFQpIHtcbiAgICAgICAgICAgICAgICBpZiAoY2hhciA9PT0gJzwnKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGNvbW1pdCBidWZmZXJcbiAgICAgICAgICAgICAgICAgICAgY29tbWl0KCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb25zdGFudHNfanNfMS5NSU5JKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50ID0gW2N1cnJlbnQsICcnLCBudWxsXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnQgPSBbY3VycmVudF07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbW9kZSA9IE1PREVfVEFHTkFNRTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGJ1ZmZlciArPSBjaGFyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG1vZGUgPT09IE1PREVfQ09NTUVOVCkge1xuICAgICAgICAgICAgICAgIC8vIElnbm9yZSBldmVyeXRoaW5nIHVudGlsIHRoZSBsYXN0IHRocmVlIGNoYXJhY3RlcnMgYXJlICctJywgJy0nIGFuZCAnPidcbiAgICAgICAgICAgICAgICBpZiAoYnVmZmVyID09PSAnLS0nICYmIGNoYXIgPT09ICc+Jykge1xuICAgICAgICAgICAgICAgICAgICBtb2RlID0gTU9ERV9URVhUO1xuICAgICAgICAgICAgICAgICAgICBidWZmZXIgPSAnJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGJ1ZmZlciA9IGNoYXIgKyBidWZmZXJbMF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocXVvdGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoY2hhciA9PT0gcXVvdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcXVvdGUgPSAnJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGJ1ZmZlciArPSBjaGFyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoYXIgPT09ICdcIicgfHwgY2hhciA9PT0gXCInXCIpIHtcbiAgICAgICAgICAgICAgICBxdW90ZSA9IGNoYXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGFyID09PSAnPicpIHtcbiAgICAgICAgICAgICAgICBjb21taXQoKTtcbiAgICAgICAgICAgICAgICBtb2RlID0gTU9ERV9URVhUO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoIW1vZGUpIHtcbiAgICAgICAgICAgICAgICAvLyBJZ25vcmUgZXZlcnl0aGluZyB1bnRpbCB0aGUgdGFnIGVuZHNcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoYXIgPT09ICc9Jykge1xuICAgICAgICAgICAgICAgIG1vZGUgPSBNT0RFX1BST1BfU0VUO1xuICAgICAgICAgICAgICAgIHByb3BOYW1lID0gYnVmZmVyO1xuICAgICAgICAgICAgICAgIGJ1ZmZlciA9ICcnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hhciA9PT0gJy8nICYmIChtb2RlIDwgTU9ERV9QUk9QX1NFVCB8fCBzdGF0aWNzW2ldW2ogKyAxXSA9PT0gJz4nKSkge1xuICAgICAgICAgICAgICAgIGNvbW1pdCgpO1xuICAgICAgICAgICAgICAgIGlmIChtb2RlID09PSBNT0RFX1RBR05BTUUpIHtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudCA9IGN1cnJlbnRbMF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG1vZGUgPSBjdXJyZW50O1xuICAgICAgICAgICAgICAgIGlmIChjb25zdGFudHNfanNfMS5NSU5JKSB7XG4gICAgICAgICAgICAgICAgICAgIDtcbiAgICAgICAgICAgICAgICAgICAgKGN1cnJlbnQgPSBjdXJyZW50WzBdKS5wdXNoKGgoLi4ubW9kZS5zbGljZSgxKSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgO1xuICAgICAgICAgICAgICAgICAgICAoY3VycmVudCA9IGN1cnJlbnRbMF0pLnB1c2goQ0hJTERfUkVDVVJTRSwgMCwgbW9kZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG1vZGUgPSBNT0RFX1NMQVNIO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hhciA9PT0gJyAnIHx8IGNoYXIgPT09ICdcXHQnIHx8IGNoYXIgPT09ICdcXG4nIHx8IGNoYXIgPT09ICdcXHInKSB7XG4gICAgICAgICAgICAgICAgLy8gPGEgZGlzYWJsZWQ+XG4gICAgICAgICAgICAgICAgY29tbWl0KCk7XG4gICAgICAgICAgICAgICAgbW9kZSA9IE1PREVfV0hJVEVTUEFDRTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGJ1ZmZlciArPSBjaGFyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1vZGUgPT09IE1PREVfVEFHTkFNRSAmJiBidWZmZXIgPT09ICchLS0nKSB7XG4gICAgICAgICAgICAgICAgbW9kZSA9IE1PREVfQ09NTUVOVDtcbiAgICAgICAgICAgICAgICBjdXJyZW50ID0gY3VycmVudFswXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBjb21taXQoKTtcbiAgICBpZiAoY29uc3RhbnRzX2pzXzEuTUlOSSkge1xuICAgICAgICByZXR1cm4gY3VycmVudC5sZW5ndGggPiAyID8gY3VycmVudC5zbGljZSgxKSA6IGN1cnJlbnRbMV07XG4gICAgfVxuICAgIHJldHVybiBjdXJyZW50O1xufTtcbmV4cG9ydHMuYnVpbGQgPSBidWlsZDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJ1aWxkLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5NSU5JID0gdm9pZCAwO1xuZXhwb3J0cy5NSU5JID0gZmFsc2U7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb25zdGFudHMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIENvcHlyaWdodCAyMDE4IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBjb25zdGFudHNfanNfMSA9IHJlcXVpcmUoXCIuL2NvbnN0YW50cy5qc1wiKTtcbmNvbnN0IGJ1aWxkX2pzXzEgPSByZXF1aXJlKFwiLi9idWlsZC5qc1wiKTtcbmNvbnN0IENBQ0hFUyA9IG5ldyBNYXAoKTtcbmNvbnN0IHJlZ3VsYXIgPSBmdW5jdGlvbiAoc3RhdGljcykge1xuICAgIGxldCB0bXAgPSBDQUNIRVMuZ2V0KHRoaXMpO1xuICAgIGlmICghdG1wKSB7XG4gICAgICAgIHRtcCA9IG5ldyBNYXAoKTtcbiAgICAgICAgQ0FDSEVTLnNldCh0aGlzLCB0bXApO1xuICAgIH1cbiAgICB0bXAgPSAoMCwgYnVpbGRfanNfMS5ldmFsdWF0ZSkodGhpcywgdG1wLmdldChzdGF0aWNzKSB8fCAodG1wLnNldChzdGF0aWNzLCAodG1wID0gKDAsIGJ1aWxkX2pzXzEuYnVpbGQpKHN0YXRpY3MpKSksIHRtcCksIGFyZ3VtZW50cywgW10pO1xuICAgIHJldHVybiB0bXAubGVuZ3RoID4gMSA/IHRtcCA6IHRtcFswXTtcbn07XG4vLyBleHBvcnQgYXMgaHRtXG5leHBvcnRzLmRlZmF1bHQgPSBjb25zdGFudHNfanNfMS5NSU5JID8gYnVpbGRfanNfMS5idWlsZCA6IHJlZ3VsYXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuanN4ID0gdm9pZCAwO1xuY29uc3QgY29yZV9qc18xID0gcmVxdWlyZShcIi4vY29yZS5qc1wiKTtcbmNvbnN0IGh0bV9qc18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL2h0bS5qc1wiKSk7XG5jb25zdCBqc3ggPSBodG1fanNfMS5kZWZhdWx0LmJpbmQoY29yZV9qc18xLmgpO1xuZXhwb3J0cy5qc3ggPSBqc3g7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1qc3guanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmh5ZHJhdGVMYXp5ID0gdm9pZCAwO1xuY29uc3QgY29yZV9qc18xID0gcmVxdWlyZShcIi4vY29yZS5qc1wiKTtcbmNvbnN0IHZpc2libGVfanNfMSA9IHJlcXVpcmUoXCIuL2NvbXBvbmVudHMvdmlzaWJsZS5qc1wiKTtcbmNvbnN0IGh5ZHJhdGVMYXp5ID0gKGNvbXBvbmVudCwgcGFyZW50ID0gbnVsbCwgcmVtb3ZlQ2hpbGROb2RlcyA9IHRydWUpID0+IHtcbiAgICBjb25zdCBjID0gKDAsIGNvcmVfanNfMS5oKSh2aXNpYmxlX2pzXzEuVmlzaWJsZSwgbnVsbCwgY29tcG9uZW50KTtcbiAgICByZXR1cm4gKDAsIGNvcmVfanNfMS5oeWRyYXRlKShjLCBwYXJlbnQsIHJlbW92ZUNoaWxkTm9kZXMpO1xufTtcbmV4cG9ydHMuaHlkcmF0ZUxhenkgPSBoeWRyYXRlTGF6eTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxhenkuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLl9jbGVhclN0YXRlID0gZXhwb3J0cy5fc3RhdGUgPSB2b2lkIDA7XG4vKiogSG9sZHMgdGhlIHN0YXRlIG9mIHRoZSB3aG9sZSBhcHBsaWNhdGlvbi4gKi9cbmV4cG9ydHMuX3N0YXRlID0gbmV3IE1hcCgpO1xuLyoqIENsZWFycyB0aGUgc3RhdGUgb2YgdGhlIHdob2xlIGFwcGxpY2F0aW9uLiAqL1xuY29uc3QgX2NsZWFyU3RhdGUgPSAoKSA9PiB7XG4gICAgZXhwb3J0cy5fc3RhdGUuY2xlYXIoKTtcbn07XG5leHBvcnRzLl9jbGVhclN0YXRlID0gX2NsZWFyU3RhdGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zdGF0ZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuU3RvcmUgPSB2b2lkIDA7XG5jb25zdCBjb3JlX2pzXzEgPSByZXF1aXJlKFwiLi9jb3JlLmpzXCIpO1xuY2xhc3MgU3RvcmUge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZSB5b3VyIG93biBTdG9yZS5cbiAgICAgKiBAcGFyYW0gZGVmYXVsdFN0YXRlIFBhc3MgdGhlIGluaXRpYWwgU3RhdGUuXG4gICAgICogQHBhcmFtIG5hbWUgVGhlIG5hbWUgb2YgdGhlIFN0b3JlIChvbmx5IHJlcXVpcmVkIGlmIHlvdSBwZXJzaXN0IHRoZSBzdGF0ZSBpbiBsb2NhbFN0b3JhZ2Ugb3Igc2Vzc2lvblN0b3JhZ2UpLlxuICAgICAqIEBwYXJhbSBzdG9yYWdlIFBhc3MgJ21lbW9yeScsICdsb2NhbCcgb3IgJ3Nlc3Npb24nLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGRlZmF1bHRTdGF0ZSwgbmFtZSA9ICcnLCBzdG9yYWdlID0gJ21lbW9yeScpIHtcbiAgICAgICAgdGhpcy5fbGlzdGVuZXJzID0gbmV3IE1hcCgpO1xuICAgICAgICBpZiAoKDAsIGNvcmVfanNfMS5pc1NTUikoKSlcbiAgICAgICAgICAgIHN0b3JhZ2UgPSAnbWVtb3J5JztcbiAgICAgICAgdGhpcy5faWQgPSBuYW1lO1xuICAgICAgICB0aGlzLl9zdG9yYWdlID0gc3RvcmFnZTtcbiAgICAgICAgdGhpcy5fc3RhdGUgPSB0aGlzLl9wcmV2U3RhdGUgPSBkZWZhdWx0U3RhdGU7XG4gICAgICAgIGlmIChzdG9yYWdlID09PSAnbWVtb3J5JyB8fCAhc3RvcmFnZSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc3QgU3RvcmFnZSA9IHN0b3JhZ2UgPT09ICdsb2NhbCcgPyBsb2NhbFN0b3JhZ2UgOiBzZXNzaW9uU3RvcmFnZTtcbiAgICAgICAgLy8gZ2V0L3NldCBpbml0aWFsIHN0YXRlIG9mIFN0b3JhZ2VcbiAgICAgICAgY29uc3QgaXRlbSA9IFN0b3JhZ2UuZ2V0SXRlbSh0aGlzLl9pZCk7XG4gICAgICAgIGlmIChpdGVtKSB7XG4gICAgICAgICAgICB0aGlzLl9zdGF0ZSA9IHRoaXMuX3ByZXZTdGF0ZSA9IEpTT04ucGFyc2UoaXRlbSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgU3RvcmFnZS5zZXRJdGVtKHRoaXMuX2lkLCBKU09OLnN0cmluZ2lmeShkZWZhdWx0U3RhdGUpKTtcbiAgICB9XG4gICAgcGVyc2lzdChuZXdTdGF0ZSkge1xuICAgICAgICBpZiAodGhpcy5fc3RvcmFnZSA9PT0gJ21lbW9yeScpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNvbnN0IFN0b3JhZ2UgPSB0aGlzLl9zdG9yYWdlID09PSAnbG9jYWwnID8gbG9jYWxTdG9yYWdlIDogc2Vzc2lvblN0b3JhZ2U7XG4gICAgICAgIFN0b3JhZ2Uuc2V0SXRlbSh0aGlzLl9pZCwgSlNPTi5zdHJpbmdpZnkobmV3U3RhdGUpKTtcbiAgICB9XG4gICAgLyoqIENsZWFycyB0aGUgc3RhdGUgb2YgdGhlIHdob2xlIHN0b3JlLiAqL1xuICAgIGNsZWFyKCkge1xuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIHRoaXMuX3N0YXRlID0gdGhpcy5fcHJldlN0YXRlID0gdW5kZWZpbmVkO1xuICAgICAgICBpZiAodGhpcy5fc3RvcmFnZSA9PT0gJ2xvY2FsJylcbiAgICAgICAgICAgIGxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKHRoaXMuX2lkKTtcbiAgICAgICAgZWxzZSBpZiAodGhpcy5fc3RvcmFnZSA9PT0gJ3Nlc3Npb24nKVxuICAgICAgICAgICAgc2Vzc2lvblN0b3JhZ2UucmVtb3ZlSXRlbSh0aGlzLl9pZCk7XG4gICAgfVxuICAgIHNldFN0YXRlKG5ld1N0YXRlKSB7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBuZXdTdGF0ZTtcbiAgICB9XG4gICAgc2V0IHN0YXRlKG5ld1N0YXRlKSB7XG4gICAgICAgIHRoaXMuX3ByZXZTdGF0ZSA9IHRoaXMuX3N0YXRlO1xuICAgICAgICB0aGlzLl9zdGF0ZSA9IG5ld1N0YXRlO1xuICAgICAgICB0aGlzLnBlcnNpc3QobmV3U3RhdGUpO1xuICAgICAgICB0aGlzLl9saXN0ZW5lcnMuZm9yRWFjaChmbmMgPT4ge1xuICAgICAgICAgICAgZm5jKHRoaXMuX3N0YXRlLCB0aGlzLl9wcmV2U3RhdGUpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZ2V0IHN0YXRlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc3RhdGU7XG4gICAgfVxuICAgIHVzZSgpIHtcbiAgICAgICAgY29uc3QgaWQgPSBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zdWJzdHJpbmcoMiwgOSk7XG4gICAgICAgIGNvbnN0IF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGdldCBzdGF0ZSgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuc3RhdGU7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2V0U3RhdGU6IChuZXdTdGF0ZSkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBuZXdTdGF0ZTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzdWJzY3JpYmU6IChmbmMpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLl9saXN0ZW5lcnMuc2V0KGlkLCBmbmMpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNhbmNlbDogKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9saXN0ZW5lcnMuaGFzKGlkKSlcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbGlzdGVuZXJzLmRlbGV0ZShpZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxufVxuZXhwb3J0cy5TdG9yZSA9IFN0b3JlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c3RvcmUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vLyBmaXhlcyBhbiBpc3N1ZSBpbiBzdGRAMC44MC4wIChkZW5vKVxuLy8gaW50ZXJmYWNlIFJlYWRhYmxlU3RyZWFtPFI+IHtcbi8vICAgZ2V0SXRlcmF0b3IoKTogYW55XG4vLyB9XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD10eXBlcy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuekluZGV4ID0gZXhwb3J0cy5yaXBwbGVFZmZlY3QgPSBleHBvcnRzLnVzZXJTZWxlY3QgPSBleHBvcnRzLmJveFNoYWRvdyA9IHZvaWQgMDtcbmNvbnN0IGNvcmVfanNfMSA9IHJlcXVpcmUoXCIuLi9jb3JlLmpzXCIpO1xuZXhwb3J0cy5ib3hTaGFkb3cgPSBgXHJcbiAgLXdlYmtpdC1ib3gtc2hhZG93OiAwcHggM3B4IDVweCAtMXB4IHJnYmEoMCwwLDAsMC4yKSwgMHB4IDZweCAxMHB4IDBweCByZ2JhKDAsMCwwLDAuMTQpLCAwcHggMXB4IDE4cHggMHB4IHJnYmEoMCwwLDAsMC4xMik7XHJcbiAgLW1vei1ib3gtc2hhZG93OiAwcHggM3B4IDVweCAtMXB4IHJnYmEoMCwwLDAsMC4yKSwgMHB4IDZweCAxMHB4IDBweCByZ2JhKDAsMCwwLDAuMTQpLCAwcHggMXB4IDE4cHggMHB4IHJnYmEoMCwwLDAsMC4xMik7XHJcbiAgYm94LXNoYWRvdzogMHB4IDNweCA1cHggLTFweCByZ2JhKDAsMCwwLDAuMiksIDBweCA2cHggMTBweCAwcHggcmdiYSgwLDAsMCwwLjE0KSwgMHB4IDFweCAxOHB4IDBweCByZ2JhKDAsMCwwLDAuMTIpO1xyXG5gO1xuZXhwb3J0cy51c2VyU2VsZWN0ID0gYFxyXG4gIC13ZWJraXQtdG91Y2gtY2FsbG91dDpub25lO1xyXG4gIC13ZWJraXQtdXNlci1zZWxlY3Q6bm9uZTtcclxuICAta2h0bWwtdXNlci1zZWxlY3Q6bm9uZTtcclxuICAtbW96LXVzZXItc2VsZWN0Om5vbmU7XHJcbiAgLW1zLXVzZXItc2VsZWN0Om5vbmU7XHJcbiAgdXNlci1zZWxlY3Q6bm9uZTtcclxuICAtd2Via2l0LXRhcC1oaWdobGlnaHQtY29sb3I6cmdiYSgwLDAsMCwwKTtcclxuYDtcbmNvbnN0IHJpcHBsZUVmZmVjdCA9IChyaXBwbGVDbHIsIGhvdmVyQ2xyKSA9PiB7XG4gICAgY29uc3QgcmlwcGxlQ2xhc3MgPSBgcmlwcGxlLSR7KDAsIGNvcmVfanNfMS5zdHJUb0hhc2gpKHJpcHBsZUNsciArIGhvdmVyQ2xyKX1gO1xuICAgIGNvbnN0IHN0eWxlcyA9IGAgIFxyXG4gIC4ke3JpcHBsZUNsYXNzfSB7XHJcbiAgICBiYWNrZ3JvdW5kLXBvc2l0aW9uOiBjZW50ZXI7XHJcbiAgICB0cmFuc2l0aW9uOiBiYWNrZ3JvdW5kIDAuOHM7XHJcbiAgfVxyXG4gIFxyXG4gIC4ke3JpcHBsZUNsYXNzfTpob3ZlciB7XHJcbiAgICBiYWNrZ3JvdW5kOiAke2hvdmVyQ2xyfSByYWRpYWwtZ3JhZGllbnQoY2lyY2xlLCB0cmFuc3BhcmVudCAxJSwgJHtob3ZlckNscn0gMSUpIGNlbnRlci8xNTAwMCU7XHJcbiAgfVxyXG5cclxuICAuJHtyaXBwbGVDbGFzc306Zm9jdXMge1xyXG4gICAgYmFja2dyb3VuZDogJHtob3ZlckNscn0gcmFkaWFsLWdyYWRpZW50KGNpcmNsZSwgdHJhbnNwYXJlbnQgMSUsICR7aG92ZXJDbHJ9IDElKSBjZW50ZXIvMTUwMDAlO1xyXG4gIH1cclxuICBcclxuICAuJHtyaXBwbGVDbGFzc306YWN0aXZlIHtcclxuICAgIGJhY2tncm91bmQtY29sb3I6ICR7cmlwcGxlQ2xyfTtcclxuICAgIGJhY2tncm91bmQtc2l6ZTogMTAwJTtcclxuICAgIHRyYW5zaXRpb246IGJhY2tncm91bmQgMHM7XHJcbiAgfWA7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgc3R5bGVzLFxuICAgICAgICBjbGFzczogcmlwcGxlQ2xhc3NcbiAgICB9O1xufTtcbmV4cG9ydHMucmlwcGxlRWZmZWN0ID0gcmlwcGxlRWZmZWN0O1xuZXhwb3J0cy56SW5kZXggPSB7XG4gICAgYnV0dG9uOiAndW5zZXQ7JyxcbiAgICBiYW5uZXI6ICc1MDsnLFxuICAgIGJhcjogJzEwMDsnLFxuICAgIG5hdmlnYXRpb246ICcxMDA7JyxcbiAgICBmYWI6ICcyMDA7JyxcbiAgICBzaGVldDogJzMwMDsnLFxuICAgIG1lbnU6ICc0MDA7JyxcbiAgICBzbmFja2JhcjogJzUwMDsnLFxuICAgIGRpYWxvZzogJzYwMDsnXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9X2NvbmZpZy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuYWRkU3R5bGVzVG9IZWFkID0gZXhwb3J0cy5saWdodGVuQ29sb3IgPSB2b2lkIDA7XG5jb25zdCBjb3JlX2pzXzEgPSByZXF1aXJlKFwiLi4vY29yZS5qc1wiKTtcbi8vIGh0dHBzOi8vZ2lzdC5naXRodWIuY29tL3JlbmFuY291dG8vNDY3NTE5MlxuY29uc3QgbGlnaHRlbkNvbG9yID0gKGNvbG9yLCBwZXJjZW50KSA9PiB7XG4gICAgY29uc3QgbnVtID0gcGFyc2VJbnQoY29sb3IucmVwbGFjZSgnIycsICcnKSwgMTYpLCBhbXQgPSBNYXRoLnJvdW5kKDIuNTUgKiBwZXJjZW50KSwgUiA9IChudW0gPj4gMTYpICsgYW10LCBCID0gKChudW0gPj4gOCkgJiAweDAwZmYpICsgYW10LCBHID0gKG51bSAmIDB4MDAwMGZmKSArIGFtdDtcbiAgICByZXR1cm4gYCMkeygweDEwMDAwMDAgK1xuICAgICAgICAoUiA8IDI1NSA/IChSIDwgMSA/IDAgOiBSKSA6IDI1NSkgKiAweDEwMDAwICtcbiAgICAgICAgKEIgPCAyNTUgPyAoQiA8IDEgPyAwIDogQikgOiAyNTUpICogMHgxMDAgK1xuICAgICAgICAoRyA8IDI1NSA/IChHIDwgMSA/IDAgOiBHKSA6IDI1NSkpXG4gICAgICAgIC50b1N0cmluZygxNilcbiAgICAgICAgLnNsaWNlKDEpfWA7XG59O1xuZXhwb3J0cy5saWdodGVuQ29sb3IgPSBsaWdodGVuQ29sb3I7XG5jb25zdCBhZGRTdHlsZXNUb0hlYWQgPSAoc3R5bGVzLCBoYXNoKSA9PiB7XG4gICAgY29uc3QgZWwgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKGBbZGF0YS1jc3MtaGFzaCo9XCIke2hhc2h9XCJdYCk7XG4gICAgaWYgKCFlbCkge1xuICAgICAgICBjb25zdCBzdHlsZUVsZW1lbnQgPSAoMCwgY29yZV9qc18xLmgpKCdzdHlsZScsIHsgJ2RhdGEtY3NzLWhhc2gnOiBoYXNoIH0sIHN0eWxlcyk7XG4gICAgICAgIGRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQoc3R5bGVFbGVtZW50KTtcbiAgICB9XG59O1xuZXhwb3J0cy5hZGRTdHlsZXNUb0hlYWQgPSBhZGRTdHlsZXNUb0hlYWQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1faGVscGVycy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQXBwQmFyID0gdm9pZCAwO1xuY29uc3QgY29tcG9uZW50X2pzXzEgPSByZXF1aXJlKFwiLi4vY29tcG9uZW50LmpzXCIpO1xuY29uc3QgY29yZV9qc18xID0gcmVxdWlyZShcIi4uL2NvcmUuanNcIik7XG5jb25zdCBfY29uZmlnX2pzXzEgPSByZXF1aXJlKFwiLi9fY29uZmlnLmpzXCIpO1xuY29uc3QgY2xhc3NlcyA9IHtcbiAgICBjb250YWluZXI6ICdhcHBCYXJfY29udGFpbmVyJyxcbiAgICBzY3JvbGxpbmdEb3duOiAnYXBwQmFyX3Njcm9sbGluZ19kb3duJ1xufTtcbmNsYXNzIEFwcEJhciBleHRlbmRzIGNvbXBvbmVudF9qc18xLkNvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMuY3Vycl9zY3JvbGxZID0gMDtcbiAgICAgICAgdGhpcy5sYXN0X3Njcm9sbFkgPSAwO1xuICAgICAgICB0aGlzLmN1cnJfc2Nyb2xsaW5nU3RhdGUgPSAnbm9uZSc7XG4gICAgICAgIHRoaXMubGFzdF9zY3JvbGxpbmdTdGF0ZSA9ICdub25lJztcbiAgICB9XG4gICAgY2FsY1Njcm9sbFBvc2l0aW9uKCkge1xuICAgICAgICB0aGlzLmN1cnJfc2Nyb2xsWSA9IHdpbmRvdy5zY3JvbGxZO1xuICAgICAgICBpZiAodGhpcy5jdXJyX3Njcm9sbFkgPiB0aGlzLmxhc3Rfc2Nyb2xsWSkge1xuICAgICAgICAgICAgdGhpcy5jdXJyX3Njcm9sbGluZ1N0YXRlID0gJ2Rvd24nO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuY3Vycl9zY3JvbGxZIDwgdGhpcy5sYXN0X3Njcm9sbFkpIHtcbiAgICAgICAgICAgIHRoaXMuY3Vycl9zY3JvbGxpbmdTdGF0ZSA9ICd1cCc7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5sYXN0X3Njcm9sbFkgPSB0aGlzLmN1cnJfc2Nyb2xsWTtcbiAgICB9XG4gICAgc2Nyb2xsKCkge1xuICAgICAgICB0aGlzLmNhbGNTY3JvbGxQb3NpdGlvbigpO1xuICAgICAgICBpZiAodGhpcy5jdXJyX3Njcm9sbFkgPCAxKSB7XG4gICAgICAgICAgICB0aGlzLmNvbnRhaW5lci5jbGFzc0xpc3QucmVtb3ZlKCdhcHBCYXJfc2Nyb2xsaW5nX2Rvd24nKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLmxhc3Rfc2Nyb2xsaW5nU3RhdGUgIT09IHRoaXMuY3Vycl9zY3JvbGxpbmdTdGF0ZSkge1xuICAgICAgICAgICAgdGhpcy5sYXN0X3Njcm9sbGluZ1N0YXRlID0gdGhpcy5jdXJyX3Njcm9sbGluZ1N0YXRlO1xuICAgICAgICAgICAgaWYgKHRoaXMuY3Vycl9zY3JvbGxpbmdTdGF0ZSA9PT0gJ2Rvd24nKVxuICAgICAgICAgICAgICAgIHRoaXMuY29udGFpbmVyLmNsYXNzTGlzdC5hZGQoJ2FwcEJhcl9zY3JvbGxpbmdfZG93bicpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHRoaXMuY29udGFpbmVyLmNsYXNzTGlzdC5yZW1vdmUoJ2FwcEJhcl9zY3JvbGxpbmdfZG93bicpO1xuICAgICAgICB9XG4gICAgfVxuICAgIG1lcmdlKCkge1xuICAgICAgICB0aGlzLmNhbGNTY3JvbGxQb3NpdGlvbigpO1xuICAgICAgICBpZiAodGhpcy5jdXJyX3Njcm9sbFkgPD0gMSkge1xuICAgICAgICAgICAgdGhpcy5jb250YWluZXIuY2xhc3NMaXN0LmFkZCgnYXBwQmFyX21lcmdlZCcpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5jb250YWluZXIuY2xhc3NMaXN0LnJlbW92ZSgnYXBwQmFyX21lcmdlZCcpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGRpZE1vdW50KCkge1xuICAgICAgICB0aGlzLmN1cnJfc2Nyb2xsWSA9IHRoaXMubGFzdF9zY3JvbGxZID0gd2luZG93LnNjcm9sbFk7XG4gICAgICAgIGlmICh0aGlzLnByb3BzLmF1dG9IaWRlKVxuICAgICAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsICgpID0+IHRoaXMuc2Nyb2xsKCkpO1xuICAgICAgICBpZiAodGhpcy5wcm9wcy5hdXRvTWVyZ2UpXG4gICAgICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgKCkgPT4gdGhpcy5tZXJnZSgpKTtcbiAgICB9XG4gICAgZGlkVW5tb3VudCgpIHtcbiAgICAgICAgaWYgKHRoaXMucHJvcHMuYXV0b0hpZGUpXG4gICAgICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgdGhpcy5zY3JvbGwpO1xuICAgICAgICBpZiAodGhpcy5wcm9wcy5hdXRvTWVyZ2UpXG4gICAgICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgKCkgPT4gdGhpcy5tZXJnZSgpKTtcbiAgICB9XG4gICAgcmVuZGVyKCkge1xuICAgICAgICBjb25zdCB7IGJhY2tncm91bmQgPSAnIzYyMDBFRScsIGNvbG9yID0gJ3doaXRlJyB9ID0gdGhpcy5wcm9wcztcbiAgICAgICAgY29uc3Qgc3R5bGVzID0gYFxyXG4gICAgLmFwcEJhcl9jb250YWluZXIge1xyXG4gICAgICBiYWNrZ3JvdW5kOiAke2JhY2tncm91bmR9O1xyXG4gICAgICBjb2xvcjogJHtjb2xvcn07XHJcbiAgICAgIGZvbnQtd2VpZ2h0OiA1MDA7XHJcblxyXG4gICAgICB6LWluZGV4OiAke19jb25maWdfanNfMS56SW5kZXguYmFyfVxyXG5cclxuICAgICAgcG9zaXRpb246IGZpeGVkO1xyXG4gICAgICB0b3A6IDA7XHJcbiAgICAgIGxlZnQ6IDA7XHJcbiAgICAgIG1pbi1oZWlnaHQ6IDI0cHg7XHJcbiAgICAgIHdpZHRoOiAxMDB2dztcclxuXHJcblxyXG4gICAgICAke19jb25maWdfanNfMS5ib3hTaGFkb3d9XHJcblxyXG4gICAgICB0cmFuc2l0aW9uOiB0b3AgMC4ycywgLXdlYmtpdC1ib3gtc2hhZG93IDAuNXMsIC1tb3otYm94LXNoYWRvdyAwLjVzLCBib3gtc2hhZG93IDAuNXM7XHJcbiAgICB9XHJcblxyXG4gICAgLmFwcEJhcl9jb250YWluZXIuYXBwQmFyX3Njcm9sbGluZ19kb3duIHtcclxuICAgICAgdG9wOiAtNTZweDtcclxuICAgIH1cclxuXHJcbiAgICAuYXBwQmFyX2NvbnRhaW5lci5hcHBCYXJfbWVyZ2VkIHtcclxuICAgICAgLXdlYmtpdC1ib3gtc2hhZG93OiBub25lO1xyXG4gICAgICAtbW96LWJveC1zaGFkb3c6IG5vbmU7XHJcbiAgICAgIGJveC1zaGFkb3c6IG5vbmU7XHJcbiAgICB9XHJcblxyXG4gICAgLmFwcEJhcl9jb250YWluZXIgLnRvb2xiYXJfY29udGFpbmVyIHtcclxuICAgICAgZGlzcGxheTogZmxleDtcclxuICAgICAganVzdGlmeS1jb250ZW50OiBzcGFjZS1iZXR3ZWVuO1xyXG4gICAgfVxyXG5cclxuICAgIC5hcHBCYXJfY29udGFpbmVyIC50b29sYmFyX2NvbnRhaW5lcixcclxuICAgIC5hcHBCYXJfY29udGFpbmVyIC50YWJzX2NvbnRhaW5lciB7XHJcbiAgICAgIG1hcmdpbjogMCBhdXRvO1xyXG4gICAgICAke3RoaXMucHJvcHMubWF4V2lkdGggPyBgbWF4LXdpZHRoOiAke3RoaXMucHJvcHMubWF4V2lkdGh9cHg7YCA6ICcnfVxyXG4gICAgfVxyXG5cclxuICAgIC5hcHBCYXJfY29udGFpbmVyIC50b29sYmFyX2NvbnRhaW5lciAudG9vbGJhcl9sZWZ0LFxyXG4gICAgLmFwcEJhcl9jb250YWluZXIgLnRvb2xiYXJfY29udGFpbmVyIC50b29sYmFyX3JpZ2h0IHtcclxuICAgICAgZGlzcGxheTogZmxleDtcclxuICAgICAgYWxpZ24taXRlbXM6IGNlbnRlcjsgICAgICBcclxuICAgIH1cclxuXHJcbiAgICAuYXBwQmFyX2NvbnRhaW5lciAudG9vbGJhcl9jb250YWluZXIgLnRvb2xiYXJfbGVmdCB7XHJcbiAgICAgIHdoaXRlLXNwYWNlOiBub3dyYXA7XHJcbiAgICAgIG92ZXJmbG93OiBoaWRkZW47XHJcbiAgICAgIHRleHQtb3ZlcmZsb3c6IGVsbGlwc2lzO1xyXG4gICAgfVxyXG5cclxuICAgIC5hcHBCYXJfY29udGFpbmVyIC50b29sYmFyX3RpdGxlIHtcclxuICAgICAgZm9udC1zaXplOiAyMHB4O1xyXG4gICAgICB3aGl0ZS1zcGFjZTogbm93cmFwO1xyXG4gICAgICBvdmVyZmxvdzogaGlkZGVuO1xyXG4gICAgICB0ZXh0LW92ZXJmbG93OiBlbGxpcHNpcztcclxuICAgIH1cclxuICAgIGA7XG4gICAgICAgIGRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQoKDAsIGNvcmVfanNfMS5oKSgnc3R5bGUnLCB7fSwgc3R5bGVzKSk7XG4gICAgICAgIGNvbnN0IG1lcmdlZENsYXNzID0gdGhpcy5wcm9wcy5hdXRvTWVyZ2UgPyAnYXBwQmFyX21lcmdlZCcgOiAnJztcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICB0aGlzLmNvbnRhaW5lciA9ICgwLCBjb3JlX2pzXzEuaCkoJ2RpdicsIHsgY2xhc3M6IGAke2NsYXNzZXMuY29udGFpbmVyfSAke21lcmdlZENsYXNzfWAgfSwgdGhpcy5wcm9wcy5jaGlsZHJlbik7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnRhaW5lcjtcbiAgICB9XG59XG5leHBvcnRzLkFwcEJhciA9IEFwcEJhcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFwcEJhci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX3Jlc3QgPSAodGhpcyAmJiB0aGlzLl9fcmVzdCkgfHwgZnVuY3Rpb24gKHMsIGUpIHtcbiAgICB2YXIgdCA9IHt9O1xuICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSAmJiBlLmluZGV4T2YocCkgPCAwKVxuICAgICAgICB0W3BdID0gc1twXTtcbiAgICBpZiAocyAhPSBudWxsICYmIHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzID09PSBcImZ1bmN0aW9uXCIpXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBwID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhzKTsgaSA8IHAubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChlLmluZGV4T2YocFtpXSkgPCAwICYmIE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChzLCBwW2ldKSlcbiAgICAgICAgICAgICAgICB0W3BbaV1dID0gc1twW2ldXTtcbiAgICAgICAgfVxuICAgIHJldHVybiB0O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQnV0dG9uID0gdm9pZCAwO1xuY29uc3QgY29yZV9qc18xID0gcmVxdWlyZShcIi4uL2NvcmUuanNcIik7XG5jb25zdCBfY29uZmlnX2pzXzEgPSByZXF1aXJlKFwiLi9fY29uZmlnLmpzXCIpO1xuY29uc3QgX2hlbHBlcnNfanNfMSA9IHJlcXVpcmUoXCIuL19oZWxwZXJzLmpzXCIpO1xuY29uc3QgaWNvbl9qc18xID0gcmVxdWlyZShcIi4vaWNvbi5qc1wiKTtcbmNvbnN0IEJ1dHRvbiA9IChwcm9wcykgPT4ge1xuICAgIGNvbnN0IHsgY2hpbGRyZW4sIG91dGxpbmVkID0gZmFsc2UsIHRleHQgPSBmYWxzZSwgYmFja2dyb3VuZCA9ICcjNjIwMGVlJywgY29sb3IgPSAnI2ZmZmZmZicsIHN0eWxlID0gJycsIGNsYXNzOiBjbGFzc05hbWUgPSAnJywgaWNvbiB9ID0gcHJvcHMsIHJlc3QgPSBfX3Jlc3QocHJvcHMsIFtcImNoaWxkcmVuXCIsIFwib3V0bGluZWRcIiwgXCJ0ZXh0XCIsIFwiYmFja2dyb3VuZFwiLCBcImNvbG9yXCIsIFwic3R5bGVcIiwgXCJjbGFzc1wiLCBcImljb25cIl0pO1xuICAgIGNvbnN0IG5vcm1hbCA9ICEob3V0bGluZWQgfHwgdGV4dCk7XG4gICAgY29uc3QgYmcgPSBub3JtYWwgPyBiYWNrZ3JvdW5kIDogJyNmZmZmZmYnO1xuICAgIGNvbnN0IGNsciA9IG5vcm1hbCA/IGNvbG9yIDogYmFja2dyb3VuZDtcbiAgICBjb25zdCBob3ZlckNsciA9IG5vcm1hbCA/ICgwLCBfaGVscGVyc19qc18xLmxpZ2h0ZW5Db2xvcikoYmcsIDEwKSA6ICgwLCBfaGVscGVyc19qc18xLmxpZ2h0ZW5Db2xvcikoYmcsIC0xMCk7XG4gICAgY29uc3QgcmlwcGxlQ2xyID0gbm9ybWFsID8gKDAsIF9oZWxwZXJzX2pzXzEubGlnaHRlbkNvbG9yKShiZywgNTApIDogKDAsIF9oZWxwZXJzX2pzXzEubGlnaHRlbkNvbG9yKShiYWNrZ3JvdW5kLCA1MCk7XG4gICAgY29uc3QgY3NzSGFzaCA9ICgwLCBjb3JlX2pzXzEuc3RyVG9IYXNoKShvdXRsaW5lZC50b1N0cmluZygpICsgdGV4dC50b1N0cmluZygpICsgYmcgKyBjbHIgKyBzdHlsZSk7XG4gICAgY29uc3QgcmlwcGxlID0gKDAsIF9jb25maWdfanNfMS5yaXBwbGVFZmZlY3QpKHJpcHBsZUNsciwgaG92ZXJDbHIpO1xuICAgIGNvbnN0IHN0eWxlcyA9IGBcclxuICAgIC5uYW5vX2pzeF9idXR0b24tJHtjc3NIYXNofSB7XHJcbiAgICAgIGNvbG9yOiAke2Nscn07XHJcbiAgICAgIGJhY2tncm91bmQ6ICR7Ymd9O1xyXG4gICAgICBib3JkZXItcmFkaXVzOiA0cHg7XHJcbiAgICAgIGRpc3BsYXk6IGlubGluZS1mbGV4O1xyXG4gICAgICBmb250LXNpemU6IDE0cHg7XHJcbiAgICAgIHBhZGRpbmc6IDEwcHggMTZweDtcclxuICAgICAgbWFyZ2luOiAwcHggMHB4IDFlbSAwcHg7XHJcbiAgICAgIHRleHQtYWxpZ246IGNlbnRlcjtcclxuICAgICAgY3Vyc29yOiBwb2ludGVyO1xyXG5cclxuICAgICAgJHtfY29uZmlnX2pzXzEudXNlclNlbGVjdH1cclxuICAgICAgXHJcblxyXG4gICAgICB6LWluZGV4OiAke19jb25maWdfanNfMS56SW5kZXguYnV0dG9ufVxyXG5cclxuICAgICAgJHtfY29uZmlnX2pzXzEuYm94U2hhZG93fVxyXG5cclxuICAgICAgYm9yZGVyOiBub25lO1xyXG4gICAgICB0ZXh0LXRyYW5zZm9ybTogdXBwZXJjYXNlO1xyXG4gICAgICBib3gtc2hhZG93OiAwIDAgNHB4ICM5OTk7XHJcbiAgICAgIG91dGxpbmU6IG5vbmU7XHJcbiAgICB9XHJcblxyXG4gICAgJHtyaXBwbGUuc3R5bGVzfVxyXG4gIGA7XG4gICAgKDAsIF9oZWxwZXJzX2pzXzEuYWRkU3R5bGVzVG9IZWFkKShzdHlsZXMsIGNzc0hhc2gpO1xuICAgIGxldCBjdXN0b21TdHlsZXMgPSAnJztcbiAgICBpZiAob3V0bGluZWQgfHwgdGV4dCkge1xuICAgICAgICBjdXN0b21TdHlsZXMgKz0gJ3BhZGRpbmctdG9wOiA5cHg7IHBhZGRpbmctYm90dG9tOiA5cHg7ICc7XG4gICAgICAgIGN1c3RvbVN0eWxlcyArPSAnLXdlYmtpdC1ib3gtc2hhZG93OiBub25lOyAtbW96LWJveC1zaGFkb3c6IG5vbmU7IGJveC1zaGFkb3cgbm9uZTsgJztcbiAgICAgICAgaWYgKG91dGxpbmVkKVxuICAgICAgICAgICAgY3VzdG9tU3R5bGVzICs9IGBib3JkZXI6IDFweCAke2Nscn0gc29saWQ7IGA7XG4gICAgfVxuICAgIGN1c3RvbVN0eWxlcyArPSBzdHlsZTtcbiAgICByZXR1cm4gKDAsIGNvcmVfanNfMS5oKSgnYnV0dG9uJywgT2JqZWN0LmFzc2lnbih7IGNsYXNzOiBgbmFub19qc3hfYnV0dG9uLSR7Y3NzSGFzaH0gJHtyaXBwbGUuY2xhc3N9ICR7Y2xhc3NOYW1lfWAsIHN0eWxlOiBjdXN0b21TdHlsZXMgfSwgcmVzdCksIGljb24gPyAoMCwgY29yZV9qc18xLmgpKGljb25fanNfMS5JY29uLCB7IHN0eWxlOiAnbWFyZ2luLWxlZnQ6IC00cHg7IG1hcmdpbi1yaWdodDogOHB4OyB3aWR0aDogMTRweDsgaGVpZ2h0OiAxNHB4OycgfSwgaWNvbikgOiBudWxsLCBjaGlsZHJlbik7XG59O1xuZXhwb3J0cy5CdXR0b24gPSBCdXR0b247XG4vLyMgc291cmNlTWFwcGluZ1VSTD1idXR0b24uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkRpYWxvZyA9IHZvaWQgMDtcbmNvbnN0IGNvcmVfanNfMSA9IHJlcXVpcmUoXCIuLi9jb3JlLmpzXCIpO1xuY29uc3QgX2NvbmZpZ19qc18xID0gcmVxdWlyZShcIi4vX2NvbmZpZy5qc1wiKTtcbmNvbnN0IGJ1dHRvbl9qc18xID0gcmVxdWlyZShcIi4vYnV0dG9uLmpzXCIpO1xuY2xhc3MgRGlhbG9nIHtcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zID0ge30pIHtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICAgICAgdGhpcy5kZWZhdWx0UGFyZW50SWQgPSAnZGlhbG9nX2NvbnRhaW5lcic7XG4gICAgICAgIHRoaXMuZGVmYXVsdEFjdGlvbkNvbG9yID0gJyM2MjAwRUUnO1xuICAgICAgICBjb25zdCBkZWZhdWx0T3B0aW9ucyA9IHtcbiAgICAgICAgICAgIHRpdGxlOiAnRGlhbG9nIFRpdGxlJyxcbiAgICAgICAgICAgIGJvZHk6ICdEaWFsb2cgYm9keSB0ZXh0LicsXG4gICAgICAgICAgICBhY3Rpb25zOiBbXG4gICAgICAgICAgICAgICAgeyBuYW1lOiAnQWN0aW9uIDEnLCBjb2xvcjogdGhpcy5kZWZhdWx0QWN0aW9uQ29sb3IgfSxcbiAgICAgICAgICAgICAgICB7IG5hbWU6ICdBY3Rpb24gMicsIGNvbG9yOiB0aGlzLmRlZmF1bHRBY3Rpb25Db2xvciB9XG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgZmlyc3RGb2N1c0FjdGlvbjogZmFsc2VcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBkZWZhdWx0T3B0aW9ucyksIG9wdGlvbnMpO1xuICAgICAgICAvLyBzdHlsZXNcbiAgICAgICAgY29uc3Qgc3R5bGVzID0gYFxyXG4gICAgI2RpYWxvZ19jb250YWluZXIgeyAgXHJcbiAgICAgIGJhY2tncm91bmQ6ICMwMDAwMDA3MDtcclxuICAgICAgcG9zaXRpb246IGZpeGVkO1xyXG4gICAgICBib3R0b206IDBweDtcclxuICAgICAgbGVmdDogMHB4O1xyXG4gICAgICBkaXNwbGF5OiBmbGV4O1xyXG4gICAgICBhbGlnbi1pdGVtczogY2VudGVyO1xyXG4gICAgICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcclxuICAgICAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcclxuICAgICAgd2lkdGg6IDEwMHZ3O1xyXG4gICAgICBoZWlnaHQ6IDEwMHZoO1xyXG4gICAgICBvdmVyZmxvdzogaGlkZGVuO1xyXG4gICAgICBcclxuICAgICAgei1pbmRleDogJHtfY29uZmlnX2pzXzEuekluZGV4LmRpYWxvZ31cclxuXHJcbiAgICAgIGFuaW1hdGlvbi1uYW1lOiBkaWFsb2ctZmFkZWluO1xyXG4gICAgICBhbmltYXRpb24tZHVyYXRpb246IDAuMnM7XHJcblxyXG4gICAgICB0cmFuc2l0aW9uOiBvcGFjaXR5IDAuMnM7XHJcbiAgICAgIG9wYWNpdHk6IDE7XHJcbiAgICB9XHJcblxyXG4gICAgI2RpYWxvZ19jb250YWluZXIuZGlhbG9nX2ZhZGVvdXQge1xyXG4gICAgICBvcGFjaXR5OiAwO1xyXG4gICAgfSBcclxuXHJcbiAgICAjZGlhbG9nX2NvbnRhaW5lciAuZGlhbG9nIHtcclxuICAgICAgYmFja2dyb3VuZC1jb2xvcjogd2hpdGU7XHJcbiAgICAgIGJvcmRlci1yYWRpdXM6IDRweDtcclxuICAgICAgbWluLXdpZHRoOiAyNDBweDtcclxuICAgICAgbWF4LXdpZHRoOiBtaW4oNTAwcHgsIDgwJSk7XHJcblxyXG4gICAgICBtYXJnaW46IDhweDtcclxuXHJcbiAgICAgICR7X2NvbmZpZ19qc18xLmJveFNoYWRvd31cclxuICAgIH1cclxuXHJcbiAgICAjZGlhbG9nX2NvbnRhaW5lciAuZGlhbG9nIC5kaWFsb2dfaGVhZGVyIHtcclxuICAgICAgY29sb3I6ICMwMDAwMDBERTtcclxuICAgICAgZm9udC1zaXplOiAyMHB4O1xyXG4gICAgICBwYWRkaW5nOiAwcHggMjRweCA5cHg7XHJcbiAgICAgIG1hcmdpbjogMjRweCAwcHggNnB4IDBweDtcclxuICAgICAgbGluZS1oZWlnaHQ6IDE7XHJcbiAgICB9XHJcblxyXG4gICAgI2RpYWxvZ19jb250YWluZXIgLmRpYWxvZyAuZGlhbG9nX2JvZHkge1xyXG4gICAgICBjb2xvcjogIzAwMDAwMDk5O1xyXG4gICAgICBmb250LXNpemU6IDE2cHg7ICBcclxuICAgICAgcGFkZGluZzogMHB4IDI0cHggMjBweDtcclxuICAgICAgbGluZS1oZWlnaHQ6IDEuNWVtO1xyXG4gICAgfVxyXG5cclxuICAgICNkaWFsb2dfY29udGFpbmVyIC5kaWFsb2cgLmRpYWxvZ19hY3Rpb25zIHtcclxuICAgICAgXHJcbiAgICAgIG1hcmdpbjogMDtcclxuICAgICAgcGFkZGluZzogOHB4O1xyXG4gICAgICBcclxuICAgICAgZGlzcGxheTogZmxleDtcclxuICAgICAgZmxleC1kaXJlY3Rpb246IHJvdztcclxuICAgICAgYWxpZ24taXRlbXM6IGZsZXgtZW5kO1xyXG4gICAgICBmbG9hdDogcmlnaHQ7XHJcblxyXG4gICAgICBmbGV4LXdyYXA6IHdyYXA7XHJcbiAgICAgIGp1c3RpZnktY29udGVudDogZmxleC1lbmQ7XHJcbiAgICB9XHJcblxyXG4gICAgI2RpYWxvZ19jb250YWluZXIgLmRpYWxvZyAuZGlhbG9nX2FjdGlvbiB7XHJcbiAgICAgIG1hcmdpbi1ib3R0b206IDBweDtcclxuICAgICAgbWFyZ2luLWxlZnQ6IDEwcHg7XHJcbiAgICB9XHJcblxyXG4gICAgLyojZGlhbG9nX2NvbnRhaW5lciAuZGlhbG9nIC5kaWFsb2dfYWN0aW9uOmhvdmVyIHtcclxuICAgICAgYm9yZGVyLXJhZGl1czogNHB4OyAgICAgIFxyXG4gICAgICBiYWNrZ3JvdW5kOiAjMDAwMDAwMGE7XHJcbiAgICB9Ki9cclxuXHJcbiAgICBAa2V5ZnJhbWVzIGRpYWxvZy1mYWRlaW4ge1xyXG4gICAgICBmcm9tIHtvcGFjaXR5OiAwO31cclxuICAgICAgdG8ge29wYWNpdHk6IDE7fVxyXG4gICAgfVxyXG4gICAgYDtcbiAgICAgICAgZG9jdW1lbnQuaGVhZC5hcHBlbmRDaGlsZCgoMCwgY29yZV9qc18xLmgpKCdzdHlsZScsIHt9LCBzdHlsZXMpKTtcbiAgICAgICAgdGhpcy5oYW5kbGVLZXlkb3duID0gdGhpcy5oYW5kbGVLZXlkb3duLmJpbmQodGhpcyk7XG4gICAgfVxuICAgIGdldFBhcmVudEVsZW1lbnQocGFyZW50SWQpIHtcbiAgICAgICAgbGV0IGVsID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQocGFyZW50SWQgfHwgdGhpcy5kZWZhdWx0UGFyZW50SWQpO1xuICAgICAgICBpZiAoIWVsKSB7XG4gICAgICAgICAgICBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICAgICAgZWwuaWQgPSB0aGlzLmRlZmF1bHRQYXJlbnRJZDtcbiAgICAgICAgICAgIGVsLmFyaWFIaWRkZW4gPSAndHJ1ZSc7XG4gICAgICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGVsKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZWw7XG4gICAgfVxuICAgIGhhbmRsZUtleWRvd24oZXZlbnQpIHtcbiAgICAgICAgaWYgKGV2ZW50LmtleSA9PT0gJ0VzY2FwZScgfHwgZXZlbnQua2V5ID09PSAnRXNjJykge1xuICAgICAgICAgICAgdGhpcy5yZW1vdmUoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZXZlbnQua2V5ID09PSAnVGFiJykge1xuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIGNvbnN0IGFjdGlvbnMgPSBBcnJheS5mcm9tKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJy5kaWFsb2dfYWN0aW9uJykpO1xuICAgICAgICAgICAgaWYgKGFjdGlvbnMubGVuZ3RoIDwgMSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRGb2N1cyA9IGFjdGlvbnMuZmluZEluZGV4KGVsID0+IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgPT09IGVsKTtcbiAgICAgICAgICAgIGlmIChjdXJyZW50Rm9jdXMgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgYWN0aW9uc1swXS5mb2N1cygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbmV4dEZvY3VzID0gY3VycmVudEZvY3VzICsgKGV2ZW50LnNoaWZ0S2V5ID8gLTEgOiAxKTtcbiAgICAgICAgICAgIGlmIChuZXh0Rm9jdXMgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgYWN0aW9uc1thY3Rpb25zLmxlbmd0aCAtIDFdLmZvY3VzKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5leHRGb2N1cyA9PT0gYWN0aW9ucy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBhY3Rpb25zWzBdLmZvY3VzKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYWN0aW9uc1tuZXh0Rm9jdXNdLmZvY3VzKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVtb3ZlKCkge1xuICAgICAgICBjb25zdCBlbCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdkaWFsb2dfY29udGFpbmVyJyk7XG4gICAgICAgIGlmICghZWwpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGVsLmNsYXNzTGlzdC5hZGQoJ2RpYWxvZ19mYWRlb3V0Jyk7XG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgZWwucmVtb3ZlKCk7XG4gICAgICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIHRoaXMuaGFuZGxlS2V5ZG93bik7XG4gICAgICAgICAgICB0aGlzLmVuYWJsZVNjcm9sbCgpO1xuICAgICAgICB9LCAyMDApO1xuICAgIH1cbiAgICBkaXNhYmxlU2Nyb2xsKCkge1xuICAgICAgICBkb2N1bWVudC5ib2R5LnN0eWxlLm92ZXJmbG93ID0gJ2hpZGRlbic7XG4gICAgfVxuICAgIGVuYWJsZVNjcm9sbCgpIHtcbiAgICAgICAgLy8gZGVmYXVsdFxuICAgICAgICBkb2N1bWVudC5ib2R5LnN0eWxlLm92ZXJmbG93ID0gJyc7XG4gICAgfVxuICAgIGZvY3VzQWN0aW9uKGZvY3VzQWN0aW9uSWQsIGFjdGlvbnMpIHtcbiAgICAgICAgY29uc3QgYWN0aW9uRWxlbWVudHMgPSBBcnJheS5mcm9tKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJy5kaWFsb2dfYWN0aW9uJykpO1xuICAgICAgICBjb25zdCBmb2N1c1RhcmdldEluZGV4ID0gYWN0aW9ucy5maW5kSW5kZXgoYWN0aW9uID0+IGFjdGlvbi5pZCA9PT0gZm9jdXNBY3Rpb25JZCk7XG4gICAgICAgIGNvbnN0IGZvY3VzVGFyZ2V0ID0gYWN0aW9uRWxlbWVudHNbZm9jdXNUYXJnZXRJbmRleF07XG4gICAgICAgIGlmIChmb2N1c1RhcmdldCkge1xuICAgICAgICAgICAgZm9jdXNUYXJnZXQuZm9jdXMoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmb2N1c0ZpcnN0QWN0aW9uKCkge1xuICAgICAgICBjb25zdCBhY3Rpb25FbGVtZW50cyA9IEFycmF5LmZyb20oZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnLmRpYWxvZ19hY3Rpb24nKSk7XG4gICAgICAgIGNvbnN0IGZvY3VzVGFyZ2V0ID0gYWN0aW9uRWxlbWVudHNbMF07XG4gICAgICAgIGlmIChmb2N1c1RhcmdldCkge1xuICAgICAgICAgICAgZm9jdXNUYXJnZXQuZm9jdXMoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzaG93KG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gICAgICAgIG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMub3B0aW9ucyksIG9wdGlvbnMpO1xuICAgICAgICBjb25zdCBjb250YWluZXIgPSB0aGlzLmdldFBhcmVudEVsZW1lbnQob3B0aW9ucy5wYXJlbnRJZCB8fCB0aGlzLmRlZmF1bHRQYXJlbnRJZCk7XG4gICAgICAgIGlmIChjb250YWluZXIuaGFzQ2hpbGROb2RlcygpKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAvLyByZW1vdmUgZGlhbG9nIHdoZW4gY29udGFpbmVyIChiYWNrZ3JvdW5kKSBnZXRzIGNsaWNrZWRcbiAgICAgICAgY29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZSA9PiB7XG4gICAgICAgICAgICBpZiAoZS50YXJnZXQgPT09IGNvbnRhaW5lcilcbiAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZSgpO1xuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgRGlhbG9nID0gKF9oZWFkZXIsIF9ib2R5LCBfYWN0aW9ucykgPT4ge1xuICAgICAgICAgICAgY29uc3QgYWN0aW9uc0FycmF5ID0gX2FjdGlvbnMubWFwKChhY3Rpb24pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKDAsIGNvcmVfanNfMS5oKShidXR0b25fanNfMS5CdXR0b24sIHtcbiAgICAgICAgICAgICAgICAgICAgdGV4dDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgY29sb3I6IGFjdGlvbi5jb2xvciB8fCB0aGlzLmRlZmF1bHRBY3Rpb25Db2xvcixcbiAgICAgICAgICAgICAgICAgICAgY2xhc3M6ICdkaWFsb2dfYWN0aW9uJyxcbiAgICAgICAgICAgICAgICAgICAgLy8gc3R5bGU6IGBjb2xvcjogJHthY3Rpb24uY29sb3IgfHwgdGhpcy5kZWZhdWx0QWN0aW9uQ29sb3J9YCxcbiAgICAgICAgICAgICAgICAgICAgb25DbGljazogKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soeyBuYW1lOiBhY3Rpb24ubmFtZSwgaWQ6IGFjdGlvbi5pZCB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LCBhY3Rpb24ubmFtZS50b1VwcGVyQ2FzZSgpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgdGl0bGUgPSAoMCwgY29yZV9qc18xLmgpKCdoMicsIHsgY2xhc3M6ICdkaWFsb2dfaGVhZGVyJywgaWQ6ICdkaWFsb2ctdGl0bGUnIH0sIF9oZWFkZXIpO1xuICAgICAgICAgICAgY29uc3QgYm9keSA9ICgwLCBjb3JlX2pzXzEuaCkoJ2RpdicsIHsgY2xhc3M6ICdkaWFsb2dfYm9keScgfSwgX2JvZHkpO1xuICAgICAgICAgICAgY29uc3QgYWN0aW9ucyA9ICgwLCBjb3JlX2pzXzEuaCkoJ2RpdicsIHsgY2xhc3M6ICdkaWFsb2dfYWN0aW9ucycgfSwgYWN0aW9uc0FycmF5KTtcbiAgICAgICAgICAgIGNvbnN0IGRpYWxvZyA9ICgwLCBjb3JlX2pzXzEuaCkoJ2RpdicsIHsgY2xhc3M6ICdkaWFsb2cnLCByb2xlOiAnZGlhbG9nJywgJ2FyaWEtbW9kYWwnOiAndHJ1ZScsICdhcmlhLWxhYmVsbGVkYnknOiAnZGlhbG9nLXRpdGxlJyB9LCB0aXRsZSwgYm9keSwgYWN0aW9ucyk7XG4gICAgICAgICAgICByZXR1cm4gZGlhbG9nO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCBlbCA9IERpYWxvZyhvcHRpb25zLnRpdGxlLCBvcHRpb25zLmJvZHksIG9wdGlvbnMuYWN0aW9ucyB8fCBbXSk7XG4gICAgICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZChlbCk7XG4gICAgICAgIGNvbnN0IHsgZmlyc3RGb2N1c0FjdGlvbiB9ID0gb3B0aW9ucztcbiAgICAgICAgaWYgKG9wdGlvbnMuYWN0aW9ucyAmJiBmaXJzdEZvY3VzQWN0aW9uKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGZpcnN0Rm9jdXNBY3Rpb24gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5mb2N1c0FjdGlvbihmaXJzdEZvY3VzQWN0aW9uLCBvcHRpb25zLmFjdGlvbnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5mb2N1c0ZpcnN0QWN0aW9uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kaXNhYmxlU2Nyb2xsKCk7XG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgdGhpcy5oYW5kbGVLZXlkb3duKTtcbiAgICAgICAgY29uc3QgZGlhbG9nID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSgnZGlhbG9nJylbMF07XG4gICAgICAgIGNvbnN0IGFjdGlvbnMgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKCdkaWFsb2dfYWN0aW9ucycpWzBdO1xuICAgICAgICAvLyBpZiB0aGUgYWN0aW9ucyBhcmUgdG9vIGxvbmcsIHdlIHByZWZlciB0byBzZXQgZmxleC1kaXJlY3Rpb24gdG8gY29sdW1uIHRoYW4gdG8gd3JhcCB0aGUgc2luZ2xlIGFjdGlvbnNcbiAgICAgICAgY29uc3QgdXNlQ29sdW1uID0gZGlhbG9nLmNsaWVudFdpZHRoIDw9IGFjdGlvbnMuY2xpZW50V2lkdGg7XG4gICAgICAgIGlmICh1c2VDb2x1bW4pXG4gICAgICAgICAgICBhY3Rpb25zLnNldEF0dHJpYnV0ZSgnc3R5bGUnLCAnZmxleC1kaXJlY3Rpb246IGNvbHVtbjsnKTtcbiAgICB9XG59XG5leHBvcnRzLkRpYWxvZyA9IERpYWxvZztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRpYWxvZy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuRmFiID0gdm9pZCAwO1xuY29uc3QgY29tcG9uZW50X2pzXzEgPSByZXF1aXJlKFwiLi4vY29tcG9uZW50LmpzXCIpO1xuY29uc3QgY29yZV9qc18xID0gcmVxdWlyZShcIi4uL2NvcmUuanNcIik7XG5jb25zdCBfY29uZmlnX2pzXzEgPSByZXF1aXJlKFwiLi9fY29uZmlnLmpzXCIpO1xuY29uc3QgX2hlbHBlcnNfanNfMSA9IHJlcXVpcmUoXCIuL19oZWxwZXJzLmpzXCIpO1xuY2xhc3MgRmFiIGV4dGVuZHMgY29tcG9uZW50X2pzXzEuQ29tcG9uZW50IHtcbiAgICByZW5kZXIoKSB7XG4gICAgICAgIGNvbnN0IHsgYmFja2dyb3VuZCA9ICcjNjIwMEVFJywgY29sb3IgPSAnd2hpdGUnLCBleHRlbmRlZCA9IGZhbHNlLCBtaW5pID0gZmFsc2UsIGNlbnRlciA9IGZhbHNlLCBsZWZ0ID0gZmFsc2UsIG9uQ2xpY2sgPSAoKSA9PiB7IH0gfSA9IHRoaXMucHJvcHM7XG4gICAgICAgIGNvbnN0IGhlaWdodCA9IG1pbmkgPyA0MCA6IGV4dGVuZGVkID8gNDggOiA1NjtcbiAgICAgICAgY29uc3QgY3NzSGFzaCA9ICgwLCBjb3JlX2pzXzEuc3RyVG9IYXNoKShleHRlbmRlZC50b1N0cmluZygpICsgbWluaS50b1N0cmluZygpICsgY2VudGVyLnRvU3RyaW5nKCkgKyBsZWZ0LnRvU3RyaW5nKCkpO1xuICAgICAgICBjb25zdCBjbGFzc05hbWUgPSBgZmFiLWNvbnRhaW5lci0ke2Nzc0hhc2h9YDtcbiAgICAgICAgY29uc3Qgc3R5bGVzID0gYFxyXG4gICAgICAuJHtjbGFzc05hbWV9IHtcclxuICAgICAgICAke21pbmkgPyAnd2lkdGg6IDQwcHg7JyA6IGV4dGVuZGVkID8gJ3BhZGRpbmc6IDBweCAxMnB4OycgOiAnd2lkdGg6IDU2cHg7J31cclxuICAgICAgICBoZWlnaHQ6ICR7aGVpZ2h0fXB4O1xyXG4gICAgICAgIHBvc2l0aW9uOiBmaXhlZDtcclxuICAgICAgICBiYWNrZ3JvdW5kOiAke2JhY2tncm91bmR9O1xyXG4gICAgICAgIGJvcmRlci1yYWRpdXM6IDM2cHg7XHJcbiAgICAgICAgZGlzcGxheTogZmxleDtcclxuICAgICAgICBhbGlnbi1pdGVtczogY2VudGVyO1xyXG4gICAgICAgIGp1c3RpZnktY29udGVudDogY2VudGVyO1xyXG4gICAgICAgIGNvbG9yOiAke2NvbG9yfTtcclxuICAgICAgICBjdXJzb3I6IHBvaW50ZXI7XHJcblxyXG4gICAgICAgIHotaW5kZXg6ICR7X2NvbmZpZ19qc18xLnpJbmRleC5mYWJ9XHJcbiAgICAgICAgYm90dG9tOiAke3RoaXMucHJvcHMub2Zmc2V0WSA/IDE2ICsgdGhpcy5wcm9wcy5vZmZzZXRZIDogMTZ9cHg7ICAgICAgICBcclxuICAgICAgICAke2xlZnQgPyAnbGVmdDogMTZweDsnIDogJ3JpZ2h0OiAxNnB4Oyd9XHJcbiAgICAgICAgJHtjZW50ZXIgPyAndHJhbnNmb3JtOiB0cmFuc2xhdGVYKDUwJSk7IHJpZ2h0OiA1MCU7JyA6ICcnfVxyXG4gICAgICAgICR7X2NvbmZpZ19qc18xLmJveFNoYWRvd31cclxuICAgICAgICAke19jb25maWdfanNfMS51c2VyU2VsZWN0fVxyXG4gICAgICB9XHJcbiAgICBgO1xuICAgICAgICAoMCwgX2hlbHBlcnNfanNfMS5hZGRTdHlsZXNUb0hlYWQpKHN0eWxlcywgY3NzSGFzaCk7XG4gICAgICAgIGNvbnN0IHsgY2hpbGRyZW4gfSA9IHRoaXMucHJvcHM7XG4gICAgICAgIHJldHVybiAoMCwgY29yZV9qc18xLmgpKCdkaXYnLCB7IGNsYXNzOiBjbGFzc05hbWUsIG9uQ2xpY2s6IChlKSA9PiBvbkNsaWNrKGUpIH0sIGNoaWxkcmVuKTtcbiAgICB9XG59XG5leHBvcnRzLkZhYiA9IEZhYjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZhYi5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX3Jlc3QgPSAodGhpcyAmJiB0aGlzLl9fcmVzdCkgfHwgZnVuY3Rpb24gKHMsIGUpIHtcbiAgICB2YXIgdCA9IHt9O1xuICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSAmJiBlLmluZGV4T2YocCkgPCAwKVxuICAgICAgICB0W3BdID0gc1twXTtcbiAgICBpZiAocyAhPSBudWxsICYmIHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzID09PSBcImZ1bmN0aW9uXCIpXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBwID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhzKTsgaSA8IHAubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChlLmluZGV4T2YocFtpXSkgPCAwICYmIE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChzLCBwW2ldKSlcbiAgICAgICAgICAgICAgICB0W3BbaV1dID0gc1twW2ldXTtcbiAgICAgICAgfVxuICAgIHJldHVybiB0O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuSWNvbiA9IHZvaWQgMDtcbmNvbnN0IGNvbXBvbmVudF9qc18xID0gcmVxdWlyZShcIi4uL2NvbXBvbmVudC5qc1wiKTtcbmNvbnN0IGNvcmVfanNfMSA9IHJlcXVpcmUoXCIuLi9jb3JlLmpzXCIpO1xuY29uc3QgX2hlbHBlcnNfanNfMSA9IHJlcXVpcmUoXCIuL19oZWxwZXJzLmpzXCIpO1xuY2xhc3MgSWNvbiBleHRlbmRzIGNvbXBvbmVudF9qc18xLkNvbXBvbmVudCB7XG4gICAgZGlkVW5tb3VudCgpIHtcbiAgICAgICAgLy8gbm90IHN1cmUgaWYgSSB3YW50IHRvIHJlbW92ZSB0aGUgY3NzLCBzaW5jZSB0aGVyZSBtaWdodCBiZSBhbm90aGVyIEljb24gd2l0aCB0aGUgc2FtZSBzdHlsZXMuXG4gICAgICAgIC8vIGNvbnN0IGVsID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihgW2RhdGEtY3NzLWhhc2gqPVwiJHt0aGlzLmNzc0hhc2h9XCJdYClcbiAgICAgICAgLy8gaWYgKGVsKSBlbC5yZW1vdmUoKVxuICAgIH1cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIGNvbnN0IF9hID0gdGhpcy5wcm9wcywgeyBzcmMsIHNpemUgPSAxNiwgYWN0aXZlID0gdHJ1ZSwgY29sb3IgPSAnIzYyMDRFRScsIHN0eWxlID0gJycgfSA9IF9hLCByZXN0ID0gX19yZXN0KF9hLCBbXCJzcmNcIiwgXCJzaXplXCIsIFwiYWN0aXZlXCIsIFwiY29sb3JcIiwgXCJzdHlsZVwiXSk7XG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgY29uc3QgY2hpbGRyZW4gPSB0aGlzLnByb3BzLmNoaWxkcmVuO1xuICAgICAgICB0aGlzLmNzc0hhc2ggPSAoMCwgY29yZV9qc18xLnN0clRvSGFzaCkoYWN0aXZlICsgY29sb3IgKyBzaXplLnRvU3RyaW5nKCkpO1xuICAgICAgICBjb25zdCBjb2xvcnMgPSB7XG4gICAgICAgICAgICBhY3RpdmU6IGNvbG9yLFxuICAgICAgICAgICAgaW5hY3RpdmU6ICcjMDAwMDAwNzAnXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHN0eWxlcyA9IGBcclxuICAgIGkuaWNvbi0ke3RoaXMuY3NzSGFzaH0ge1xyXG4gICAgICB3aWR0aDogJHtzaXplfXB4O1xyXG4gICAgICBoZWlnaHQ6ICR7c2l6ZX1weDtcclxuICAgICAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xyXG4gICAgICBjb250ZW50OiAnJztcclxuXHJcbiAgICAgIC8qLXdlYmtpdC1tYXNrOiB1cmwoWU9VUl9TVkdfVVJMKSBuby1yZXBlYXQgNTAlIDUwJTtcclxuICAgICAgbWFzazogdXJsKFlPVVJfU1ZHX1VSTCkgbm8tcmVwZWF0IDUwJSA1MCU7Ki9cclxuXHJcbiAgICAgIC13ZWJraXQtbWFzay1zaXplOiBjb3ZlcjtcclxuICAgICAgbWFzay1zaXplOiBjb3ZlcjsgXHJcblxyXG4gICAgICBiYWNrZ3JvdW5kLWNvbG9yOiAke2NvbG9ycy5hY3RpdmV9O1xyXG4gICAgfVxyXG5cclxuICAgIGkuaWNvbi0ke3RoaXMuY3NzSGFzaH0uaWNvbl9pbmFjdGl2ZS0ke3RoaXMuY3NzSGFzaH0ge1xyXG4gICAgICBiYWNrZ3JvdW5kLWNvbG9yOiAke2NvbG9ycy5pbmFjdGl2ZX07XHJcbiAgICB9XHJcbiAgICBgO1xuICAgICAgICAoMCwgX2hlbHBlcnNfanNfMS5hZGRTdHlsZXNUb0hlYWQpKHN0eWxlcywgdGhpcy5jc3NIYXNoKTtcbiAgICAgICAgLy8gY29uc3QgaWNvblN0eWxlID0gYC13ZWJraXQtbWFzazogdXJsKC9kZXYvZm9udC1hd2Vzb21lL2VsbGlwc2lzLXYtc29saWQuc3ZnKSBuby1yZXBlYXQgNTAlIDUwJTttYXNrOiB1cmwoL2Rldi9mb250LWF3ZXNvbWUvZWxsaXBzaXMtdi1zb2xpZC5zdmcpIG5vLXJlcGVhdCA1MCUgNTAlO2BcbiAgICAgICAgY29uc3QgaWNvblN0eWxlID0gYC13ZWJraXQtbWFzazogdXJsKCR7c3JjIHx8IGNoaWxkcmVufSkgbm8tcmVwZWF0IDUwJSA1MCU7IG1hc2s6IHVybCgke3NyYyB8fCBjaGlsZHJlbn0pIG5vLXJlcGVhdCA1MCUgNTAlO2A7XG4gICAgICAgIGNvbnN0IGNsYXNzZXMgPSBbYGljb24tJHt0aGlzLmNzc0hhc2h9YF07XG4gICAgICAgIGlmICghYWN0aXZlKVxuICAgICAgICAgICAgY2xhc3Nlcy5wdXNoKGBpY29uX2luYWN0aXZlLSR7dGhpcy5jc3NIYXNofWApO1xuICAgICAgICBjb25zdCBpY29uID0gKDAsIGNvcmVfanNfMS5oKSgnaScsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7IGNsYXNzOiBjbGFzc2VzLmpvaW4oJyAnKSB9LCByZXN0KSwgeyBzdHlsZTogaWNvblN0eWxlICsgc3R5bGUgfSkpO1xuICAgICAgICByZXR1cm4gaWNvbjtcbiAgICB9XG59XG5leHBvcnRzLkljb24gPSBJY29uO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aWNvbi5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuU2hlZXQgPSBleHBvcnRzLlRhYiA9IGV4cG9ydHMuVGFicyA9IGV4cG9ydHMuU25hY2tiYXIgPSBleHBvcnRzLk1lbnUgPSBleHBvcnRzLkxpc3RJdGVtID0gZXhwb3J0cy5MaXN0ID0gZXhwb3J0cy5JY29uID0gZXhwb3J0cy5GYWIgPSBleHBvcnRzLkRpYWxvZyA9IGV4cG9ydHMuQnV0dG9uID0gZXhwb3J0cy5OYXZpZ2F0aW9uQWN0aW9uID0gZXhwb3J0cy5OYXZpZ2F0aW9uID0gZXhwb3J0cy5Ub29sYmFyID0gZXhwb3J0cy5BcHBCYXIgPSB2b2lkIDA7XG52YXIgYXBwQmFyX2pzXzEgPSByZXF1aXJlKFwiLi4vdWkvYXBwQmFyLmpzXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQXBwQmFyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBhcHBCYXJfanNfMS5BcHBCYXI7IH0gfSk7XG52YXIgdG9vbGJhcl9qc18xID0gcmVxdWlyZShcIi4uL3VpL3Rvb2xiYXIuanNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJUb29sYmFyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0b29sYmFyX2pzXzEuVG9vbGJhcjsgfSB9KTtcbnZhciBuYXZpZ2F0aW9uX2pzXzEgPSByZXF1aXJlKFwiLi4vdWkvbmF2aWdhdGlvbi5qc1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIk5hdmlnYXRpb25cIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG5hdmlnYXRpb25fanNfMS5OYXZpZ2F0aW9uOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiTmF2aWdhdGlvbkFjdGlvblwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbmF2aWdhdGlvbl9qc18xLk5hdmlnYXRpb25BY3Rpb247IH0gfSk7XG52YXIgYnV0dG9uX2pzXzEgPSByZXF1aXJlKFwiLi4vdWkvYnV0dG9uLmpzXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQnV0dG9uXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBidXR0b25fanNfMS5CdXR0b247IH0gfSk7XG52YXIgZGlhbG9nX2pzXzEgPSByZXF1aXJlKFwiLi4vdWkvZGlhbG9nLmpzXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiRGlhbG9nXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBkaWFsb2dfanNfMS5EaWFsb2c7IH0gfSk7XG52YXIgZmFiX2pzXzEgPSByZXF1aXJlKFwiLi4vdWkvZmFiLmpzXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiRmFiXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBmYWJfanNfMS5GYWI7IH0gfSk7XG52YXIgaWNvbl9qc18xID0gcmVxdWlyZShcIi4uL3VpL2ljb24uanNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJJY29uXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpY29uX2pzXzEuSWNvbjsgfSB9KTtcbnZhciBsaXN0X2pzXzEgPSByZXF1aXJlKFwiLi4vdWkvbGlzdC5qc1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkxpc3RcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGxpc3RfanNfMS5MaXN0OyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiTGlzdEl0ZW1cIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGxpc3RfanNfMS5MaXN0SXRlbTsgfSB9KTtcbnZhciBtZW51X2pzXzEgPSByZXF1aXJlKFwiLi4vdWkvbWVudS5qc1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIk1lbnVcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1lbnVfanNfMS5NZW51OyB9IH0pO1xudmFyIHNuYWNrYmFyX2pzXzEgPSByZXF1aXJlKFwiLi4vdWkvc25hY2tiYXIuanNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJTbmFja2JhclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gc25hY2tiYXJfanNfMS5TbmFja2JhcjsgfSB9KTtcbnZhciB0YWJzX2pzXzEgPSByZXF1aXJlKFwiLi4vdWkvdGFicy5qc1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlRhYnNcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRhYnNfanNfMS5UYWJzOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiVGFiXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0YWJzX2pzXzEuVGFiOyB9IH0pO1xudmFyIHNoZWV0X2pzXzEgPSByZXF1aXJlKFwiLi4vdWkvc2hlZXQuanNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJTaGVldFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gc2hlZXRfanNfMS5TaGVldDsgfSB9KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5MaXN0ID0gZXhwb3J0cy5MaXN0SXRlbSA9IHZvaWQgMDtcbmNvbnN0IGNvbXBvbmVudF9qc18xID0gcmVxdWlyZShcIi4uL2NvbXBvbmVudC5qc1wiKTtcbmNvbnN0IGNvcmVfanNfMSA9IHJlcXVpcmUoXCIuLi9jb3JlLmpzXCIpO1xuY29uc3QgaWNvbl9qc18xID0gcmVxdWlyZShcIi4vaWNvbi5qc1wiKTtcbmNvbnN0IF9oZWxwZXJzX2pzXzEgPSByZXF1aXJlKFwiLi9faGVscGVycy5qc1wiKTtcbmNsYXNzIExpc3RJdGVtIGV4dGVuZHMgY29tcG9uZW50X2pzXzEuQ29tcG9uZW50IHtcbiAgICByZW5kZXIoKSB7XG4gICAgICAgIGNvbnN0IHsgcHJvcHM6IHAgfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IHsgb25DbGljayA9ICgpID0+IHsgfSB9ID0gcDtcbiAgICAgICAgY29uc3QgYWRqdXN0ZWRNYXJnaW4gPSAnbWFyZ2luLXJpZ2h0OiAxNnB4Oyc7XG4gICAgICAgIGNvbnN0IGljb24gPSBwLmljb24gPyAoMCwgY29yZV9qc18xLmgpKGljb25fanNfMS5JY29uLCB7IHNpemU6IDIwLCBzdHlsZTogJ21hcmdpbi1yaWdodDogMzJweDsnLCBzcmM6IHAuaWNvbiB9KSA6IG51bGw7XG4gICAgICAgIGNvbnN0IGF2YXRhciA9IHAuYXZhdGFyXG4gICAgICAgICAgICA/ICgwLCBjb3JlX2pzXzEuaCkoJ2ltZycsIHsgc3JjOiBwLmF2YXRhciwgd2lkdGg6IDQwLCBoZWlnaHQ6IDQwLCBzdHlsZTogYGJvcmRlci1yYWRpdXM6IDIwcHg7ICR7YWRqdXN0ZWRNYXJnaW59YCB9KVxuICAgICAgICAgICAgOiBudWxsO1xuICAgICAgICBjb25zdCBzcXVhcmUgPSBwLnNxdWFyZSA/ICgwLCBjb3JlX2pzXzEuaCkoJ2ltZycsIHsgc3JjOiBwLnNxdWFyZSwgd2lkdGg6IDU2LCBoZWlnaHQ6IDU2LCBzdHlsZTogYWRqdXN0ZWRNYXJnaW4gfSkgOiBudWxsO1xuICAgICAgICBjb25zdCBpbWFnZSA9IHAuaW1hZ2VcbiAgICAgICAgICAgID8gKDAsIGNvcmVfanNfMS5oKSgnaW1nJywgeyBzcmM6IHAuaW1hZ2UsIHdpZHRoOiAxMDAsIGhlaWdodDogNTYsIHN0eWxlOiAnbWFyZ2luLWxlZnQ6IC0xNnB4OyBtYXJnaW4tcmlnaHQ6IDE2cHg7JyB9KVxuICAgICAgICAgICAgOiBudWxsO1xuICAgICAgICBjb25zdCB0ZXh0ID0gKDAsIGNvcmVfanNfMS5oKSgnc3BhbicsIG51bGwsIHAuY2hpbGRyZW4pO1xuICAgICAgICAvLyBhZGRpdGlvbmFsIHN0eWxlIGZvciB0aGUgbGlzdCBpdGVtXG4gICAgICAgIGxldCBzdHlsZSA9ICcnO1xuICAgICAgICBpZiAocC5pY29uIHx8IHAuYXZhdGFyKVxuICAgICAgICAgICAgc3R5bGUgKz0gJ21pbi1oZWlnaHQ6IDU2cHg7ICc7XG4gICAgICAgIGlmIChwLnNxdWFyZSB8fCBwLmltYWdlKVxuICAgICAgICAgICAgc3R5bGUgKz0gJ21pbi1oZWlnaHQ6IDcycHg7ICc7XG4gICAgICAgIHJldHVybiAoMCwgY29yZV9qc18xLmgpKCdsaScsIHsgc3R5bGUsIG9uQ2xpY2sgfSwgaWNvbiwgYXZhdGFyLCBzcXVhcmUsIGltYWdlLCB0ZXh0KTtcbiAgICB9XG59XG5leHBvcnRzLkxpc3RJdGVtID0gTGlzdEl0ZW07XG5jbGFzcyBMaXN0IGV4dGVuZHMgY29tcG9uZW50X2pzXzEuQ29tcG9uZW50IHtcbiAgICByZW5kZXIoKSB7XG4gICAgICAgIGNvbnN0IHsgc21hbGwgPSBmYWxzZSB9ID0gdGhpcy5wcm9wcztcbiAgICAgICAgdGhpcy5jc3NIYXNoID0gKDAsIGNvcmVfanNfMS5zdHJUb0hhc2gpKGBMaXN0JHtzbWFsbC50b1N0cmluZygpfWApO1xuICAgICAgICBjb25zdCBzdHlsZXMgPSBgXHJcbiAgICAgIC5saXN0LSR7dGhpcy5jc3NIYXNofSB1bCB7XHJcbiAgICAgICAgbWFyZ2luOiAwcHg7XHJcbiAgICAgICAgcGFkZGluZzogOHB4IDE2cHg7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC5saXN0LSR7dGhpcy5jc3NIYXNofSB1bCBsaSB7XHJcbiAgICAgICAgbGlzdC1zdHlsZTogbm9uZTtcclxuICAgICAgICBtaW4taGVpZ2h0OiAke3NtYWxsID8gMzIgOiA0Nn1weDtcclxuICAgICAgICBkaXNwbGF5OiBmbGV4O1xyXG4gICAgICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XHJcbiAgICAgICAgbWFyZ2luOiAwcHggLTE2cHg7XHJcbiAgICAgICAgcGFkZGluZzogMHB4IDE2cHg7XHJcbiAgICAgICAgY3Vyc29yOiBwb2ludGVyO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAubGlzdC0ke3RoaXMuY3NzSGFzaH0gdWwgbGkgc3BhbiB7XHJcbiAgICAgICAgZm9udC1zaXplOiAxNnB4O1xyXG4gICAgICB9XHJcblxyXG4gICAgICAubGlzdC0ke3RoaXMuY3NzSGFzaH0gdWwgbGk6aG92ZXIgIHtcclxuICAgICAgICBiYWNrZ3JvdW5kOiMwMDAwMDAxMFxyXG4gICAgICB9ICAgIFxyXG4gICAgYDtcbiAgICAgICAgKDAsIF9oZWxwZXJzX2pzXzEuYWRkU3R5bGVzVG9IZWFkKShzdHlsZXMsIHRoaXMuY3NzSGFzaCk7XG4gICAgICAgIGNvbnN0IHVsID0gKDAsIGNvcmVfanNfMS5oKSgndWwnLCBudWxsLCB0aGlzLnByb3BzLmNoaWxkcmVuKTtcbiAgICAgICAgcmV0dXJuICgwLCBjb3JlX2pzXzEuaCkoJ2RpdicsIHsgY2xhc3M6IGBsaXN0LSR7dGhpcy5jc3NIYXNofWAgfSwgdWwpO1xuICAgIH1cbn1cbmV4cG9ydHMuTGlzdCA9IExpc3Q7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1saXN0LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5NZW51ID0gdm9pZCAwO1xuY29uc3QgY29yZV9qc18xID0gcmVxdWlyZShcIi4uL2NvcmUuanNcIik7XG5jb25zdCBfY29uZmlnX2pzXzEgPSByZXF1aXJlKFwiLi9fY29uZmlnLmpzXCIpO1xuY29uc3QgX2hlbHBlcnNfanNfMSA9IHJlcXVpcmUoXCIuL19oZWxwZXJzLmpzXCIpO1xuY2xhc3MgTWVudSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuZGVmYXVsdFBhcmVudElkID0gJ21lbnVfaXRlbXNfY29udGFpbmVyJztcbiAgICAgICAgdGhpcy5jc3NIYXNoID0gTWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc3Vic3RyaW5nKDIpO1xuICAgIH1cbiAgICAvLyBkaWRVbm1vdW50KCkge1xuICAgIC8vICAgY29uc3QgZWwgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKGBbZGF0YS1jc3MtaGFzaCo9XCIke3RoaXMuY3NzSGFzaH1cIl1gKVxuICAgIC8vICAgaWYgKGVsKSBlbC5yZW1vdmUoKVxuICAgIC8vIH1cbiAgICBnZXRQYXJlbnRFbGVtZW50KGlkKSB7XG4gICAgICAgIC8vIGRlbGV0ZSBhbGwgb3RoZXJcbiAgICAgICAgY29uc3Qgb3RoZXJzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChgW2lkXj1cIiR7dGhpcy5kZWZhdWx0UGFyZW50SWR9XCJdYCk7XG4gICAgICAgIG90aGVycy5mb3JFYWNoKGUgPT4ge1xuICAgICAgICAgICAgZS5yZW1vdmUoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGxldCBlbCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGAke3RoaXMuZGVmYXVsdFBhcmVudElkfS0ke2lkfWApO1xuICAgICAgICBpZiAoIWVsKSB7XG4gICAgICAgICAgICBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICAgICAgZWwuaWQgPSBgJHt0aGlzLmRlZmF1bHRQYXJlbnRJZH0tJHtpZH1gO1xuICAgICAgICB9XG4gICAgICAgICgwLCBjb3JlX2pzXzEucmVtb3ZlQWxsQ2hpbGROb2RlcykoZWwpO1xuICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGVsKTtcbiAgICAgICAgcmV0dXJuIGVsO1xuICAgIH1cbiAgICBjbG9zZSgpIHtcbiAgICAgICAgKDAsIGNvcmVfanNfMS5yZW1vdmVBbGxDaGlsZE5vZGVzKSh0aGlzLmdldFBhcmVudEVsZW1lbnQodGhpcy5jc3NIYXNoKSk7XG4gICAgfVxuICAgIG9wZW4obWVudU9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgeyBwb3NpdGlvbiwgbGlzdCB9ID0gbWVudU9wdGlvbnM7XG4gICAgICAgIC8vIGNoZWNrIGluIHdoaWNoIGNvcm5lciB0aGUgbWVudSBhcHBlYXJzIGFuZCBhZGp1c3QgZml4ZWQgcG9zaXRpb24uXG4gICAgICAgIGNvbnN0IGxlZnQgPSBwb3NpdGlvbi54IDwgd2luZG93LmlubmVyV2lkdGggLyAyID8gJ2xlZnQnIDogJ3JpZ2h0JztcbiAgICAgICAgY29uc3QgdG9wID0gcG9zaXRpb24ueSA8IHdpbmRvdy5pbm5lckhlaWdodCAvIDIgPyAndG9wJyA6ICdib3R0b20nO1xuICAgICAgICBjb25zdCBzdHlsZXMgPSBgXHJcbiAgIFxyXG4gICAgI21lbnVfaXRlbXNfYmFja2dyb3VuZC0ke3RoaXMuY3NzSGFzaH0ge1xyXG4gICAgICB3aWR0aDogMTAwdnc7XHJcbiAgICAgIGhlaWdodDogMTAwdmg7XHJcbiAgICAgIGJhY2tncm91bmQ6IHRyYW5zcGFyZW50O1xyXG4gICAgICBwb3NpdGlvbjogZml4ZWQ7XHJcbiAgICAgIHRvcDogMDtcclxuICAgICAgbGVmdDogMDtcclxuICAgICAgei1pbmRleDogJHtfY29uZmlnX2pzXzEuekluZGV4Lm1lbnV9ICAgICAgXHJcbiAgICB9XHJcbiAgIFxyXG4gICAgI21lbnVfaXRlbXNfbGlzdC0ke3RoaXMuY3NzSGFzaH0ge1xyXG4gICAgICBwb3NpdGlvbjogZml4ZWQ7XHJcbiAgICAgIGJhY2tncm91bmQ6IHdoaXRlO1xyXG4gICAgICBcclxuICAgICAgYm9yZGVyLXJhZGl1czogNHB4O1xyXG4gICAgICBtaW4td2lkdGg6IDExMnB4O1xyXG5cclxuICAgICAgJHt0b3B9OiAke3Bvc2l0aW9uLnkgPiB3aW5kb3cuaW5uZXJIZWlnaHQgLyAyID8gd2luZG93LmlubmVySGVpZ2h0IC0gcG9zaXRpb24ueSA6IHBvc2l0aW9uLnl9cHg7XHJcbiAgICAgICR7bGVmdH06ICR7cG9zaXRpb24ueCA+IHdpbmRvdy5pbm5lcldpZHRoIC8gMiA/IHdpbmRvdy5pbm5lcldpZHRoIC0gcG9zaXRpb24ueCA6IHBvc2l0aW9uLnh9cHg7XHJcblxyXG4gICAgICB6LWluZGV4OiAke19jb25maWdfanNfMS56SW5kZXgubWVudX1cclxuXHJcbiAgICAgICR7X2NvbmZpZ19qc18xLmJveFNoYWRvd31cclxuICAgIH1cclxuXHJcbiAgICBgO1xuICAgICAgICAvLyByZW1vdmUgb2xkIHN0eWxlc1xuICAgICAgICBjb25zdCBlbCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoYFtkYXRhLWNzcy1oYXNoKj1cIiR7dGhpcy5jc3NIYXNofVwiXWApO1xuICAgICAgICBpZiAoZWwpXG4gICAgICAgICAgICBlbC5yZW1vdmUoKTtcbiAgICAgICAgLy8gYWRkIG5ldyBzdHlsZXNcbiAgICAgICAgKDAsIF9oZWxwZXJzX2pzXzEuYWRkU3R5bGVzVG9IZWFkKShzdHlsZXMsIHRoaXMuY3NzSGFzaCk7XG4gICAgICAgIGNvbnN0IGl0ZW1zTGlzdCA9ICgwLCBjb3JlX2pzXzEuaCkoJ2RpdicsIHsgaWQ6IGBtZW51X2l0ZW1zX2xpc3QtJHt0aGlzLmNzc0hhc2h9YCB9LCBsaXN0KTtcbiAgICAgICAgY29uc3QgaXRlbXNCZyA9ICgwLCBjb3JlX2pzXzEuaCkoJ2RpdicsIHsgb25DbGljazogKCkgPT4gdGhpcy5jbG9zZSgpLCBpZDogYG1lbnVfaXRlbXNfYmFja2dyb3VuZC0ke3RoaXMuY3NzSGFzaH1gIH0sIGl0ZW1zTGlzdCk7XG4gICAgICAgIGl0ZW1zTGlzdC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIChlKSA9PiBlLnN0b3BQcm9wYWdhdGlvbigpKTtcbiAgICAgICAgdGhpcy5nZXRQYXJlbnRFbGVtZW50KHRoaXMuY3NzSGFzaCkuYXBwZW5kQ2hpbGQoKDAsIGNvcmVfanNfMS5yZW5kZXIpKGl0ZW1zQmcpKTtcbiAgICB9XG59XG5leHBvcnRzLk1lbnUgPSBNZW51O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWVudS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuTmF2aWdhdGlvbiA9IGV4cG9ydHMuTmF2aWdhdGlvbkFjdGlvbiA9IHZvaWQgMDtcbmNvbnN0IGNvcmVfanNfMSA9IHJlcXVpcmUoXCIuLi9jb3JlLmpzXCIpO1xuY29uc3QgY29tcG9uZW50X2pzXzEgPSByZXF1aXJlKFwiLi4vY29tcG9uZW50LmpzXCIpO1xuY29uc3QgX2NvbmZpZ19qc18xID0gcmVxdWlyZShcIi4vX2NvbmZpZy5qc1wiKTtcbmNvbnN0IGljb25fanNfMSA9IHJlcXVpcmUoXCIuL2ljb24uanNcIik7XG5jb25zdCBjbGFzc2VzID0ge1xuICAgIGxhYmVsOiAnYm90dG9tX25hdmlnYXRpb25fbGFiZWwnLFxuICAgIGFjdGlvbjogJ2JvdHRvbV9uYXZpZ2F0aW9uX2FjdGlvbicsXG4gICAgaWRQcmVmaXg6ICdib3R0b21fbmF2aWdhdGlvbl9hY3Rpb25faWQtJyxcbiAgICBpbmFjdGl2ZTogJ2JvdHRvbV9uYXZpZ2F0aW9uX2FjdGlvbl9pbmFjdGl2ZScsXG4gICAgaW5pdGlhbEFjdGl2ZTogJ2JvdHRvbV9uYXZpZ2F0aW9uX2xhYmVsX2luaXRpYWxfYWN0aXZlJ1xufTtcbmNsYXNzIE5hdmlnYXRpb25BY3Rpb24gZXh0ZW5kcyBjb21wb25lbnRfanNfMS5Db21wb25lbnQge1xuICAgIHdpbGxNb3VudCgpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICB0aGlzLmlkID0gKF9hID0gdGhpcy5wcm9wcy5pZCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogdGhpcy5wcm9wcy5sYWJlbC50b0xvd2VyQ2FzZSgpLnJlcGxhY2UoL1xccy9nbSwgJy0nKS5yZXBsYWNlKC9bLV0rL2dtLCAnLScpO1xuICAgIH1cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIGNvbnN0IGxhYmVsID0gKDAsIGNvcmVfanNfMS5oKSgnc3BhbicsIHsgY2xhc3M6IGNsYXNzZXMubGFiZWwgfSwgdGhpcy5wcm9wcy5sYWJlbCk7XG4gICAgICAgIGNvbnN0IGFjdGlvbkNsYXNzZXMgPSBbY2xhc3Nlcy5hY3Rpb25dO1xuICAgICAgICBpZiAodGhpcy5wcm9wcy5hY3RpdmUpXG4gICAgICAgICAgICBhY3Rpb25DbGFzc2VzLnB1c2goY2xhc3Nlcy5pbml0aWFsQWN0aXZlKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgYWN0aW9uQ2xhc3Nlcy5wdXNoKGNsYXNzZXMuaW5hY3RpdmUpO1xuICAgICAgICByZXR1cm4gKDAsIGNvcmVfanNfMS5oKSgnZGl2Jywge1xuICAgICAgICAgICAgaWQ6IGAke2NsYXNzZXMuaWRQcmVmaXh9JHt0aGlzLmlkfWAsXG4gICAgICAgICAgICBjbGFzczogYWN0aW9uQ2xhc3Nlcy5qb2luKCcgJyksXG4gICAgICAgICAgICBvbkNsaWNrOiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5wcm9wcy5saW5rKVxuICAgICAgICAgICAgICAgICAgICB3aW5kb3cubG9jYXRpb24uaHJlZiA9IHRoaXMucHJvcHMubGluaztcbiAgICAgICAgICAgICAgICAoX2IgPSAoX2EgPSB0aGlzLnByb3BzKS5vbkNsaWNrKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FsbChfYSwgeyBuYXZpZ2F0ZTogISF0aGlzLnByb3BzLmxpbmssIGlkOiB0aGlzLmlkLCBsYWJlbDogdGhpcy5wcm9wcy5sYWJlbCwgY29tcG9uZW50OiB0aGlzIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCB0aGlzLnByb3BzLmljb24gPyAoMCwgY29yZV9qc18xLmgpKGljb25fanNfMS5JY29uLCB7IHNpemU6IDIyLCBzdHlsZTogJ21hcmdpbi1ib3R0b206IDJweDsnLCBzcmM6IHRoaXMucHJvcHMuaWNvbiB9KSA6IG51bGwsIGxhYmVsKTtcbiAgICB9XG59XG5leHBvcnRzLk5hdmlnYXRpb25BY3Rpb24gPSBOYXZpZ2F0aW9uQWN0aW9uO1xuY2xhc3MgTmF2aWdhdGlvbiBleHRlbmRzIGNvbXBvbmVudF9qc18xLkNvbXBvbmVudCB7XG4gICAgZGlkTW91bnQoKSB7XG4gICAgICAgIGNvbnN0IGNoaWxkcmVuID0gdGhpcy5wcm9wcy5jaGlsZHJlbjtcbiAgICAgICAgY2hpbGRyZW4uZm9yRWFjaChjID0+IHtcbiAgICAgICAgICAgIGMucHJvcHMub25DbGljayA9IGUgPT4ge1xuICAgICAgICAgICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgICAgICAgICAgaWYgKGUubmF2aWdhdGUpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICBjb25zdCBlbGVtZW50cyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoYFtpZF49XCIke2NsYXNzZXMuaWRQcmVmaXh9XCJdYCk7XG4gICAgICAgICAgICAgICAgZWxlbWVudHMuZm9yRWFjaChlbCA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlbC5pZCA9PT0gYCR7Y2xhc3Nlcy5pZFByZWZpeH0ke2UuaWR9YClcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsLmNsYXNzTGlzdC5yZW1vdmUoY2xhc3Nlcy5pbmFjdGl2ZSk7XG4gICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsLmNsYXNzTGlzdC5hZGQoY2xhc3Nlcy5pbmFjdGl2ZSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgKF9iID0gKF9hID0gdGhpcy5wcm9wcykub25DbGljaykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EsIGUpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgY29uc3QgY29sb3JzID0ge1xuICAgICAgICAgICAgYWN0aXZlOiAnIzYyMDRFRScsXG4gICAgICAgICAgICBpbmFjdGl2ZTogJyMwMDAwMDA3MCdcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3Qgc3R5bGVzID0gYFxyXG4gICAgICAjYm90dG9tX25hdmlnYXRpb25fY29udGFpbmVyIHtcclxuXHJcbiAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogd2hpdGU7XHJcbiAgICAgICAgcG9zaXRpb246IGZpeGVkO1xyXG4gICAgICAgIGJvdHRvbTogMDtcclxuICAgICAgICBsZWZ0OiAwO1xyXG4gICAgICAgIHdpZHRoOiAxMDB2dztcclxuICAgICAgICBtaW4taGVpZ2h0OiA1NnB4O1xyXG5cclxuICAgICAgICB6LWluZGV4OiAke19jb25maWdfanNfMS56SW5kZXgubmF2aWdhdGlvbn1cclxuXHJcbiAgICAgICAgZGlzcGxheTogZmxleDtcclxuICAgICAgICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcclxuICAgICAgICBcclxuICAgICAgICAke19jb25maWdfanNfMS5ib3hTaGFkb3d9XHJcbiAgICAgIH0gXHJcblxyXG4gICAgICAjYm90dG9tX25hdmlnYXRpb25fY29udGFpbmVyIC5ib3R0b21fbmF2aWdhdGlvbl9sYWJlbCB7XHJcbiAgICAgICAgdHJhbnNpdGlvbjogZm9udC1zaXplIDAuMnM7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgICNib3R0b21fbmF2aWdhdGlvbl9jb250YWluZXIgLmJvdHRvbV9uYXZpZ2F0aW9uX2xhYmVsX2luaXRpYWxfYWN0aXZlIC5ib3R0b21fbmF2aWdhdGlvbl9sYWJlbHtcclxuICAgICAgICBhbmltYXRpb24tbmFtZTogYm90dG9tX25hdmlnYXRpb25fbGFiZWxfZm9udHNpemU7XHJcbiAgICAgICAgYW5pbWF0aW9uLWR1cmF0aW9uOiAwLjJzO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBAa2V5ZnJhbWVzIGJvdHRvbV9uYXZpZ2F0aW9uX2xhYmVsX2ZvbnRzaXplIHtcclxuICAgICAgICBmcm9tIHtmb250LXNpemU6IDEycHg7fVxyXG4gICAgICAgIHRvIHtmb250LXNpemU6IDE0cHg7fVxyXG4gICAgICB9XHJcblxyXG4gICAgICAjYm90dG9tX25hdmlnYXRpb25fY29udGFpbmVyIC5ib3R0b21fbmF2aWdhdGlvbl9hY3Rpb24ge1xyXG4gICAgICAgIGNvbG9yOiAke2NvbG9ycy5hY3RpdmV9O1xyXG4gICAgICAgIGZvbnQtc2l6ZTogMTRweDtcclxuXHJcbiAgICAgICAgbWluLXdpZHRoOiA4MHB4O1xyXG4gICAgICAgIG1heC13aWR0aDogMTY4cHg7XHJcbiAgICAgICAgZmxleC1ncm93OiAxO1xyXG5cclxuICAgICAgICBkaXNwbGF5OiBmbGV4O1xyXG4gICAgICAgIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XHJcbiAgICAgICAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XHJcbiAgICAgICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcclxuXHJcbiAgICAgICAgY3Vyc29yOiBwb2ludGVyO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAjYm90dG9tX25hdmlnYXRpb25fY29udGFpbmVyIC5ib3R0b21fbmF2aWdhdGlvbl9hY3Rpb25faW5hY3RpdmV7XHJcbiAgICAgICAgY29sb3I6ICR7Y29sb3JzLmluYWN0aXZlfTtcclxuICAgICAgICBmb250LXNpemU6IDEycHg7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgICNib3R0b21fbmF2aWdhdGlvbl9jb250YWluZXIgLmJvdHRvbV9uYXZpZ2F0aW9uX2FjdGlvbl9pbmFjdGl2ZSBpIHtcclxuICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiAke2NvbG9ycy5pbmFjdGl2ZX1cclxuICAgICAgfVxyXG4gICAgYDtcbiAgICAgICAgZG9jdW1lbnQuaGVhZC5hcHBlbmRDaGlsZCgoMCwgY29yZV9qc18xLmgpKCdzdHlsZScsIHt9LCBzdHlsZXMpKTtcbiAgICAgICAgY29uc3QgeyBwYXJlbnRJZCwgY2hpbGRyZW4gfSA9IHRoaXMucHJvcHM7XG4gICAgICAgIGNvbnN0IG5hdmlnYXRpb24gPSAoMCwgY29yZV9qc18xLmgpKCdkaXYnLCB7IGlkOiAnYm90dG9tX25hdmlnYXRpb25fY29udGFpbmVyJyB9LCBjaGlsZHJlbik7XG4gICAgICAgIGlmIChwYXJlbnRJZCkge1xuICAgICAgICAgICAgY29uc3QgcGFyZW50ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQocGFyZW50SWQpO1xuICAgICAgICAgICAgaWYgKHBhcmVudCkge1xuICAgICAgICAgICAgICAgIHBhcmVudC5hcHBlbmRDaGlsZChuYXZpZ2F0aW9uKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5hdmlnYXRpb247XG4gICAgfVxufVxuZXhwb3J0cy5OYXZpZ2F0aW9uID0gTmF2aWdhdGlvbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW5hdmlnYXRpb24uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlNoZWV0ID0gdm9pZCAwO1xuY29uc3QgY29tcG9uZW50X2pzXzEgPSByZXF1aXJlKFwiLi4vY29tcG9uZW50LmpzXCIpO1xuY29uc3QgY29yZV9qc18xID0gcmVxdWlyZShcIi4uL2NvcmUuanNcIik7XG5jb25zdCBfY29uZmlnX2pzXzEgPSByZXF1aXJlKFwiLi9fY29uZmlnLmpzXCIpO1xuY29uc3QgX2hlbHBlcnNfanNfMSA9IHJlcXVpcmUoXCIuL19oZWxwZXJzLmpzXCIpO1xuY2xhc3MgU2hlZXQgZXh0ZW5kcyBjb21wb25lbnRfanNfMS5Db21wb25lbnQge1xuICAgIHN0YXRpYyBzaG93KHNoZWV0KSB7XG4gICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoKDAsIGNvcmVfanNfMS5yZW5kZXIpKHNoZWV0KSk7XG4gICAgfVxuICAgIHN0YXRpYyBjbG9zZSgpIHtcbiAgICAgICAgY29uc3QgZWwgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdbY2xhc3NePXNoZWV0X2NvbnRhaW5lcl0nKTtcbiAgICAgICAgaWYgKGVsKVxuICAgICAgICAgICAgZWwucmVtb3ZlKCk7XG4gICAgfVxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgY29uc3QgeyBtb2RlID0gJ2N1c3RvbScsIHRpdGxlLCBzdWJ0aXRsZSB9ID0gdGhpcy5wcm9wcztcbiAgICAgICAgY29uc3QgY3NzSGFzaCA9ICgwLCBjb3JlX2pzXzEuc3RyVG9IYXNoKShgc2hlZXQke21vZGV9YCk7XG4gICAgICAgIGNvbnN0IGlzU2lkZSA9IG1vZGUgPT09ICdzaWRlJyB8fCBtb2RlID09PSAncmlnaHQnIHx8IG1vZGUgPT09ICdsZWZ0JztcbiAgICAgICAgY29uc3QgaXNCb3R0b20gPSBtb2RlID09PSAnYm90dG9tJztcbiAgICAgICAgY29uc3QgZmFkZUluID0gbW9kZSA9PT0gJ3NpZGUnID8gJ2xlZnQnIDogbW9kZTtcbiAgICAgICAgY29uc3QgYm9yZGVyUmFkaXVzID0gbW9kZSA9PT0gJ2JvdHRvbScgPyAnYm9yZGVyLXJhZGl1czogNHB4OycgOiAnJztcbiAgICAgICAgbGV0IHNoZWV0U3R5bGVzID0gJyc7XG4gICAgICAgIGlmIChpc1NpZGUpIHtcbiAgICAgICAgICAgIHNoZWV0U3R5bGVzICs9IGBcclxuICAgICAgICBtaW4td2lkdGg6IDI1NnB4O1xyXG4gICAgICAgIG1heC13aWR0aDogY2FsYygxMDB2dyAtIDU2cHgpO1xyXG4gICAgICAgIGhlaWdodDogMTAwdmg7XHJcblxyXG4gICAgICAgIHRvcDogMDtcclxuICAgICAgICAke21vZGUgPT09ICdyaWdodCcgPyAncmlnaHQnIDogJ2xlZnQnfTogMDtgO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0JvdHRvbSkge1xuICAgICAgICAgICAgc2hlZXRTdHlsZXMgKz0gYFxyXG4gICAgICAgIHdpZHRoOiAxMDB2dztcclxuICAgICAgICBib3R0b206IDBweDsgICAgICBcclxuICAgICAgICBsZWZ0OiAwO2A7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc3R5bGVzID0gYFxyXG4gICAgICBAa2V5ZnJhbWVzIHNoZWV0X2ZhZGVpbl8ke2ZhZGVJbn0tJHtjc3NIYXNofSB7XHJcbiAgICAgICAgZnJvbSB7JHtmYWRlSW59OiAtMTAwJTt9XHJcbiAgICAgICAgdG8geyR7ZmFkZUlufTogMDt9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC5zaGVldF9jb250YWluZXItJHtjc3NIYXNofSB7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC5zaGVldF9zaGVldC0ke2Nzc0hhc2h9IHtcclxuICAgICAgICBvdmVyZmxvdzogc2Nyb2xsO1xyXG4gICAgICAgIG1heC1oZWlnaHQ6IDEwMHZoO1xyXG5cclxuICAgICAgICAke3NoZWV0U3R5bGVzfVxyXG4gICAgICAgIGJhY2tncm91bmQ6IHdoaXRlO1xyXG4gICAgICAgIHBvc2l0aW9uOiBmaXhlZDtcclxuXHJcbiAgICAgICAgJHtib3JkZXJSYWRpdXN9XHJcblxyXG4gICAgICAgIGJveC1zaXppbmc6IGJvcmRlci1ib3g7XHJcbiAgICAgICAgJHtfY29uZmlnX2pzXzEuYm94U2hhZG93fVxyXG5cclxuICAgICAgICB6LWluZGV4OiAke19jb25maWdfanNfMS56SW5kZXguc2hlZXR9XHJcblxyXG4gICAgICAgIGFuaW1hdGlvbi1uYW1lOiBzaGVldF9mYWRlaW5fJHtmYWRlSW59LSR7Y3NzSGFzaH07XHJcbiAgICAgICAgYW5pbWF0aW9uLWR1cmF0aW9uOiAwLjJzO1xyXG5cclxuICAgICAgICB0cmFuc2l0aW9uOiB0b3AgMnMsIHJpZ2h0IDJzLCBib3R0b20gMnMsIGxlZnQgMnM7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC5zaGVldF9iYWNrZ3JvdW5kLSR7Y3NzSGFzaH0ge1xyXG4gICAgICAgIGJhY2tncm91bmQ6ICMwMDAwMDA3MDtcclxuICAgICAgICBwb3NpdGlvbjogZml4ZWQ7XHJcbiAgICAgICAgdG9wOiAwcHg7XHJcbiAgICAgICAgbGVmdDogMHB4O1xyXG4gICAgICAgIHdpZHRoOiAxMDB2dztcclxuICAgICAgICBoZWlnaHQ6IDEwMHZoO1xyXG4gICAgICAgIHotaW5kZXg6ICR7X2NvbmZpZ19qc18xLnpJbmRleC5zaGVldH1cclxuXHJcbiAgICAgICAgYW5pbWF0aW9uLW5hbWU6IHNoZWV0LWJhY2tncm91bmQtZmFkZWluO1xyXG4gICAgICAgIGFuaW1hdGlvbi1kdXJhdGlvbjogMC4ycztcclxuICAgICAgfVxyXG5cclxuICAgICAgQGtleWZyYW1lcyBzaGVldC1iYWNrZ3JvdW5kLWZhZGVpbiB7XHJcbiAgICAgICAgZnJvbSB7b3BhY2l0eTogMDt9XHJcbiAgICAgICAgdG8ge29wYWNpdHk6IDE7fVxyXG4gICAgICB9XHJcbiAgICAgIFxyXG4gICAgICAuc2hlZXRfdGl0bGUtJHtjc3NIYXNofSB7XHJcbiAgICAgICAgcGFkZGluZzogMjBweCAxNnB4IDBweDtcclxuICAgICAgICBmb250LXNpemU6IDI0cHg7XHJcbiAgICAgIH1cclxuICAgICAgXHJcbiAgICAgIC5zaGVldF9zdWJ0aXRsZS0ke2Nzc0hhc2h9IHtcclxuICAgICAgICBwYWRkaW5nOiA4cHggMTZweDtcclxuICAgICAgICBmb250LXNpemU6IDE0cHg7XHJcbiAgICAgICAgY29sb3I6ICMwMDAwMDBiMDtcclxuICAgICAgfWA7XG4gICAgICAgICgwLCBfaGVscGVyc19qc18xLmFkZFN0eWxlc1RvSGVhZCkoc3R5bGVzLCBjc3NIYXNoKTtcbiAgICAgICAgY29uc3QgYmFja2dyb3VuZCA9ICgwLCBjb3JlX2pzXzEuaCkoJ2RpdicsIHtcbiAgICAgICAgICAgIGNsYXNzOiBgc2hlZXRfYmFja2dyb3VuZC0ke2Nzc0hhc2h9YCxcbiAgICAgICAgICAgIG9uQ2xpY2s6ICgpID0+IHtcbiAgICAgICAgICAgICAgICBlbGVtZW50LnJlbW92ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgdCA9IHRpdGxlID8gKDAsIGNvcmVfanNfMS5oKSgnZGl2JywgeyBjbGFzczogYHNoZWV0X3RpdGxlLSR7Y3NzSGFzaH1gIH0sIHRpdGxlKSA6IG51bGw7XG4gICAgICAgIGNvbnN0IHMgPSBzdWJ0aXRsZSA/ICgwLCBjb3JlX2pzXzEuaCkoJ2RpdicsIHsgY2xhc3M6IGBzaGVldF9zdWJ0aXRsZS0ke2Nzc0hhc2h9YCB9LCBzdWJ0aXRsZSkgOiBudWxsO1xuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIGNvbnN0IHNoID0gKDAsIGNvcmVfanNfMS5oKSgnZGl2JywgeyBjbGFzczogYHNoZWV0X3NoZWV0LSR7Y3NzSGFzaH1gIH0sIHQsIHMsIHRoaXMucHJvcHMuY2hpbGRyZW4pO1xuICAgICAgICBjb25zdCBlbGVtZW50ID0gKDAsIGNvcmVfanNfMS5oKSgnZGl2JywgeyBjbGFzczogYHNoZWV0X2NvbnRhaW5lci0ke2Nzc0hhc2h9YCB9LCBiYWNrZ3JvdW5kLCBzaCk7XG4gICAgICAgIHJldHVybiBlbGVtZW50O1xuICAgIH1cbn1cbmV4cG9ydHMuU2hlZXQgPSBTaGVldDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNoZWV0LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5TbmFja2JhciA9IHZvaWQgMDtcbmNvbnN0IGNvcmVfanNfMSA9IHJlcXVpcmUoXCIuLi9jb3JlLmpzXCIpO1xuY29uc3QgX2NvbmZpZ19qc18xID0gcmVxdWlyZShcIi4vX2NvbmZpZy5qc1wiKTtcbmNsYXNzIFNuYWNrYmFyIHtcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zID0ge30pIHtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICAgICAgdGhpcy5kZWZhdWx0UGFyZW50SWQgPSAnc25hY2tiYXJfY29udGFpbmVyJztcbiAgICAgICAgdGhpcy5kZWZhdWx0QWN0aW9uQ29sb3IgPSAnI0JDODZGQyc7XG4gICAgICAgIGNvbnN0IGRlZmF1bHRPcHRpb25zID0ge1xuICAgICAgICAgICAgbWVzc2FnZTogJ0hlbGxvIFNuYWNrIScsXG4gICAgICAgICAgICBhY3Rpb25zOiBbeyBuYW1lOiAnRGlzbWlzcycsIGNvbG9yOiB0aGlzLmRlZmF1bHRBY3Rpb25Db2xvciB9XSxcbiAgICAgICAgICAgIGF1dG9IaWRlOiB0cnVlLFxuICAgICAgICAgICAgY29uc2VjdXRpdmU6IHRydWUsXG4gICAgICAgICAgICBvZmZzZXRZOiAwXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgZGVmYXVsdE9wdGlvbnMpLCBvcHRpb25zKTtcbiAgICAgICAgLy8gc3R5bGVzXG4gICAgICAgIGNvbnN0IHN0eWxlcyA9IGBcclxuICAgICAgI3NuYWNrYmFyX2NvbnRhaW5lciB7ICAgIFxyXG4gICAgICAgIHBvc2l0aW9uOiBmaXhlZDtcclxuICAgICAgICBib3R0b206ICR7dGhpcy5vcHRpb25zLm9mZnNldFl9cHg7XHJcbiAgICAgICAgbGVmdDogMHB4O1xyXG4gICAgICAgIG92ZXJmbG93OiBoaWRkZW47XHJcbiAgICAgICAgei1pbmRleDogJHtfY29uZmlnX2pzXzEuekluZGV4LnNuYWNrYmFyfVxyXG4gICAgICB9XHJcblxyXG4gICAgICAjc25hY2tiYXJfY29udGFpbmVyIC5zbmFja2Jhcl9zbmFjayB7XHJcbiAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogIzMyMzIzMjtcclxuXHJcbiAgICAgICAgcGFkZGluZzogMTZweCAxNnB4IDE2cHggMTZweDtcclxuICAgICAgICBtYXJnaW46IDBweCA4cHggOHB4IDhweDtcclxuXHJcbiAgICAgICAgYm9yZGVyLXJhZGl1czogNHB4O1xyXG4gICAgICAgIHdpZHRoOiAzNDRweDtcclxuICAgICAgICBtYXgtd2lkdGg6IGNhbGMoMTAwdncgLSAxNnB4KTtcclxuICAgICAgICBib3gtc2l6aW5nOiBib3JkZXItYm94O1xyXG4gICAgICAgIGRpc3BsYXk6IGZsZXg7XHJcbiAgICAgICAganVzdGlmeS1jb250ZW50OiBzcGFjZS1iZXR3ZWVuO1xyXG4gICAgICAgIGhlaWdodDogZml0LWNvbnRlbnQ7XHJcbiAgICAgICAgb3ZlcmZsb3c6IGhpZGRlbjtcclxuXHJcbiAgICAgICAgJHtfY29uZmlnX2pzXzEuYm94U2hhZG93fVxyXG5cclxuICAgICAgICBhbmltYXRpb24tbmFtZTogc25hY2tiYXItZmFkZWluO1xyXG4gICAgICAgIGFuaW1hdGlvbi1kdXJhdGlvbjogMC4ycztcclxuXHJcbiAgICAgICAgdHJhbnNpdGlvbjogb3BhY2l0eSAwLjJzO1xyXG4gICAgICAgIG9wYWNpdHk6IDE7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgICNzbmFja2Jhcl9jb250YWluZXIgLnNuYWNrYmFyX3NuYWNrX2ZhZGVvdXQge1xyXG4gICAgICAgIG9wYWNpdHk6IDA7XHJcbiAgICAgIH0gXHJcblxyXG4gICAgICAjc25hY2tiYXJfY29udGFpbmVyIC5zbmFja2Jhcl9zbmFjayAuc25hY2tiYXJfbWVzc2FnZSB7XHJcbiAgICAgICAgY29sb3I6ICNERkRGREY7XHJcbiAgICAgICAgZm9udC1zaXplOiAxNnB4O1xyXG4gICAgICAgIGFsaWduLXNlbGY6IGNlbnRlcjtcclxuICAgICAgfVxyXG5cclxuICAgICAgI3NuYWNrYmFyX2NvbnRhaW5lciAuc25hY2tiYXJfc25hY2sgLnNuYWNrYmFyX2FjdGlvbnMge1xyXG4gICAgICAgIGFsaWduLXNlbGY6IGNlbnRlcjtcclxuICAgICAgfVxyXG5cclxuICAgICAgI3NuYWNrYmFyX2NvbnRhaW5lciAuc25hY2tiYXJfc25hY2sgLnNuYWNrYmFyX2FjdGlvbiB7XHJcbiAgICAgICAgZm9udC1zaXplOiAxNnB4O1xyXG4gICAgICAgIGN1cnNvcjogcG9pbnRlcjtcclxuICAgICAgICBwYWRkaW5nOiA4cHg7XHJcbiAgICAgICAgbWFyZ2luLXJpZ2h0OiAtOHB4O1xyXG4gICAgICB9XHJcblxyXG4gICAgICBAa2V5ZnJhbWVzIHNuYWNrYmFyLWZhZGVpbiB7XHJcbiAgICAgICAgZnJvbSB7b3BhY2l0eTogMDt9XHJcbiAgICAgICAgdG8ge29wYWNpdHk6IDE7fVxyXG4gICAgICB9XHJcbiAgICBgO1xuICAgICAgICBkb2N1bWVudC5oZWFkLmFwcGVuZENoaWxkKCgwLCBjb3JlX2pzXzEuaCkoJ3N0eWxlJywge30sIHN0eWxlcykpO1xuICAgIH1cbiAgICBnZXRQYXJlbnRFbGVtZW50KHBhcmVudElkKSB7XG4gICAgICAgIGxldCBlbCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHBhcmVudElkIHx8IHRoaXMuZGVmYXVsdFBhcmVudElkKTtcbiAgICAgICAgaWYgKCFlbCkge1xuICAgICAgICAgICAgZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgICAgIGVsLmlkID0gdGhpcy5kZWZhdWx0UGFyZW50SWQ7XG4gICAgICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGVsKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZWw7XG4gICAgfVxuICAgIHJlbW92ZShlbCkge1xuICAgICAgICBlbC5jbGFzc0xpc3QuYWRkKCdzbmFja2Jhcl9zbmFja19mYWRlb3V0Jyk7XG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4gZWwucmVtb3ZlKCksIDIwMCk7XG4gICAgfVxuICAgIHNob3cob3B0aW9ucywgY2FsbGJhY2spIHtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5jb25zZWN1dGl2ZSkge1xuICAgICAgICAgICAgY29uc3Qgc25hY2tzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnLnNuYWNrYmFyX3NuYWNrJyk7XG4gICAgICAgICAgICBzbmFja3MuZm9yRWFjaChzID0+IHRoaXMucmVtb3ZlKHMpKTtcbiAgICAgICAgICAgIGlmIChzbmFja3MubGVuZ3RoID4gMClcbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHRoaXMuX3Nob3cob3B0aW9ucywgY2FsbGJhY2spLCAyMDAgKyAyMCk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgdGhpcy5fc2hvdyhvcHRpb25zLCBjYWxsYmFjayk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fc2hvdyhvcHRpb25zLCBjYWxsYmFjayk7XG4gICAgfVxuICAgIF9zaG93KG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gICAgICAgIG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMub3B0aW9ucyksIG9wdGlvbnMpO1xuICAgICAgICBjb25zdCBjb250YWluZXIgPSB0aGlzLmdldFBhcmVudEVsZW1lbnQob3B0aW9ucy5wYXJlbnRJZCB8fCB0aGlzLmRlZmF1bHRQYXJlbnRJZCk7XG4gICAgICAgIC8vIGFkanVzdCBvZmZzZXRZXG4gICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5vZmZzZXRZID09PSAnbnVtYmVyJylcbiAgICAgICAgICAgIGNvbnRhaW5lci5zdHlsZS5ib3R0b20gPSBgJHtvcHRpb25zLm9mZnNldFl9cHhgO1xuICAgICAgICBjb25zdCBTbmFjayA9IChfbWVzc2FnZSwgX2FjdGlvbnMpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGFjdGlvbnNBcnJheSA9IF9hY3Rpb25zLm1hcCgoYWN0aW9uKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICgwLCBjb3JlX2pzXzEuaCkoJ2EnLCB7XG4gICAgICAgICAgICAgICAgICAgIGNsYXNzOiAnc25hY2tiYXJfYWN0aW9uJyxcbiAgICAgICAgICAgICAgICAgICAgc3R5bGU6IGBjb2xvcjogJHthY3Rpb24uY29sb3IgfHwgdGhpcy5kZWZhdWx0QWN0aW9uQ29sb3J9YCxcbiAgICAgICAgICAgICAgICAgICAgb25DbGljazogKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNhbGxiYWNrKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKHsgbmFtZTogYWN0aW9uLm5hbWUsIGlkOiBhY3Rpb24uaWQgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZShlbCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LCBhY3Rpb24ubmFtZS50b1VwcGVyQ2FzZSgpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgbWVzc2FnZSA9ICgwLCBjb3JlX2pzXzEuaCkoJ2RpdicsIHsgY2xhc3M6ICdzbmFja2Jhcl9tZXNzYWdlJyB9LCBfbWVzc2FnZSk7XG4gICAgICAgICAgICBjb25zdCBhY3Rpb25zID0gKDAsIGNvcmVfanNfMS5oKSgnZGl2JywgeyBjbGFzczogJ3NuYWNrYmFyX2FjdGlvbnMnIH0sIGFjdGlvbnNBcnJheSk7XG4gICAgICAgICAgICBjb25zdCBzbmFjayA9ICgwLCBjb3JlX2pzXzEuaCkoJ2RpdicsIHsgY2xhc3M6ICdzbmFja2Jhcl9zbmFjaycgfSwgbWVzc2FnZSwgYWN0aW9ucyk7XG4gICAgICAgICAgICByZXR1cm4gc25hY2s7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGVsID0gU25hY2sob3B0aW9ucy5tZXNzYWdlLCBvcHRpb25zLmFjdGlvbnMgfHwgW10pO1xuICAgICAgICAvLyBhdXRvSGlkZSBvcHRpb25zXG4gICAgICAgIGlmIChvcHRpb25zLmF1dG9IaWRlID09PSB0cnVlKVxuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB0aGlzLnJlbW92ZShlbCksIDUwMDApO1xuICAgICAgICBlbHNlIGlmICh0eXBlb2Ygb3B0aW9ucy5hdXRvSGlkZSA9PT0gJ251bWJlcicpXG4gICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHRoaXMucmVtb3ZlKGVsKSwgb3B0aW9ucy5hdXRvSGlkZSk7XG4gICAgICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZChlbCk7XG4gICAgfVxufVxuZXhwb3J0cy5TbmFja2JhciA9IFNuYWNrYmFyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c25hY2tiYXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlRhYnMgPSBleHBvcnRzLlRhYiA9IHZvaWQgMDtcbmNvbnN0IGNvbXBvbmVudF9qc18xID0gcmVxdWlyZShcIi4uL2NvbXBvbmVudC5qc1wiKTtcbmNvbnN0IGNvcmVfanNfMSA9IHJlcXVpcmUoXCIuLi9jb3JlLmpzXCIpO1xuY29uc3QgX2NvbmZpZ19qc18xID0gcmVxdWlyZShcIi4vX2NvbmZpZy5qc1wiKTtcbmNvbnN0IF9oZWxwZXJzX2pzXzEgPSByZXF1aXJlKFwiLi9faGVscGVycy5qc1wiKTtcbmNvbnN0IFRhYiA9IChwcm9wcykgPT4ge1xuICAgIGNvbnN0IGNsYXNzZXMgPSBbcHJvcHMuaXRlbUNsYXNzLCBwcm9wcy5yaXBwbGVDbGFzc107XG4gICAgaWYgKHByb3BzLmFjdGl2ZSlcbiAgICAgICAgY2xhc3Nlcy5wdXNoKCdhY3RpdmUnKTtcbiAgICBjb25zdCBsaW5rID0gcHJvcHMuaHJlZiA/IHsgaHJlZjogcHJvcHMuaHJlZiB9IDoge307XG4gICAgY29uc3QgYSA9ICgwLCBjb3JlX2pzXzEuaCkoJ2EnLCBPYmplY3QuYXNzaWduKHt9LCBsaW5rKSwgcHJvcHMuY2hpbGRyZW4pO1xuICAgIHJldHVybiAoMCwgY29yZV9qc18xLmgpKCdsaScsIHsgY2xhc3M6IGNsYXNzZXMuam9pbignICcpLCBvbkNsaWNrOiAoKSA9PiBwcm9wcy5vbkNsaWNrSGFuZGxlcih7IGluZGV4OiBwcm9wcy5pbmRleCB9KSB9LCBhKTtcbn07XG5leHBvcnRzLlRhYiA9IFRhYjtcbmNsYXNzIFRhYnMgZXh0ZW5kcyBjb21wb25lbnRfanNfMS5Db21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLmFjdGl2ZSA9IHRoaXMucHJvcHMuYWN0aXZlIHx8IDA7XG4gICAgfVxuICAgIGRpZE1vdW50KCkge1xuICAgICAgICBjb25zdCBhZGp1c3RMaW5lID0gKGl0ZW0pID0+IHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIGlmICghaXRlbSlcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBjb25zdCBmaXJzdCA9IHRoaXMuaXRlbXNbMF0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgICAgICBjb25zdCBhY3RpdmUgPSBpdGVtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICAgICAgdGhpcy5saW5lLnN0eWxlLmxlZnQgPSBgJHthY3RpdmUueCAtIGZpcnN0Lnh9cHhgO1xuICAgICAgICAgICAgdGhpcy5saW5lLnN0eWxlLndpZHRoID0gYCR7YWN0aXZlLndpZHRofXB4YDtcbiAgICAgICAgICAgIC8vIGRpc2FibGUgb2xkXG4gICAgICAgICAgICAoX2EgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcudGFic19pdGVtLmFjdGl2ZScpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2xhc3NMaXN0LnJlbW92ZSgnYWN0aXZlJyk7XG4gICAgICAgICAgICAvLyBlbmFibGUgbmV3XG4gICAgICAgICAgICBpdGVtLmNsYXNzTGlzdC5hZGQoJ2FjdGl2ZScpO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCBzY3JvbGxJbnRvVmlldyA9IChpdGVtKSA9PiB7XG4gICAgICAgICAgICBpZiAoIXRoaXMucHJvcHMuc2Nyb2xsKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGl0ZW0uc2Nyb2xsSW50b1ZpZXcoe1xuICAgICAgICAgICAgICAgIGJlaGF2aW9yOiAnc21vb3RoJyxcbiAgICAgICAgICAgICAgICBibG9jazogJ2NlbnRlcicsXG4gICAgICAgICAgICAgICAgaW5saW5lOiAnY2VudGVyJ1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgKDAsIGNvcmVfanNfMS50aWNrKSgoKSA9PiB7XG4gICAgICAgICAgICBhZGp1c3RMaW5lKHRoaXMuaXRlbXNbdGhpcy5hY3RpdmVdKTtcbiAgICAgICAgICAgIHNjcm9sbEludG9WaWV3KHRoaXMuaXRlbXNbdGhpcy5hY3RpdmVdKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5pdGVtcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgaXRlbSA9IHRoaXMuaXRlbXNbaV07XG4gICAgICAgICAgICBpdGVtLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuYWN0aXZlID0gaTtcbiAgICAgICAgICAgICAgICAvLyBsb29rcyBoYWNreSwgYnV0IHdvcmtzIHdlbGwgOilcbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IGFkanVzdExpbmUoaXRlbSksIDUwKTtcbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IGFkanVzdExpbmUoaXRlbSksIDEwMCk7XG4gICAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiBhZGp1c3RMaW5lKGl0ZW0pLCAxNTApO1xuICAgICAgICAgICAgICAgIC8vIGRvZXMgbm90IHdvcmsgaW4gc2FmYXJpXG4gICAgICAgICAgICAgICAgc2Nyb2xsSW50b1ZpZXcoaXRlbSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgY29uc3QgcmlwcGxlID0gKDAsIF9jb25maWdfanNfMS5yaXBwbGVFZmZlY3QpKCcjZmZmZmZmNzAnLCAnIzU5MDJkYicpO1xuICAgICAgICBjb25zdCB7IHNjcm9sbCA9IGZhbHNlLCBjaGlsZHJlbiwgYWN0aXZlIH0gPSB0aGlzLnByb3BzO1xuICAgICAgICBjb25zdCBjc3NIYXNoID0gKDAsIGNvcmVfanNfMS5zdHJUb0hhc2gpKHNjcm9sbC50b1N0cmluZygpICsgKGNoaWxkcmVuID09PSBudWxsIHx8IGNoaWxkcmVuID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjaGlsZHJlbi5sZW5ndGgpICsgYWN0aXZlICsgcmlwcGxlLmNsYXNzKTtcbiAgICAgICAgY29uc3Qgc3R5bGVzID0gYFxyXG4gICAgICAudGFic19jb250YWluZXItJHtjc3NIYXNofSB7XHJcbiAgICAgICAgYmFja2dyb3VuZDogIzYyMDRlZTtcclxuXHJcbiAgICAgICAgd2lkdGg6IDEwMCU7XHJcbiAgICAgICAgaGVpZ2h0OiA0OHB4O1xyXG5cclxuICAgICAgICBvdmVyZmxvdy14OiAke3RoaXMucHJvcHMuc2Nyb2xsID8gJ3Njcm9sbCcgOiAnaGlkZGVuJ307XHJcbiAgICAgICAgb3ZlcmZsb3cteTogaGlkZGVuO1xyXG5cclxuICAgICAgICAke19jb25maWdfanNfMS51c2VyU2VsZWN0fVxyXG4gICAgICB9XHJcblxyXG4gICAgICAvKiBIaWRlIHNjcm9sbGJhciBmb3IgQ2hyb21lLCBTYWZhcmkgYW5kIE9wZXJhICovXHJcbiAgICAgIC50YWJzX2NvbnRhaW5lci0ke2Nzc0hhc2h9Ojotd2Via2l0LXNjcm9sbGJhciB7XHJcbiAgICAgICAgZGlzcGxheTogbm9uZTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLyogSGlkZSBzY3JvbGxiYXIgZm9yIElFLCBFZGdlIGFuZCBGaXJlZm94ICovXHJcbiAgICAgIC50YWJzX2NvbnRhaW5lci0ke2Nzc0hhc2h9IHtcclxuICAgICAgICAtbXMtb3ZlcmZsb3ctc3R5bGU6IG5vbmU7IC8qIElFIGFuZCBFZGdlICovXHJcbiAgICAgICAgc2Nyb2xsYmFyLXdpZHRoOiBub25lOyAvKiBGaXJlZm94ICovXHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC50YWJzX2xpc3QtJHtjc3NIYXNofSB7XHJcbiAgICAgICAgJHshdGhpcy5wcm9wcy5zY3JvbGwgPyAnZGlzcGxheTogZmxleDsganVzdGlmeS1jb250ZW50OiBzcGFjZS1ldmVubHk7JyA6ICcnfVxyXG5cclxuICAgICAgICBoZWlnaHQ6IDEwMCU7XHJcbiAgICAgICAgZGlzcGxheTogZmxleDtcclxuICAgICAgICBsaXN0LXN0eWxlLXR5cGU6IG5vbmU7XHJcbiAgICAgICAgbWFyZ2luOiAwO1xyXG4gICAgICAgIHBhZGRpbmc6IDA7XHJcbiAgICAgICAgY3Vyc29yOiBwb2ludGVyO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAudGFic19pdGVtLSR7Y3NzSGFzaH0ge1xyXG4gICAgICAgICR7IXRoaXMucHJvcHMuc2Nyb2xsID8gJ3dpZHRoOiAxMDAlOyB0ZXh0LWFsaWduOiBjZW50ZXI7JyA6ICcnfVxyXG5cclxuICAgICAgICBwYWRkaW5nLXRvcDogMTZweDtcclxuICAgICAgICBmb250LXNpemU6IDE0cHg7XHJcbiAgICAgICAgdGV4dC10cmFuc2Zvcm06IHVwcGVyY2FzZTtcclxuICAgICAgICBjb2xvcjogcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjc1KTtcclxuICAgICAgICB0cmFuc2l0aW9uOiBjb2xvciAwLjJzO1xyXG4gICAgICB9XHJcbiAgICAgIFxyXG4gICAgICBcclxuICAgICAgLnRhYnNfaXRlbS0ke2Nzc0hhc2h9IGEge1xyXG4gICAgICAgIGZvbnQtc2l6ZTogMTRweDtcclxuICAgICAgICBwYWRkaW5nOiAxNnB4IDMycHg7XHJcbiAgICAgICAgdGV4dC1kZWNvcmF0aW9uOiBub25lO1xyXG4gICAgICAgIHRleHQtdHJhbnNmb3JtOiB1cHBlcmNhc2U7XHJcbiAgICAgICAgY29sb3I6IHJnYmEoMjU1LCAyNTUsIDI1NSwgMC43NSk7XHJcbiAgICAgICAgdHJhbnNpdGlvbjogY29sb3IgMC4ycztcclxuICAgICAgfVxyXG5cclxuICAgICAgLnRhYnNfaXRlbS0ke2Nzc0hhc2h9LmFjdGl2ZSBhIHtcclxuICAgICAgICBjb2xvcjogcmdiYSgyNTUsIDI1NSwgMjU1LCAxKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLnRhYnNfaXRlbS0ke2Nzc0hhc2h9OmFjdGl2ZSB7XHJcbiAgICAgICAgYmFja2dyb3VuZDogIzU5MDJkYjtcclxuICAgICAgfVxyXG5cclxuICAgICAgLyogaWYgdGhlIHByaW1hcnkgaW5wdXQgbWVjaGFuaXNtIHN5c3RlbSBvZiB0aGUgZGV2aWNlIGNhbiBob3ZlciBvdmVyIGVsZW1lbnRzIHdpdGggZWFzZSwgd2UgdXNlIGhvdmVyICovXHJcbiAgICAgIEBtZWRpYSAoaG92ZXI6IGhvdmVyKSB7XHJcbiAgICAgICAgLnRhYnNfaXRlbS0ke2Nzc0hhc2h9OmhvdmVyIHtcclxuICAgICAgICAgIGJhY2tncm91bmQ6ICM1OTAyZGI7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICAke3JpcHBsZS5zdHlsZXN9XHJcblxyXG4gICAgICAudGFic19saW5lLSR7Y3NzSGFzaH0ge1xyXG4gICAgICAgIGJvcmRlci1ib3R0b206IDJweCBzb2xpZCB3aGl0ZTtcclxuICAgICAgICBwb3NpdGlvbjogcmVsYXRpdmU7XHJcbiAgICAgICAgdG9wOiAtMnB4O1xyXG5cclxuICAgICAgICBvcGFjaXR5OiAwO1xyXG4gICAgICAgIFxyXG4gICAgICAgIGxlZnQ6IDUwJTtcclxuICAgICAgICB3aWR0aDogMHB4O1xyXG5cclxuICAgICAgICB0cmFuc2l0aW9uOiBsZWZ0IDAuNXMsIHdpZHRoIDAuNXM7XHJcblxyXG4gICAgICAgIGFuaW1hdGlvbi1uYW1lOiB0YWJzX2xpbmVfZmFkZWluO1xyXG4gICAgICAgIGFuaW1hdGlvbi1kdXJhdGlvbjogMC4yNXM7XHJcbiAgICAgICAgYW5pbWF0aW9uLWRlbGF5OiAwLjI1cztcclxuICAgICAgICBhbmltYXRpb24tZmlsbC1tb2RlOiBmb3J3YXJkcztcclxuICAgICAgfVxyXG4gICAgICBcclxuICAgICAgQGtleWZyYW1lcyB0YWJzX2xpbmVfZmFkZWluIHtcclxuICAgICAgICBmcm9tIHtvcGFjaXR5OiAwO31cclxuICAgICAgICB0byB7b3BhY2l0eTogMTt9XHJcbiAgICAgIH1cclxuICAgICAgYDtcbiAgICAgICAgKDAsIF9oZWxwZXJzX2pzXzEuYWRkU3R5bGVzVG9IZWFkKShzdHlsZXMsIGNzc0hhc2gpO1xuICAgICAgICAvLyBzZXQgdGhlIGFjdGl2ZSB0YWJcbiAgICAgICAgKF9hID0gdGhpcy5wcm9wcy5jaGlsZHJlbikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmZvckVhY2goKGMsIGkpID0+IHtcbiAgICAgICAgICAgIC8vIGlzIGFjdGl2ZVxuICAgICAgICAgICAgaWYgKGkgPT09IHRoaXMuYWN0aXZlKVxuICAgICAgICAgICAgICAgIGMucHJvcHMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGMucHJvcHMpLCB7IGFjdGl2ZTogdHJ1ZSB9KTtcbiAgICAgICAgICAgIC8vIGFkZCByaXBwbGUgY2xhc3NcbiAgICAgICAgICAgIGMucHJvcHMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGMucHJvcHMpLCB7IHJpcHBsZUNsYXNzOiByaXBwbGUuY2xhc3MsIGl0ZW1DbGFzczogYHRhYnNfaXRlbS0ke2Nzc0hhc2h9YCwgaW5kZXg6IGkgfSk7XG4gICAgICAgICAgICAvLyBhZGQgY2xpY2sgZXZlbnRzXG4gICAgICAgICAgICBjLnByb3BzLm9uQ2xpY2tIYW5kbGVyID0gKGV2ZW50KSA9PiB0aGlzLnByb3BzLm9uQ2xpY2soZXZlbnQpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5pdGVtcyA9ICgwLCBjb3JlX2pzXzEucmVuZGVyKSh0aGlzLnByb3BzLmNoaWxkcmVuKTtcbiAgICAgICAgY29uc3QgbGlzdCA9ICgwLCBjb3JlX2pzXzEuaCkoJ3VsJywgeyBjbGFzczogYHRhYnNfbGlzdC0ke2Nzc0hhc2h9YCB9LCB0aGlzLml0ZW1zKTtcbiAgICAgICAgdGhpcy5saW5lID0gKDAsIGNvcmVfanNfMS5oKSgnZGl2JywgeyBjbGFzczogYHRhYnNfbGluZS0ke2Nzc0hhc2h9YCB9KTtcbiAgICAgICAgY29uc3QgY29udGFpbmVyID0gKDAsIGNvcmVfanNfMS5oKSgnZGl2JywgeyBjbGFzczogYHRhYnNfY29udGFpbmVyLSR7Y3NzSGFzaH1gIH0sIGxpc3QsIHRoaXMubGluZSk7XG4gICAgICAgIHJldHVybiBjb250YWluZXI7XG4gICAgfVxufVxuZXhwb3J0cy5UYWJzID0gVGFicztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRhYnMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlRvb2xiYXIgPSB2b2lkIDA7XG5jb25zdCBjb21wb25lbnRfanNfMSA9IHJlcXVpcmUoXCIuLi9jb21wb25lbnQuanNcIik7XG5jb25zdCBjb3JlX2pzXzEgPSByZXF1aXJlKFwiLi4vY29yZS5qc1wiKTtcbmNvbnN0IGNsYXNzZXMgPSB7XG4gICAgYmFyOiAndG9vbGJhcl9jb250YWluZXInLFxuICAgIGxlZnQ6ICd0b29sYmFyX2xlZnQnLFxuICAgIHJpZ2h0OiAndG9vbGJhcl9yaWdodCcsXG4gICAgaWNvbjogJ3Rvb2xiYXJfaWNvbidcbn07XG5jbGFzcyBUb29sYmFyIGV4dGVuZHMgY29tcG9uZW50X2pzXzEuQ29tcG9uZW50IHtcbiAgICBzdGF0aWMgc2V0VGl0bGUodGl0bGUpIHtcbiAgICAgICAgY29uc3QgZWwgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcudG9vbGJhcl90aXRsZScpO1xuICAgICAgICBpZiAoZWwpXG4gICAgICAgICAgICBlbC5pbm5lclRleHQgPSB0aXRsZTtcbiAgICB9XG4gICAgcmVuZGVyKCkge1xuICAgICAgICBjb25zdCBzdHlsZXMgPSBgXHJcbiAgICAgIC50b29sYmFyX2NvbnRhaW5lciB7XHJcbiAgICAgICAgcGFkZGluZzogMTZweDtcclxuICAgICAgfVxyXG5cclxuICAgICAgLnRvb2xiYXJfY29udGFpbmVyIC50b29sYmFyX3RleHQge1xyXG4gICAgICAgIGZvbnQtc2l6ZTogMjBweDtcclxuICAgICAgICBtYXJnaW4tbGVmdDogMjRweDtcclxuICAgICAgICBjdXJzb3I6IHBvaW50ZXI7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC50b29sYmFyX2NvbnRhaW5lciAudG9vbGJhcl9pY29uIHtcclxuICAgICAgICB3aWR0aDogMjJweDtcclxuICAgICAgICBoZWlnaHQ6IDIycHg7XHJcbiAgICAgICAgbWFyZ2luLWxlZnQ6IDI0cHg7XHJcbiAgICAgICAgY3Vyc29yOiBwb2ludGVyO1xyXG5cclxuICAgICAgICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XHJcbiAgICAgICAgY29udGVudDogJyc7XHJcblxyXG4gICAgICAgIC8qLXdlYmtpdC1tYXNrOiB1cmwoWU9VUl9TVkdfVVJMKSBuby1yZXBlYXQgNTAlIDUwJTtcclxuICAgICAgICBtYXNrOiB1cmwoWU9VUl9TVkdfVVJMKSBuby1yZXBlYXQgNTAlIDUwJTsqL1xyXG5cclxuICAgICAgICAtd2Via2l0LW1hc2stc2l6ZTogY292ZXI7XHJcbiAgICAgICAgbWFzay1zaXplOiBjb3ZlcjsgXHJcblxyXG4gICAgICAgIGJhY2tncm91bmQtY29sb3I6IHdoaXRlO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAudG9vbGJhcl9uYXZpZ2F0aW9uX2JveCB7XHJcbiAgICAgICAgcGFkZGluZzogNHB4O1xyXG4gICAgICAgIHdpZHRoOiAyMHB4O1xyXG4gICAgICAgIGhlaWdodDogMTZweDtcclxuICAgICAgICBtYXJnaW4tcmlnaHQ6IDMycHg7XHJcbiAgICAgICAgY3Vyc29yOiBwb2ludGVyO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAudG9vbGJhcl9oYW1idXJnZXJfYnV0dG9uLFxyXG4gICAgICAudG9vbGJhcl9oYW1idXJnZXJfYnV0dG9uOjpiZWZvcmUsXHJcbiAgICAgIC50b29sYmFyX2hhbWJ1cmdlcl9idXR0b246OmFmdGVyIHtcclxuICAgICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XHJcbiAgICAgICAgd2lkdGg6IDIwcHg7XHJcbiAgICAgICAgaGVpZ2h0OiAycHg7XHJcbiAgICAgICAgYm9yZGVyLXJhZGl1czogMnB4O1xyXG4gICAgICAgIGJhY2tncm91bmQ6IHdoaXRlO1xyXG4gICAgICAgIGNvbnRlbnQ6ICcnO1xyXG4gICAgICB9XHJcbiAgICAgIC50b29sYmFyX2hhbWJ1cmdlcl9idXR0b246OmJlZm9yZSB7XHJcbiAgICAgICAgdG9wOiA2cHg7XHJcbiAgICAgIH1cclxuICAgICAgLnRvb2xiYXJfaGFtYnVyZ2VyX2J1dHRvbjo6YWZ0ZXIge1xyXG4gICAgICAgIHRvcDogMTJweDtcclxuICAgICAgfVxyXG5cclxuICAgICAgLnRvb2xiYXJfYnV0dG9uX3dyYXBwZXIge1xyXG4gICAgICAgIHdpZHRoOiAyNHB4O1xyXG4gICAgICAgIGhlaWdodDogMjRweDtcclxuICAgICAgICBwYWRkaW5nOiAycHg7XHJcbiAgICAgICAgcG9zaXRpb246IHJlbGF0aXZlO1xyXG4gICAgICAgIHRvcDogLTJweDtcclxuICAgICAgfVxyXG5cclxuICAgICAgLnRvb2xiYXJfYmFja19idXR0b24sXHJcbiAgICAgIC50b29sYmFyX2JhY2tfYnV0dG9uOjpiZWZvcmUsXHJcbiAgICAgIC50b29sYmFyX2JhY2tfYnV0dG9uOjphZnRlciB7XHJcbiAgICAgICAgcG9zaXRpb246IHJlbGF0aXZlO1xyXG4gICAgICAgIHRvcDogN3B4O1xyXG4gICAgICAgIHdpZHRoOiAyMHB4O1xyXG4gICAgICAgIGhlaWdodDogMnB4O1xyXG4gICAgICAgIGJvcmRlci1yYWRpdXM6IDJweDtcclxuICAgICAgICBiYWNrZ3JvdW5kOiB3aGl0ZTtcclxuICAgICAgICBjb250ZW50OiAnJztcclxuICAgICAgfVxyXG5cclxuICAgICAgLnRvb2xiYXJfYmFja19idXR0b246OmJlZm9yZSB7XHJcbiAgICAgICAgcG9zaXRpb246IGFic29sdXRlO1xyXG4gICAgICAgIHRvcDogLTVweDtcclxuICAgICAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZTNkKC00cHgsMCwwKSByb3RhdGUoLTQ1ZGVnKSBzY2FsZVgoLjcpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAudG9vbGJhcl9iYWNrX2J1dHRvbjo6YWZ0ZXIge1xyXG4gICAgICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcclxuICAgICAgICB0b3A6IDVweDtcclxuICAgICAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZTNkKC00cHgsMCwwKSByb3RhdGUoNDVkZWcpIHNjYWxlWCguNyk7XHJcbiAgICAgIH1cclxuICAgIGA7XG4gICAgICAgIGRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQoKDAsIGNvcmVfanNfMS5oKSgnc3R5bGUnLCB7fSwgc3R5bGVzKSk7XG4gICAgICAgIGNvbnN0IHsgYmFjayA9IGZhbHNlLCBhY3Rpb25DbGljayA9ICgpID0+IHsgfSwgbWVudSB9ID0gdGhpcy5wcm9wcztcbiAgICAgICAgY29uc3QgbmF2aWdhdGlvbkFjdGlvbiA9IG1lbnVcbiAgICAgICAgICAgID8gKDAsIGNvcmVfanNfMS5oKSgnZGl2Jywge1xuICAgICAgICAgICAgICAgIGNsYXNzOiAndG9vbGJhcl9idXR0b25fd3JhcHBlcicsXG4gICAgICAgICAgICAgICAgb25DbGljazogYWN0aW9uQ2xpY2tcbiAgICAgICAgICAgIH0sICgwLCBjb3JlX2pzXzEuaCkoJ2RpdicsIHsgY2xhc3M6ICd0b29sYmFyX2hhbWJ1cmdlcl9idXR0b24nIH0pKVxuICAgICAgICAgICAgOiBiYWNrXG4gICAgICAgICAgICAgICAgPyAoMCwgY29yZV9qc18xLmgpKCdkaXYnLCB7XG4gICAgICAgICAgICAgICAgICAgIGNsYXNzOiAndG9vbGJhcl9idXR0b25fd3JhcHBlcicsXG4gICAgICAgICAgICAgICAgICAgIG9uQ2xpY2s6IGFjdGlvbkNsaWNrXG4gICAgICAgICAgICAgICAgfSwgKDAsIGNvcmVfanNfMS5oKSgnZGl2Jywge1xuICAgICAgICAgICAgICAgICAgICBjbGFzczogJ3Rvb2xiYXJfYmFja19idXR0b24nXG4gICAgICAgICAgICAgICAgfSkpXG4gICAgICAgICAgICAgICAgOiBudWxsO1xuICAgICAgICBjb25zdCBuYXZpZ2F0aW9uID0gbmF2aWdhdGlvbkFjdGlvbiA/ICgwLCBjb3JlX2pzXzEuaCkoJ2RpdicsIHsgY2xhc3M6ICd0b29sYmFyX25hdmlnYXRpb25fYm94JyB9LCBuYXZpZ2F0aW9uQWN0aW9uKSA6IG51bGw7XG4gICAgICAgIGNvbnN0IHRpdGxlID0gdGhpcy5wcm9wcy50aXRsZSA/ICgwLCBjb3JlX2pzXzEuaCkoJ2RpdicsIHsgY2xhc3M6ICd0b29sYmFyX3RpdGxlJyB9LCB0aGlzLnByb3BzLnRpdGxlKSA6IG51bGw7XG4gICAgICAgIGNvbnN0IGxlZnQgPSAoMCwgY29yZV9qc18xLmgpKCdkaXYnLCB7IGNsYXNzOiBjbGFzc2VzLmxlZnQgfSwgbmF2aWdhdGlvbiwgdGl0bGUpO1xuICAgICAgICBjb25zdCByaWdodCA9ICgwLCBjb3JlX2pzXzEuaCkoJ2RpdicsIHsgY2xhc3M6IGNsYXNzZXMucmlnaHQgfSwgdGhpcy5wcm9wcy5jaGlsZHJlbik7XG4gICAgICAgIGNvbnN0IGJhciA9ICgwLCBjb3JlX2pzXzEuaCkoJ2RpdicsIHsgY2xhc3M6IGNsYXNzZXMuYmFyIH0sIGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgcmV0dXJuIGJhcjtcbiAgICB9XG59XG5leHBvcnRzLlRvb2xiYXIgPSBUb29sYmFyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dG9vbGJhci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuVkVSU0lPTiA9IHZvaWQgMDtcbi8vIFRISVMgSVMgQU4gQVVUT0dFTkVSQVRFRCBGSUxFLiBETyBOT1QgRURJVCBUSElTIEZJTEUgRElSRUNUTFkuXG5leHBvcnRzLlZFUlNJT04gPSAnMC4wLjM3Jztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXZlcnNpb24uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19yZXN0ID0gKHRoaXMgJiYgdGhpcy5fX3Jlc3QpIHx8IGZ1bmN0aW9uIChzLCBlKSB7XG4gICAgdmFyIHQgPSB7fTtcbiAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkgJiYgZS5pbmRleE9mKHApIDwgMClcbiAgICAgICAgdFtwXSA9IHNbcF07XG4gICAgaWYgKHMgIT0gbnVsbCAmJiB0eXBlb2YgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyA9PT0gXCJmdW5jdGlvblwiKVxuICAgICAgICBmb3IgKHZhciBpID0gMCwgcCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMocyk7IGkgPCBwLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoZS5pbmRleE9mKHBbaV0pIDwgMCAmJiBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwocywgcFtpXSkpXG4gICAgICAgICAgICAgICAgdFtwW2ldXSA9IHNbcFtpXV07XG4gICAgICAgIH1cbiAgICByZXR1cm4gdDtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLndpdGhTdHlsZXMgPSB2b2lkIDA7XG5jb25zdCBjb3JlX2pzXzEgPSByZXF1aXJlKFwiLi9jb3JlLmpzXCIpO1xuY29uc3QgY29tcG9uZW50X2pzXzEgPSByZXF1aXJlKFwiLi9jb21wb25lbnQuanNcIik7XG5jb25zdCBmcmFnbWVudF9qc18xID0gcmVxdWlyZShcIi4vZnJhZ21lbnQuanNcIik7XG5jb25zdCBoZWxtZXRfanNfMSA9IHJlcXVpcmUoXCIuL2NvbXBvbmVudHMvaGVsbWV0LmpzXCIpO1xuY29uc3Qgd2l0aFN0eWxlcyA9ICguLi5zdHlsZXMpID0+IChXcmFwcGVkQ29tcG9uZW50KSA9PiB7XG4gICAgcmV0dXJuIGNsYXNzIGV4dGVuZHMgY29tcG9uZW50X2pzXzEuQ29tcG9uZW50IHtcbiAgICAgICAgcmVuZGVyKCkge1xuICAgICAgICAgICAgY29uc3QgX2EgPSB0aGlzLnByb3BzLCB7IGNoaWxkcmVuIH0gPSBfYSwgcmVzdCA9IF9fcmVzdChfYSwgW1wiY2hpbGRyZW5cIl0pO1xuICAgICAgICAgICAgY29uc3QgaGVsbWV0cyA9IFtdO1xuICAgICAgICAgICAgc3R5bGVzLmZvckVhY2goc3R5bGUgPT4ge1xuICAgICAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHN0eWxlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICBoZWxtZXRzLnB1c2goKDAsIGNvcmVfanNfMS5oKShoZWxtZXRfanNfMS5IZWxtZXQsIG51bGwsICgwLCBjb3JlX2pzXzEuaCkoJ3N0eWxlJywgbnVsbCwgc3R5bGUpKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBzdHlsZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBfc3R5bGUgPSBzdHlsZSgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIF9zdHlsZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlbG1ldHMucHVzaCgoMCwgY29yZV9qc18xLmgpKGhlbG1ldF9qc18xLkhlbG1ldCwgbnVsbCwgKDAsIGNvcmVfanNfMS5oKSgnc3R5bGUnLCBudWxsLCBfc3R5bGUpKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHN0eWxlID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBfc3R5bGUgPSAoX2EgPSBzdHlsZS50b1N0cmluZykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwoc3R5bGUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIF9zdHlsZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlbG1ldHMucHVzaCgoMCwgY29yZV9qc18xLmgpKGhlbG1ldF9qc18xLkhlbG1ldCwgbnVsbCwgKDAsIGNvcmVfanNfMS5oKSgnc3R5bGUnLCBudWxsLCBfc3R5bGUpKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IGNvbXBvbmVudCA9IGNoaWxkcmVuICYmIGNoaWxkcmVuLmxlbmd0aCA+IDBcbiAgICAgICAgICAgICAgICA/ICgwLCBjb3JlX2pzXzEuaCkoV3JhcHBlZENvbXBvbmVudCwgT2JqZWN0LmFzc2lnbih7fSwgcmVzdCksIGNoaWxkcmVuKVxuICAgICAgICAgICAgICAgIDogKDAsIGNvcmVfanNfMS5oKShXcmFwcGVkQ29tcG9uZW50LCBPYmplY3QuYXNzaWduKHt9LCB0aGlzLnByb3BzKSk7XG4gICAgICAgICAgICByZXR1cm4gKDAsIGNvcmVfanNfMS5oKShmcmFnbWVudF9qc18xLkZyYWdtZW50LCBudWxsLCAuLi5oZWxtZXRzLCBjb21wb25lbnQpO1xuICAgICAgICB9XG4gICAgfTtcbn07XG5leHBvcnRzLndpdGhTdHlsZXMgPSB3aXRoU3R5bGVzO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9d2l0aFN0eWxlcy5qcy5tYXAiLCIvLyBUaGUgbW9kdWxlIGNhY2hlXG52YXIgX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fID0ge307XG5cbi8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG5mdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuXHR2YXIgY2FjaGVkTW9kdWxlID0gX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fW21vZHVsZUlkXTtcblx0aWYgKGNhY2hlZE1vZHVsZSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0cmV0dXJuIGNhY2hlZE1vZHVsZS5leHBvcnRzO1xuXHR9XG5cdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG5cdHZhciBtb2R1bGUgPSBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdID0ge1xuXHRcdC8vIG5vIG1vZHVsZS5pZCBuZWVkZWRcblx0XHQvLyBubyBtb2R1bGUubG9hZGVkIG5lZWRlZFxuXHRcdGV4cG9ydHM6IHt9XG5cdH07XG5cblx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG5cdF9fd2VicGFja19tb2R1bGVzX19bbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG5cdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG5cdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbn1cblxuIiwiIiwiLy8gc3RhcnR1cFxuLy8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4vLyBUaGlzIGVudHJ5IG1vZHVsZSBpcyByZWZlcmVuY2VkIGJ5IG90aGVyIG1vZHVsZXMgc28gaXQgY2FuJ3QgYmUgaW5saW5lZFxudmFyIF9fd2VicGFja19leHBvcnRzX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiLi9saWIvYnVuZGxlcy9idW5kbGUuZnVsbC5qc1wiKTtcbiIsIiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==